{"version":3,"sources":["webpack:///vue/js/5.b8ca75b462c1146c519b.js","webpack:///./src/components/Course/CourseInfo.vue?865d","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/summernote.css","webpack:///./static/summernote/lang/summernote-zh-CN.js","webpack:///./src/components/Course/cropper.vue?0479","webpack:///./src/components/Course/vue-cropper.vue","webpack:///./src/components/Course/vue-cropper.vue?548c","webpack:///./src/components/Course/vue-cropper.vue?b38f","webpack:///./src/components/Course/CourseInfo.vue?5d70","webpack:///src/components/Course/CourseInfo.vue","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.eot","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.eot?dfc5","webpack:///./src/components/Course/cropper.vue?485c","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.ttf","webpack:///./src/components/Course/CourseInfo.vue","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/summernote.js","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.woff","webpack:///./node_modules/_codemirror@5.32.0@codemirror/lib/codemirror.js","webpack:///./src/components/Course/CourseInfo.vue?1cd1","webpack:///src/components/Course/cropper.vue","webpack:///./node_modules/_summernote@0.8.8@summernote/dist/summernote.css?7cf9","webpack:///./src/components/Course/cropper.vue","webpack:///./src/components/Course/vue-cropper.vue?6722","webpack:///src/components/Course/vue-cropper.vue","webpack:///./src/components/Course/cropper.vue?43a0","webpack:///./static/exif.js"],"names":["webpackJsonp","+N4l","module","exports","__webpack_require__","content","i","locals","/AwD","push","version","sources","names","mappings","file","sourcesContent","sourceRoot","/QYM","jQuery","$","extend","summernote","lang","zh-CN","font","bold","italic","underline","clear","height","name","strikethrough","subscript","superscript","size","image","insert","resizeFull","resizeHalf","resizeQuarter","floatLeft","floatRight","floatNone","shapeRounded","shapeCircle","shapeThumbnail","shapeNone","dragImageHere","selectFromFiles","maximumFileSize","maximumFileSizeError","url","remove","video","videoLink","providers","link","unlink","edit","textToDisplay","openInNewWindow","table","hr","style","p","blockquote","pre","h1","h2","h3","h4","h5","h6","lists","unordered","ordered","options","help","fullscreen","codeview","paragraph","outdent","indent","left","center","right","justify","color","recent","more","background","foreground","transparent","setTransparent","reset","resetToDefault","shortcut","shortcuts","close","textFormatting","action","paragraphFormatting","documentStyle","extraKeys","history","undo","redo","insertParagraph","tab","untab","removeFormat","justifyLeft","justifyCenter","justifyRight","justifyFull","insertUnorderedList","insertOrderedList","formatPara","formatH1","formatH2","formatH3","formatH4","formatH5","formatH6","insertHorizontalRule","linkDialog.show","call","/SmK","1JdY","__webpack_exports__","injectStyle","ssrContext","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_vue_cropper_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_5daee910_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_vue_cropper_vue__","normalizeComponent","__vue_styles__","Component","A5hA","DvhC","render","_vm","this","_h","$createElement","_c","_self","ref","staticClass","directives","rawName","value","loading","expression","width","trueWidth","trueHeight","transform","scale","x","y","rotate","attrs","src","imgs","alt","_v","class","cropper-move","move","crop","cropper-crop","cropper-modal","cropping","on","mousedown","startMove","touchstart","mouseover","scaleImg","mouseout","cancleScale","cropW","cropH","cropOffsertX","cropOffsertY","cropMove","top","cropInfo","_s","_e","fixedBox","$event","changeCropSize","staticRenderFns","esExports","Ln7P","staticStyle","margin-left","id","face","course","teacher","float","text-align","enctype","coverImgUrl","type","data-toggle","data-target","tabindex","role","aria-labelledby","aria-hidden","margin","transfer","isModelShow","display","data-dismiss","margin-top","click","save","Maxp","__WEBPACK_IMPORTED_MODULE_0_summernote_dist_summernote_css__","__WEBPACK_IMPORTED_MODULE_1_summernote_dist_summernote_js__","n","__WEBPACK_IMPORTED_MODULE_2__static_summernote_lang_summernote_zh_CN_js__","__WEBPACK_IMPORTED_MODULE_3_jquery__","__WEBPACK_IMPORTED_MODULE_4__cropper__","components","cropper","data","uploadcoverImgUrl","markupStr","courseId","modelSrc","isShow","urlUs","watch","methods","null","arguments","length","undefined","updateCourseInfo","console","log","_this","axios","method","description","then","response","coverBus","$emit","catch","error","alert","getCourseInfo","_this2","result","nickname","bus","body","auto","time","focus","upload","_this3","formData","FormData","append","files","config","headers","Content-Type","post","C","r","FileReader","f","document","getElementById","readAsDataURL","onload","e","beforeCreate","created","a","window","sessionStorage","getItem","$router","beforeMount","mounted","sendFile","ready","tabsize","htmlMode","disableDragAndDrop","toolbar","callbacks","onImageUpload","beforeUpdate","updated","beforeDestroy","destroyed","MbIj","OYI4","Qnm5","RUcL","Upgw","Object","defineProperty","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_CourseInfo_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_9e4d1e1c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_CourseInfo_vue__","Wj0Y","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","apply","browserVersion","isSupportAmd","isFontInstalled","fontName","testFontName","$tester","css","position","fontSize","text","appendTo","originalWidth","userAgent","navigator","isMSIE","test","matches","exec","parseFloat","isEdge","hasCodeMirror","CodeMirror","isSupportTouch","MaxTouchPoints","msMaxTouchPoints","agent","isMac","appVersion","indexOf","isFF","isPhantom","isWebkit","isChrome","isSafari","jqueryVersion","fn","jquery","isW3CRangeSupport","createRange","func","eq","itemA","itemB","eq2","peq2","propName","ok","fail","not","and","fA","fB","item","idCounter","self","invoke","obj","uniqueId","prefix","rect2bnd","rect","$document","scrollTop","scrollLeft","bottom","invertObject","inverted","key","hasOwnProperty","namespaceToCamel","namespace","split","map","substring","toUpperCase","join","debounce","wait","immediate","timeout","context","args","later","callNow","clearTimeout","setTimeout","list","head","array","last","initial","slice","tail","find","pred","idx","len","all","inArray","contains","sum","reduce","memo","v","from","collection","isEmpty","clusterBy","aLast","compact","aResult","unique","results","next","prev","NBSP_CHAR","String","fromCharCode","dom","isEditable","node","hasClass","isControlSizing","makePredByNodeName","nodeName","isText","nodeType","isElement","isVoid","isPara","isHeading","isPre","isLi","isPurePara","isTable","isData","isInline","isBodyContainer","isList","isHr","isBlockquote","isCell","isAnchor","isParaInline","ancestor","isBodyInline","isBody","isClosestSibling","nodeA","nodeB","nextSibling","previousSibling","withClosestSiblings","siblings","blankHTML","nodeLength","nodeValue","childNodes","innerHTML","paddingBlankHTML","parentNode","singleChildAncestor","listAncestor","ancestors","el","lastAncestor","filter","commonAncestor","listPrev","nodes","listNext","listDescendant","descendants","fnWalk","current","wrap","wrapperName","parent","wrapper","insertBefore","appendChild","insertAfter","preceding","appendChildNodes","aChild","each","child","isLeftEdgePoint","point","offset","isRightEdgePoint","isEdgePoint","isLeftEdgeOf","isRightEdgeOf","isLeftEdgePointOf","isRightEdgePointOf","hasChildren","prevPoint","isSkipInnerOffset","nextPoint","isSamePoint","pointA","pointB","isVisiblePoint","leftNode","rightNode","prevPointUntil","nextPointUntil","isCharPoint","ch","charAt","walkPoint","startPoint","endPoint","handler","isSkipOffset","makeOffsetPath","reverse","fromOffsetPath","offsets","splitNode","isSkipPaddingBlankHTML","isNotSplitEdgePoint","splitText","childNode","clone","cloneNode","splitTree","root","splitPoint","splitRoot","container","topAncestor","pivot","create","createElement","createText","createTextNode","isRemoveChild","removeNode","removeChild","removeWhile","replace","newNode","cssText","isTextarea","$node","stripLinebreaks","val","html","isNewlineOnBlock","markup","regexTag","match","endSlash","isEndOfInlineContainer","isBlockNode","trim","posFromPlaceholder","placeholder","$placeholder","pos","outerHeight","attachEvents","events","keys","forEach","detachEvents","off","isCustomStyleTag","classList","ZERO_WIDTH_NBSP_CHAR","blank","emptyPara","isBlock","isDiv","isBR","isSpan","isB","isU","isS","isI","isImg","isEmptyAnchor","Context","$note","ui","memos","modules","layoutInfo","initialize","createLayout","_initialize","hide","destroy","_destroy","removeData","removeLayout","disabled","isDisabled","code","disable","buttons","plugins","initializeModule","removeModule","removeMemo","triggerEvent","isActivated","codable","editable","attr","enable","callback","trigger","shouldInitialize","ModuleClass","withoutIntialize","createInvokeHandlerAndUpdateState","event","createInvokeHandler","preventDefault","$target","target","closest","splits","hasSeparator","moduleName","methodName","isExternalAPICalled","hasInitOptions","langInfo","icons","tooltip","note","first","Renderer","children","$parent","contents","className","addClass","k","$container","renderer","isArray","editor","editingArea","statusbar","airEditor","airEditable","buttonGroup","dropdown","items","template","option","dropdownButtonContents","icon","caret","dropdownCheck","checkClassName","palette","row","rowSize","colors","eventName","col","colSize","placement","dialog","fade","title","footer","popover","direction","hideArrow","checkbox","checked","iconClassName","tagName","button","toggleBtn","$btn","isEnable","toggleClass","toggleBtnActive","isActive","onDialogShown","$dialog","one","onDialogHidden","showDialog","modal","hideDialog","$editor","airMode","show","en-US","dropImage","addRowAbove","addRowBelow","addColLeft","addColRight","delRow","delCol","delTable","specialChar","select","keyMap","BACKSPACE","TAB","ENTER","SPACE","DELETE","LEFT","UP","RIGHT","DOWN","NUM0","NUM1","NUM2","NUM3","NUM4","NUM5","NUM6","NUM7","NUM8","B","E","I","J","K","L","R","S","U","V","Y","Z","SLASH","LEFTBRACKET","BACKSLASH","RIGHTBRACKET","isEdit","keyCode","isMove","nameFromCode","range","textRangeToPoint","textRange","isStart","prevContainer","parentElement","tester","createTextRange","moveToElementText","compareEndPoints","textRangeStart","curTextNode","collapse","firstChild","pointTester","duplicate","setEndPoint","textCount","cont","pointToTextRange","textRangeInfo","isCollapseToStart","prevTextNodes","collapseToStart","info","moveStart","WrappedRange","sc","so","ec","eo","nativeRange","w3cRange","setStart","setEnd","getPoints","getStartPoint","getEndPoint","nativeRng","selection","getSelection","rangeCount","removeAllRanges","addRange","scrollIntoView","offsetTop","Math","abs","normalize","getVisiblePoint","isLeftToRight","block","isCollapsed","includeAncestor","fullyContains","leftEdgeNodes","expand","startAncestor","endAncestor","boundaryPoints","isSameContainer","deleteContents","rng","emptyParents","makeIsOn","isOnEditable","isOnList","isOnAnchor","isOnCell","isOnData","wrapBodyInlineWithPara","inlineSiblings","concat","para","insertNode","pasteHTML","contentsContainer","toString","getWordRange","findAfter","bookmark","s","path","paraBookmark","paras","getClientRects","wrappedRange","createFromSelection","createFromNode","anchorNode","getRangeAt","startContainer","startOffset","endContainer","endOffset","textRangeEnd","isTextNode","createFromNodeBefore","createFromNodeAfter","createFromBookmark","createFromParaBookmark","async","readFileAsDataURL","Deferred","deferred","dataURL","resolve","onerror","reject","promise","createImage","$img","detach","History","$editable","stack","stackOffset","makeSnapshot","emptyBookmark","applySnapshot","snapshot","rewind","recordUndo","Style","jQueryCSS","$obj","propertyNames","propertyName","fromNode","properties","styleInfo","parseInt","stylePara","styleNodes","expandClosestSibling","onlyPartialContains","nodesInRange","tails","elem","$cont","font-bold","queryCommandState","font-italic","font-underline","font-subscript","font-superscript","font-strikethrough","font-family","queryCommandValue","orderedTypes","isUnordered","lineHeight","toFixed","anchor","Bullet","toggleList","clustereds","wrapList","releaseList","listName","wrappedParas","diffLists","listNode","prevList","nextList","isEscapseToBody","releasedParas","headList","lastList","middleList","rootLists","rootList","listNodes","Typing","bullet","insertTab","Array","nextPara","emptyAnchors","TableResultAction","where","domTable","setStartPoint","toLowerCase","_startPoint","colPos","cellIndex","rowPos","rowIndex","setVirtualTablePosition","baseRow","baseCell","isRowSpan","isColSpan","isVirtualCell","objPosition","isVirtual","_virtualTable","getActionCell","virtualTableCellObj","resultAction","virtualRowPosition","virtualColPosition","virtualTable","recoverCellIndex","newCellIndex","addCellInfoToVirtual","cell","cellHasColspan","colSpan","cellHasRowspan","rowSpan","isThisSelectedCell","rowspanNumber","attributes","rp","rowspanIndex","adjustStartPoint","colspanNumber","cp","cellspanIndex","isSelectedCell","createVirtualTable","rows","cells","getDeleteResultActionToCell","Column","SubtractSpanCount","Row","AddCell","RemoveCell","getAddResultActionToCell","SumSpanCount","Ignore","_actionCellList","getActionList","fixedRow","fixedCol","actualPosition","canContinue","rowPosition","colPosition","requestAction","Add","Delete","Table","isShift","nextCell","addRow","currentTr","trAttributes","recoverAttributes","vTable","actions","idCell","currentCell","tdAttributes","newTd","removeAttr","setAttribute","before","lastTrIndex","after","addCol","actionIndex","resultStr","attrList","specified","deleteRow","cellPos","index","virtualPosition","hasRowspan","nextRow","cloneRow","removeAttribute","deleteCol","hasColspan","createTable","colCount","rowCount","tdHTML","tds","idxCol","trHTML","trs","idxRow","$table","tableClassName","deleteTable","Editor","lastRange","typing","isDefaultPrevented","handleKeyMap","preventDefaultEditableShortCuts","changeEventName","outerWidth","maxHeight","minHeight","metaKey","ctrlKey","altKey","shiftKey","keyName","afterCommand","saveRange","thenCollapse","restoreRange","saveTarget","clearTarget","restoreTarget","currentStyle","styleFromNode","beforeCommand","isPreventTrigger","commands","sCmd","execCommand","tabSize","wrapCommand","insertImage","param","$image","min","insertImages","filename","maximumImageFileSize","insertImagesOrCallback","insertText","textNode","getSelectedText","formatBlock","onApplyCustomStyle","onFormatBlock","spans","firstSpan","font-size","hrNode","removeBogus","bogusNode","bogusCharIdx","deleteData","createLink","linkInfo","linkUrl","linkText","isNewWindow","isTextChanged","onCreateLink","anchors","startRange","endRange","getLinkInfo","$anchor","colorInfo","foreColor","backColor","insertTable","dim","dimension","floatMe","resize","resizeTo","bKeepRatio","imageSize","newRatio","ratio","removeMedia","hasFocus","is","empty","Clipboard","summernote.keydown","we","needKeydownHook","$paste","pasteByHook","opacity","pasteByEvent","decodedData","atob","Uint8Array","charCodeAt","blob","Blob","pasteContent","clipboardData","originalEvent","kind","getAsFile","Dropzone","documentEventHandlers","$dropzone","prependTo","detachDocumentEvent","substr","onDrop","attachDragAndDropEvent","$dropzoneMessage","onDragenter","isCodeview","hasEditorSize","add","onDragleave","removeClass","dataTransfer","types","getData","Promise","__WEBPACK_AMD_REQUIRE_ARRAY__","cm","oe","Codeview","$codable","sync","toggle","deactivate","activate","prettifyHtml","cmEditor","fromTextArea","codemirror","tern","server","TernServer","ternServer","updateArgHints","setSize","getValue","toTextArea","isChange","Statusbar","$statusbar","disableResizeEditor","stopPropagation","editableTop","onMouseMove","clientY","minheight","max","Fullscreen","$toolbar","$window","$scrollbar","h","setsize","onResize","isFullscreen","Handle","$editingArea","summernote.mousedown","update","summernote.keyup summernote.scroll summernote.change summernote.dialog.shown","summernote.disable","summernote.codeview.toggled","$handle","disableResizeImage","posStart","clientX","isImage","$selection","w","sizingText","AutoLink","linkPattern","summernote.keyup","handleKeyup","handleKeydown","lastWordRange","keyword","wordRange","AutoSync","summernote.change","Placeholder","summernote.init summernote.change","Buttons","invertedKeyMap","representShortcut","editorMethod","addToolbarButtons","addImagePopoverButtons","addLinkPopoverButtons","addTablePopoverButtons","fontInstalledMap","fontNamesIgnoreCheck","magic","styleTags","tag","eraser","menuCheck","fontNames","fontSizes","$button","currentTarget","$dropdown","$holder","$color","$currentButton","unorderedlist","orderedlist","alignLeft","alignCenter","alignRight","alignJustify","textHeight","lineHeights","insertTableMaxSize","tableMoveHandler","picture","minus","arrowsAlt","question","trash","rowAbove","rowBelow","colBefore","colAfter","rowRemove","colRemove","build","groups","groupIdx","groupLen","group","groupName","$group","updateCurrentStyle","updateBtnStates",".note-btn-bold",".note-btn-italic",".note-btn-underline",".note-btn-subscript",".note-btn-superscript",".note-btn-strikethrough","$item","isChecked","infos","selector","posOffset","$picker","$dimensionDisplay","$catcher","$highlighted","$unhighlighted","offsetX","posCatcher","pageX","pageY","offsetY","c","ceil","Toolbar","toolbarContainer","changeContainer","updateFullscreen","updateCodeview","isIncludeCodeview","LinkDialog","dialogsInBody","disableLinkTarget","dialogsFade","bindEnterKey","$input","toggleLinkBtn","$linkBtn","$linkText","$linkUrl","showLinkDialog","$openInNewWindow","handleLinkTextUpdate","handleLinkUrlUpdate","linkTargetBlank","prop","state","LinkPopover","summernote.keyup summernote.mouseup summernote.change summernote.scroll","summernote.disable summernote.dialog.shown","$popover","prepend","$content","href","ImageDialog","imageLimitation","unit","floor","readableSize","pow","showImageDialog","$imageInput","$imageUrl","$imageBtn","replaceWith","ImagePopover","posEditor","TablePopover","summernote.keyup summernote.scroll summernote.change","VideoDialog","createVideoNode","$video","ytRegExp","ytMatch","igRegExp","igMatch","vRegExp","vMatch","vimRegExp","vimMatch","dmRegExp","dmMatch","youkuRegExp","youkuMatch","qqRegExp","qqMatch","qqRegExp2","qqMatch2","mp4RegExp","mp4Match","oggRegExp","oggMatch","webmRegExp","webmMatch","youtubeId","vid","showVideoDialog","$videoUrl","$videoBtn","HelpDialog","createShortCutList","command","$row","margin-right","max-height","overflow","showHelpDialog","AirPopover","summernote.keyup summernote.mouseup summernote.scroll","summernote.disable summernote.change summernote.dialog.shown","summernote.focusout","relatedTarget","air","bnd","HintPopover","hint","hintDirection","hints","selectItem","innerHeight","moveDown","$current","$next","$nextGroup","moveUp","$prev","$prevGroup","nodeFromItem","createItemTemplates","hintIdx","searchKeyword","search","createGroup","clipboard","dropzone","handle","hintPopover","autoLink","autoSync","linkDialog","linkPopover","imageDialog","imagePopover","tablePopover","videoDialog","helpDialog","airPopover","styleWithSpan","textareaAutoSync","onInit","onFocus","onBlur","onEnter","onKeyup","onKeydown","onImageUploadError","mode","lineNumbers","pc","CTRL+Z","CTRL+Y","SHIFT+TAB","CTRL+B","CTRL+I","CTRL+U","CTRL+SHIFT+S","CTRL+BACKSLASH","CTRL+SHIFT+L","CTRL+SHIFT+E","CTRL+SHIFT+R","CTRL+SHIFT+J","CTRL+SHIFT+NUM7","CTRL+SHIFT+NUM8","CTRL+LEFTBRACKET","CTRL+RIGHTBRACKET","CTRL+NUM0","CTRL+NUM1","CTRL+NUM2","CTRL+NUM3","CTRL+NUM4","CTRL+NUM5","CTRL+NUM6","CTRL+ENTER","CTRL+K","mac","CMD+Z","CMD+SHIFT+Z","CMD+B","CMD+I","CMD+U","CMD+SHIFT+S","CMD+BACKSLASH","CMD+SHIFT+L","CMD+SHIFT+E","CMD+SHIFT+R","CMD+SHIFT+J","CMD+SHIFT+NUM7","CMD+SHIFT+NUM8","CMD+LEFTBRACKET","CMD+RIGHTBRACKET","CMD+NUM0","CMD+NUM1","CMD+NUM2","CMD+NUM3","CMD+NUM4","CMD+NUM5","CMD+NUM6","CMD+ENTER","CMD+K","align","circle","frame","pencil","square","cvcb","dRO2","global","classTest","cls","RegExp","removeChildren","count","removeChildrenAndAdd","elt","eltP","host","activeElt","activeElement","shadowRoot","joinClasses","b","as","bind","prototype","copyObj","overwrite","countColumn","string","end","startIndex","startValue","nextTab","findColumn","goal","skipped","spaceStr","spaceStrs","lst","arr","out","insertSorted","score","priority","splice","nothing","createObj","base","props","inst","isWordCharBasic","nonASCIISingleCaseWordChar","isWordChar","helper","source","isExtendingChar","extendingChars","skipExtendingChars","str","dir","findFirst","to","midF","mid","Display","place","doc","input","d","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","ie","ie_version","zIndex","paddingRight","webkit","gecko","mobile","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","getLine","Error","chunk","sz","chunkSize","getBetween","start","line","iter","getLines","updateLineHeight","diff","lineNo","cur","no","lineAtHeight","outer","i$1","lh","isLine","l","lineNumberFor","lineNumberFormatter","firstLineNumber","Pos","sticky","cmp","equalCursorPos","copyPos","maxPos","minPos","clipLine","clipPos","clipToLen","linelen","clipPosArray","seeReadOnlySpans","sawReadOnlySpans","seeCollapsedSpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","span","removeMarkedSpan","addMarkedSpan","markedSpans","attachLine","markedSpansBefore","old","startCh","isInsert","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","m","j","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","findMaxLine","iterateBidiSections","order","part","level","getBidiPartAt","bidiOther","getOrder","bidiOrdering","getHandlers","emitter","_handlers","noHandlers","removeEventListener","detachEvent","map$$1","signal","handlers","signalDOMEvent","override","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","set","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","zeroWidthElement","zwspSupported","offsetHeight","offsetWidth","hasBadBidiRects","badBidiRects","txt","r0","getBoundingClientRect","r1","hasBadZoomedRects","badZoomedRects","normal","fromRange","defineMode","dependencies","modes","defineMIME","mime","spec","mimeModes","resolveMode","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","copyState","nstate","innerMode","startState","a1","a2","highlightLine","forceToEnd","st","modeGen","lineClasses","runMode","o","overlays","baseTokens","overlay","at","i_end","opaque","baseTokenPos","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","styleClasses","highlightFrontier","modeFrontier","precise","findStartLine","saved","fromSaved","processLine","nextLine","startAt","stream","StringStream","callBlankLine","eol","readToken","blankLine","inner","token","takeToken","asArray","tokens","Token","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","SavedContext","lookAhead","indented","retreatFrontier","updateLine","estimateHeight","estHeight","cleanUpLine","interpretTokenStyle","cache","styleToClassCacheWithMode","styleToClassCache","buildLineContent","lineView","builder","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","startStyle","endStyle","displayText","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","j$1","j$2","upto","tokenText","LineView","hidden","buildViewArray","nextPos","pushOperation","op","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","cursorActivityCalled","finishOperation","endCb","signalLater","orphanDelayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","wrap$1","gutterWrap","lineNumber","gutterLeft","gutterWidth","alignable","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","wrapperWidth","coverGutter","paddingLeft","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","paddingVert","paddingH","getComputedStyle","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","ensureLineHeights","wrapping","lineWrapping","curWidth","heights","rects","mapFromLineView","updateExternalMeasurement","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","nodeAndOffsetInLineMap","mStart","mEnd","coverStart","coverEnd","getUsefulRect","nullRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","chrome","android","pageXOffset","documentElement","pageScrollY","marginTop","pageYOffset","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","get","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","mergedPos","wrappedLineExtent","begin","wrappedLineExtentChar","boxIsAfter","box","widgetHeight$$1","ltr","coordsBidiPartWrapped","coordsBidiPart","baseX","chAround","boxAround","atLeft","atStart","_lineNo","closestDist","endX","dist","measureText","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","posFromMouse","liberal","forRect","space","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","sel","ranges","primIndex","range$$1","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","cursor","cursorHeight","otherCursor","cmpCoords","fragment","rightSide","drawForLine","fromArg","toArg","wrapX","side","extent","lineLen","fromPos","toPos","openStart","openEnd","openLeft","docLTR","openRight","leftSide","topLeft","topRight","botLeft","botRight","padding","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","delayBlurEvent","delayingBlurEvent","receivedFocus","rmClass","updateHeightsInViewport","prevBottom","updateWidgetHeight","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","phantom","scrollNode","scrollPosIntoView","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","initScrollbars","scrollbarModel","scrollbarStyle","axis","startOperation","viewChanged","updateInput","changeObjs","selectionChanged","updateMaxLine","nextOpId","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","i$4","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","minWidth","takeFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","highlight","highlightWorker","Date","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","marginBottom","borderRightWidth","selectionSnapshot","active","anchorOffset","focusNode","focusOffset","restoreSelection","editorIsHidden","force","visible","viewportMargin","different","wrapperHeight","toUpdate","selSnapshot","patchDisplay","oldDisplayWidth","updateNumbersFrom","rm","currentWheelTarget","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","wheelPixelsPerUnit","onScrollWheel","scroll","canScrollX","canScrollY","presto","pixels","wheelSamples","movedX","movedY","sample","normalizeSelection","prim","sort","inv","Range","Selection","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","origin","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","somethingSelected","addSelectionToHistory","clearRedo","dest","equals","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","copy","deepCopy","newChanges","Number","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","filterSelectionChange","this$1","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","sel_dontScroll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","antiChanges","returned","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","replaceRange","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","copied","changeLine","changeType","LeafChunk","BranchChunk","adjustScrollWhenAboveVisible","addLineWidget","LineWidget","insertAt","aboveVisible","markText","markTextShared","TextMarker","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","nextMarkerId","isParent","SharedTextMarker","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","clearDragCursor","lastDrop","isReadOnly","File","read","allowDropFileTypes","reader","lineSeparator","readAsText","draggingText","text$1","selected","listSelections","replaceSelection","onDragStart","setData","effectAllowed","setDragImage","safari","img","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","ensureGlobalHandlers","globalsRegistered","registerGlobalHandlers","resizeTimer","normalizeKeyName","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","lookupKey","getKeyMap","fallthrough","isModifierKey","keyNames","addModifierNames","noShift","flipCtrlCmd","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","targetTop","moveVisually","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","res","nextCh","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","Pass","lookupKeyForEditor","keyMaps","dispatchKey","seq","keySeq","stopSeq","dispatchKeyInner","handleKeyBinding","motion","handleCharBinding","onKeyDown","handled","lastStoppedKey","hasCopyEvent","showCrossHair","up","onKeyUp","onKeyPress","charCode","clickRepeat","now","lastDoubleClick","compare","lastClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","selectingText","handleMappedButton","leftButtonDown","captureRightClick","onContextMenu","configureMouse","chromeOS","addNew","moveOnDrag","contained","behavior","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","rangeForUnit","findWordAt","extendTo","lastPos","startCol","posCol","leftPos","startSel","ourIndex","oldRange","ourRange","ranges$1","bidiSimplify","sel_mouse","curCount","counter","editorSize","anchorLine","boundary","headIndex","usePart","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","theme","guttersChanged","dragDropChanged","Init","funcs","dragFunctions","enter","over","leave","drop","wrappingChanged","CodeMirror$1","defaults","Doc","inputStyles","inputStyle","pasteIncoming","cutIncoming","Delayed","autofocus","registerEventHandlers","opt","optionHandlers","finishInit","initHooks","textRendering","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touch","radiusX","radiusY","farAway","word","inp","getField","indentLine","how","aggressive","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","setLastCopied","newLastCopied","lastCopied","applyTextInput","inserted","deleted","paste","textLines","splitLinesAuto","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","hiddenTextarea","te","div","ios","border","findPosH","findNextLine","moveOnce","boundToLine","origDir","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","posToDOM","isInGutter","scan","badPos","bad","domTextBetween","recognizeMarker","closing","lineSep","addText","walk","cmText","textContent","markerID","domToPos","lineNode","locateNodeInLineView","topNode","curNode","dist$1","textarea","tabIndex","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","getWrapperElement","platform","ie_upto10","ie_11up","edge","documentMode","qtwebkit","vendor","mac_geMountainLion","windows","presto_version","endNode","moveEnd","selectInput","selectionStart","selectionEnd","ms","sel_move","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","type$1","prev$1","type$2","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","i$7","nstart","unshift","addEventListener","attachEvent","nl","rt","hasSelection","ownerDocument","oncopy","lineOracle","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","hideFirstChars","oracle","baseToken","maxLookAhead","NativeScrollbars","vert","horiz","checkedZeroWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elementFromPoint","NullScrollbars","native","here","there","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","oldH","withOp","dHeight","nextDocId","cleanGeneration","constructor","setValue","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","dup","replaceSelections","newSel","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertSoftTab","spaces","defaultTab","transposeChars","newlineAndIndent","sels","openLine","toggleOverwrite","defineInitHook","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","poll","pollSelection","pollInterval","triggerOnKeyDown","pollContent","fromIndex","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","prepareCopyCut","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","prepareSelectAllHack","extval","rehide","oldWrapperCSS","oldCSS","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","scrollTo","mouseup","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","attach","integer","helpers","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","getScrollInfo","interpret","swapDoc","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","dontDelegate","contenteditable","defineExtension","defineDocExtension","cmpPos","k5vd","kqM6","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default","__WEBPACK_IMPORTED_MODULE_1__vue_cropper__","model","modelBtn","crap","imageU","example2","outputType","canScale","autoCrop","fixed","fixedNumber","downImg","sumitImageFile","base64Codes","forms","convertBase64UrlToBlob","$refs","cropper2","clearCrop","urlData","bytes","ab","ArrayBuffer","ia","finish2","getCropData","addDB","_this4","uploadImg","num","_this5","URL","createObjectURL","startCrop","down","_this6","aLink","download","getCropBlob","vueCropper","nCkV","o5+c","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_cropper_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_3bb4743c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_cropper_vue__","oIVi","r0eM","__WEBPACK_IMPORTED_MODULE_0__static_exif_js__","__WEBPACK_IMPORTED_MODULE_0__static_exif_js___default","moveX","moveY","cropOldW","cropOldH","canChangeX","canChangeY","changeCropTypeX","changeCropTypeY","cropX","cropY","cropChangeX","cropChangeY","support","touchNow","isIos","orientation","default","outputSize","Boolean","autoCropWidth","autoCropHeight","computed","checkedImg","reload","showPreview","canvas","Image","ctx","getContext","getAllTags","getTag","drawImage","PI","restore","toBlob","crossOrigin","moveImg","leaveImg","touchScale","cancleTouchScale","createCrop","endCrop","oldTouch1","newTouch1","oldTouch2","newTouch2","oldL","sqrt","newL","cha","coe","nowX","nowY","$nextTick","onmousewheel","changeSize","deltaY","changeScale","fw","fh","fixedHeight","typeW","typeH","changeCropNow","changeCropEnd","fixedWidth","stopCrop","moveCrop","leaveCrop","cb","_this7","imgW","imgH","_width","_height","_ctx","toDataURL","bstr","u8arr","_this8","goAutoCrop","changeCrop","rotateLeft","rotateRight","rotateClear","u","isIOS","tQYy","for","clip","accept","yOBD","imageHasData","base64ToArrayBuffer","base64","contentType","binary","buffer","objectURLToBlob","http","XMLHttpRequest","open","responseType","status","send","getImageData","handleBinaryFile","binFile","findEXIFinJPEG","exifdata","iptcdata","findIPTCinJPEG","EXIF","isXmpEnabled","xmpdata","findXMPinJPEG","arrayBuffer","fileReader","readAsArrayBuffer","debug","byteLength","dataView","DataView","getUint8","readEXIFData","getUint16","nameHeaderLength","readIPTCData","sectionLength","fieldValue","fieldName","dataSize","segmentType","segmentStartPos","IptcFieldMap","getInt16","getStringFromDB","readTags","tiffStart","dirStart","strings","bigEnd","entryOffset","entries","tags","readTagValue","vals","numerator","denominator","numValues","getUint32","valueOffset","getInt32","getNextIFDOffset","readThumbnailImage","firstIFDOffset","IFD1OffsetPointer","thumbTags","IFD1Tags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","outstr","exifData","gpsData","tiffOffset","TiffTags","ExifIFDPointer","ExifTags","StringValues","Components","GPSInfoIFDPointer","GPSTags","DOMParser","xmpString","xmpEndIndex","indexOfXmp","xml2Object","parseFromString","xml2json","xml","json","attribute","hasChildNodes","itemAtt","dataKey","dataValue","message","EXIFwrapped","Tags","36864","40960","40961","40962","40963","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","40965","42016","256","257","34665","34853","258","259","262","274","277","284","530","531","282","283","296","273","278","279","513","514","301","318","319","529","532","306","270","271","272","305","315","33432","0","1","2","4","5","6","7","10","11","12","14","15","21","22","23","24","25","26","28","29","30","ExposureProgram","MeteringMode","255","LightSource","Flash","31","65","69","71","73","77","79","89","95","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","120","55","80","85","122","105","116","enableXmp","disableXmp","HTMLImageElement","complete","getIptcTag","getAllIptcTags","pretty","strPretty","readFromBinaryFile"],"mappings":"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,EAAAO,EAAA,SrB0mkBMsoG,KACA,SAAU5wG,EAAQC,EAASC,GsBpokBjCD,EAAAD,EAAAC,QAAAC,EAAA,YAKAD,EAAAM,MAAAP,EAAAI,EAAA,2uGAAowG,IAAQI,QAAA,EAAAC,SAAA,gEAAAC,SAAAC,SAAA,mxDAAAC,KAAA,kBAAAC,gBAAA,6kJAAm/MC,WAAA,OtB6okBzvT+vG,KACA,SAAU7wG,EAAQ+H,EAAqB7H,GAE7C,YACqB,IAAI4wG,GAAgD5wG,EAAoB,QACpE6wG,EAAwD7wG,EAAoB4N,EAAEgjG,EuB9kkBvG/oG,GAAA,GvBypkBCqG,KAAM,WACL,OAECw+B,EuBvpkBH,EvBwpkBGjB,EuBvpkBH,EvBypkBGhiC,MuBvpkBH,EvBypkBGC,EuBvpkBH,EvBypkBGC,EuBvpkBH,EvBypkBGR,SuBvpkBH,EvBypkBGG,UuBvpkBH,EvBypkBGC,WuBvpkBH,EvBypkBGa,MuBvpkBH,EvBypkBG0mG,MuBvpkBH,EvBypkBGC,MuBvpkBH,EvBypkBG1mG,MuBvpkBH,EvBypkBGG,UuBvpkBH,EvBypkBGS,MuBvpkBH,EvBwpkBGC,MuBvpkBH,EvBwpkBG8lG,SuBvpkBH,EvBwpkBGC,SuBvpkBH,EvBypkBGC,YuBvpkBH,EvBwpkBGC,YuBvpkBH,EvBypkBGC,gBuBvpkBH,EvBwpkBGC,gBuBvpkBH,EvBypkBGC,MuBvpkBH,EvBwpkBGC,MuBvpkBH,EvBwpkBGC,YuBvpkBH,EvBwpkBGC,YuBvpkBH,EvBwpkBGtmG,auBvpkBH,EvBwpkBGC,auBvpkBH,EvBypkBGsmG,QuBvpkBH,GvBypkBGlpB,WACAmpB,UuBvpkBH,EvBypkBG/nG,OuBvpkBH,EvBwpkBGgoG,OuBvpkBH,EvBwpkBGC,YuBvpkBH,EvBwpkBG9nG,KuBtpkBH,KvBypkBC82C,OACCq/B,KACCxzE,KuBvpkBHuO,OvBwpkBG62F,QuBtpkBH,IvBypkBEC,YACCrlG,KuBvpkBH8sE,OvBwpkBGs4B,QuBtpkBH,GvBwpkBE1D,YACC1hG,KuBvpkBHuO,OvBwpkBG62F,QuBtpkBH,QvBwpkBE1gF,MACC1kB,KuBvpkBHslG,QvBwpkBGF,SuBtpkBH,GvBypkBEzD,UACC3hG,KuBvpkBHslG,QvBwpkBGF,SuBtpkBH,GvBypkBExD,UACC5hG,KuBvpkBHslG,QvBwpkBGF,SuBtpkBH,GvBwpkBEG,eACCvlG,KuBvpkBH8sE,OvBwpkBGs4B,QuBtpkBH,GvBwpkBEI,gBACCxlG,KuBvpkBH8sE,OvBwpkBGs4B,QuBtpkBH,GvBypkBEvD,OACC7hG,KuBvpkBHslG,QvBwpkBGF,SuBtpkBH,GvBypkBEtD,aACC9hG,KuBvpkBHkuB,MvBwpkBGk3E,QAAS,WACR,OAAQ,EuBvpkBZ,KvB2pkBEpmG,UACCgB,KuBvpkBHslG,QvBwpkBGF,SuBtpkBH,GvBypkBEpoD,MACCh9C,KuBvpkBHslG,QvBwpkBGF,SuBrpkBH,IvBwpkBCK,UACC5mG,SAAU,WACT,MAAO9C,MAAK2C,aAAe,GAAK,QuBvpkBnC,QvB0pkBCqD,OAECyxE,IAAK,WAEJz3E,KuBvpkBH2pG,cvBypkBEroG,KAAM,WACLtB,KuBvpkBH4pG,UvBypkBEpnG,MAAO,WACNxC,KAAKwC,QAAUxC,KuBvpkBlBwC,MvBwpkBGxC,KuBvpkBH6pG,evBypkBEpnG,MAAO,WACNzC,KAAKyC,QAAUzC,KuBvpkBlByC,MvBwpkBGzC,KuBvpkBH6pG,evBypkBEnnG,aAAc,WACb1C,KuBvpkBH6pG,evBypkBElnG,aAAc,WACb3C,KuBvpkBH6pG,evBypkBE7oG,MAAO,WACNhB,KuBvpkBH6pG,evBypkBE5oG,EAAG,WACFjB,KuBvpkBH6pG,evBypkBE3oG,EAAG,WACFlB,KuBvpkBH6pG,evBypkBE1oG,OAAQ,WACPnB,KuBvpkBH6pG,gBvB0pkBC5jG,SAEC0jG,WAAY,WuBvpkBd,GAAAljG,GAAAzG,IvB0pkBGA,MAAKU,SuBzpkBR,EvB0pkBGV,KAAKgB,MuBzpkBR,EvB0pkBGhB,KuBzpkBHumG,WvB0pkBG,IAAIuD,GAASnhG,SAASoR,cuBzpkBzB,UvB0pkBO09D,EAAM,GuBzpkBbsyB,OvB0pkBO5oG,EuBzpkBP,CvB0pkBGs2E,GAAI3uE,OAAS,WACZ,GAAIlI,GAAQ62E,EuBzpkBhB72E,MvB0pkBQ5H,EAASy+E,EuBzpkBjBz+E,OvB0pkBQgxG,EAAMF,EAAOG,WuBzpkBrB,KvB0pkBID,GuBzpkBJjlG,OvB0pkBIqjG,EAAsDl/F,EAAEy3B,QAAQ82C,EAAK,WAGpE,OAFA2wB,EAAsDl/F,EAAEghG,WuBzpkB7DzyB,GvB0pkBKhxE,EAAM2iG,YAAchB,EAAsDl/F,EAAEihG,OAAO1yB,EuBzpkBxF,evB0pkBahxE,EuBzpkBb2iG,avB0pkBM,IuBzpkBN,GvB0pkBOjoG,EuBzpkBP,CACA,MvB0pkBM,KuBzpkBN,GvB0pkBOA,GuBzpkBP,CACA,MvB0pkBM,KuBzpkBN,GvB0pkBOA,EuBzpkBP,CACA,MACA,SvB0pkBOA,EuBxpkBP,EvB0pkBK,GAAe,IAAXA,EuBvpkBT,YvBwpkBMsF,EAAMnF,KAAOmF,EuBzpkBnBgxE,IvB4pkBK,QuBzpkBLt2E,GvB0pkBM,IuBzpkBN,GvB0pkBO2oG,EAAOlpG,MuBzpkBdA,EvB0pkBOkpG,EAAO9wG,OuBzpkBdA,EvB0pkBOgxG,EAAII,UAAU3yB,EAAK,EAAG,EAAG72E,EuBzpkBhC5H,EACA,MvB0pkBM,KuBzpkBN,GvB0pkBM,KuBzpkBN,EvB2pkBO8wG,EAAOlpG,MuBzpkBd5H,EvB0pkBO8wG,EAAO9wG,OuBzpkBd4H,EvB0pkBOopG,EAAI7oG,OAAgB,GAATA,EAAc8oB,KAAKogF,GuBzpkBrC,KvB0pkBOL,EAAII,UAAU3yB,EAAK,GAAIz+E,EAAQ4H,EuBzpkBtC5H,EACA,MvB0pkBM,KuBzpkBN,GvB0pkBM,KuBzpkBN,EvB0pkBO8wG,EAAOlpG,MuBzpkBdA,EvB0pkBOkpG,EAAO9wG,OuBzpkBdA,EvB0pkBOgxG,EAAI7oG,OAAgB,GAATA,EAAc8oB,KAAKogF,GuBzpkBrC,KvB0pkBOL,EAAII,UAAU3yB,GAAM72E,GAAQ5H,EAAQ4H,EuBzpkB3C5H,EACA,MvB0pkBM,KuBzpkBN,GvB0pkBM,KuBzpkBN,EvB0pkBO8wG,EAAOlpG,MuBzpkBd5H,EvB0pkBO8wG,EAAO9wG,OuBzpkBd4H,EvB0pkBOop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","file":"vue/js/5.b8ca75b462c1146c519b.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ \"+N4l\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"k5vd\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"8bSs\")(\"4caeb91b\", content, true);\n\n/***/ }),\n\n/***/ \"/AwD\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"BkJT\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \"@font-face{font-family:summernote;font-style:normal;font-weight:400;src:url(\" + __webpack_require__(\"OYI4\") + \");src:url(\" + __webpack_require__(\"MbIj\") + \"?#iefix) format(\\\"embedded-opentype\\\"),url(\" + __webpack_require__(\"cvcb\") + \") format(\\\"woff\\\"),url(\" + __webpack_require__(\"RUcL\") + \") format(\\\"truetype\\\")}[class*=\\\" note-icon-\\\"]:before,[class^=note-icon-]:before{display:inline-block;font:normal normal normal 14px summernote;font-size:inherit;-webkit-font-smoothing:antialiased;text-decoration:inherit;text-rendering:auto;text-transform:none;vertical-align:middle;speak:none;-moz-osx-font-smoothing:grayscale}.note-icon-align-center:before,.note-icon-align-indent:before,.note-icon-align-justify:before,.note-icon-align-left:before,.note-icon-align-outdent:before,.note-icon-align-right:before,.note-icon-align:before,.note-icon-arrow-circle-down:before,.note-icon-arrow-circle-left:before,.note-icon-arrow-circle-right:before,.note-icon-arrow-circle-up:before,.note-icon-arrows-alt:before,.note-icon-arrows-h:before,.note-icon-arrows-v:before,.note-icon-bold:before,.note-icon-caret:before,.note-icon-chain-broken:before,.note-icon-circle:before,.note-icon-close:before,.note-icon-code:before,.note-icon-col-after:before,.note-icon-col-before:before,.note-icon-col-remove:before,.note-icon-eraser:before,.note-icon-font:before,.note-icon-frame:before,.note-icon-italic:before,.note-icon-link:before,.note-icon-magic:before,.note-icon-menu-check:before,.note-icon-minus:before,.note-icon-orderedlist:before,.note-icon-pencil:before,.note-icon-picture:before,.note-icon-question:before,.note-icon-redo:before,.note-icon-row-above:before,.note-icon-row-below:before,.note-icon-row-remove:before,.note-icon-special-character:before,.note-icon-square:before,.note-icon-strikethrough:before,.note-icon-subscript:before,.note-icon-summernote:before,.note-icon-superscript:before,.note-icon-table:before,.note-icon-text-height:before,.note-icon-trash:before,.note-icon-underline:before,.note-icon-undo:before,.note-icon-unorderedlist:before,.note-icon-video:before{display:inline-block;font-family:summernote;font-style:normal;font-weight:400;text-decoration:inherit}.note-icon-align-center:before{content:\\\"\\\\F101\\\"}.note-icon-align-indent:before{content:\\\"\\\\F102\\\"}.note-icon-align-justify:before{content:\\\"\\\\F103\\\"}.note-icon-align-left:before{content:\\\"\\\\F104\\\"}.note-icon-align-outdent:before{content:\\\"\\\\F105\\\"}.note-icon-align-right:before{content:\\\"\\\\F106\\\"}.note-icon-align:before{content:\\\"\\\\F107\\\"}.note-icon-arrow-circle-down:before{content:\\\"\\\\F108\\\"}.note-icon-arrow-circle-left:before{content:\\\"\\\\F109\\\"}.note-icon-arrow-circle-right:before{content:\\\"\\\\F10A\\\"}.note-icon-arrow-circle-up:before{content:\\\"\\\\F10B\\\"}.note-icon-arrows-alt:before{content:\\\"\\\\F10C\\\"}.note-icon-arrows-h:before{content:\\\"\\\\F10D\\\"}.note-icon-arrows-v:before{content:\\\"\\\\F10E\\\"}.note-icon-bold:before{content:\\\"\\\\F10F\\\"}.note-icon-caret:before{content:\\\"\\\\F110\\\"}.note-icon-chain-broken:before{content:\\\"\\\\F111\\\"}.note-icon-circle:before{content:\\\"\\\\F112\\\"}.note-icon-close:before{content:\\\"\\\\F113\\\"}.note-icon-code:before{content:\\\"\\\\F114\\\"}.note-icon-col-after:before{content:\\\"\\\\F115\\\"}.note-icon-col-before:before{content:\\\"\\\\F116\\\"}.note-icon-col-remove:before{content:\\\"\\\\F117\\\"}.note-icon-eraser:before{content:\\\"\\\\F118\\\"}.note-icon-font:before{content:\\\"\\\\F119\\\"}.note-icon-frame:before{content:\\\"\\\\F11A\\\"}.note-icon-italic:before{content:\\\"\\\\F11B\\\"}.note-icon-link:before{content:\\\"\\\\F11C\\\"}.note-icon-magic:before{content:\\\"\\\\F11D\\\"}.note-icon-menu-check:before{content:\\\"\\\\F11E\\\"}.note-icon-minus:before{content:\\\"\\\\F11F\\\"}.note-icon-orderedlist:before{content:\\\"\\\\F120\\\"}.note-icon-pencil:before{content:\\\"\\\\F121\\\"}.note-icon-picture:before{content:\\\"\\\\F122\\\"}.note-icon-question:before{content:\\\"\\\\F123\\\"}.note-icon-redo:before{content:\\\"\\\\F124\\\"}.note-icon-row-above:before{content:\\\"\\\\F125\\\"}.note-icon-row-below:before{content:\\\"\\\\F126\\\"}.note-icon-row-remove:before{content:\\\"\\\\F127\\\"}.note-icon-special-character:before{content:\\\"\\\\F128\\\"}.note-icon-square:before{content:\\\"\\\\F129\\\"}.note-icon-strikethrough:before{content:\\\"\\\\F12A\\\"}.note-icon-subscript:before{content:\\\"\\\\F12B\\\"}.note-icon-summernote:before{content:\\\"\\\\F12C\\\"}.note-icon-superscript:before{content:\\\"\\\\F12D\\\"}.note-icon-table:before{content:\\\"\\\\F12E\\\"}.note-icon-text-height:before{content:\\\"\\\\F12F\\\"}.note-icon-trash:before{content:\\\"\\\\F130\\\"}.note-icon-underline:before{content:\\\"\\\\F131\\\"}.note-icon-undo:before{content:\\\"\\\\F132\\\"}.note-icon-unorderedlist:before{content:\\\"\\\\F133\\\"}.note-icon-video:before{content:\\\"\\\\F134\\\"}.note-editor{position:relative}.note-editor .note-dropzone{position:absolute;z-index:100;display:none;color:#87cefa;background-color:#fff;opacity:.95}.note-editor .note-dropzone .note-dropzone-message{display:table-cell;font-size:28px;font-weight:700;text-align:center;vertical-align:middle}.note-editor .note-dropzone.hover{color:#098ddf}.note-editor.dragover .note-dropzone{display:table}.note-editor .note-editing-area{position:relative}.note-editor .note-editing-area .note-editable{outline:0}.note-editor .note-editing-area .note-editable sup{vertical-align:super}.note-editor .note-editing-area .note-editable sub{vertical-align:sub}.note-editor .note-editing-area img.note-float-left{margin-right:10px}.note-editor .note-editing-area img.note-float-right{margin-left:10px}.note-editor.note-frame{border:1px solid #a9a9a9}.note-editor.note-frame.codeview .note-editing-area .note-editable{display:none}.note-editor.note-frame.codeview .note-editing-area .note-codable{display:block}.note-editor.note-frame .note-editing-area{overflow:hidden}.note-editor.note-frame .note-editing-area .note-editable{padding:10px;overflow:auto;color:#000;background-color:#fff}.note-editor.note-frame .note-editing-area .note-editable[contenteditable=false]{background-color:#e5e5e5}.note-editor.note-frame .note-editing-area .note-codable{display:none;width:100%;padding:10px;margin-bottom:0;font-family:Menlo,Monaco,monospace,sans-serif;font-size:14px;color:#ccc;background-color:#222;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;box-shadow:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;resize:none}.note-editor.note-frame.fullscreen{position:fixed;top:0;left:0;z-index:1050;width:100%!important}.note-editor.note-frame.fullscreen .note-editable{background-color:#fff}.note-editor.note-frame.fullscreen .note-resizebar{display:none}.note-editor.note-frame .note-statusbar{background-color:#f5f5f5;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.note-editor.note-frame .note-statusbar .note-resizebar{width:100%;height:8px;padding-top:1px;cursor:ns-resize}.note-editor.note-frame .note-statusbar .note-resizebar .note-icon-bar{width:20px;margin:1px auto;border-top:1px solid #a9a9a9}.note-editor.note-frame .note-placeholder{padding:10px}.note-popover.popover{max-width:none}.note-popover.popover .popover-content a{display:inline-block;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle}.note-popover.popover .arrow{left:20px!important}.note-popover .popover-content,.panel-heading.note-toolbar{padding:0 0 5px 5px;margin:0}.note-popover .popover-content>.btn-group,.panel-heading.note-toolbar>.btn-group{margin-top:5px;margin-right:5px;margin-left:0}.note-popover .popover-content .btn-group .note-table,.panel-heading.note-toolbar .btn-group .note-table{min-width:0;padding:5px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker{font-size:18px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher{position:absolute!important;z-index:3;width:10em;height:10em;cursor:pointer}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted{position:relative!important;z-index:1;width:5em;height:5em;background:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC\\\") repeat}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted{position:absolute!important;z-index:2;width:1em;height:1em;background:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIjd6vvD2f9LKLW+AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKwNDEVT0AAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC\\\") repeat}.note-popover .popover-content .note-style blockquote,.note-popover .popover-content .note-style h1,.note-popover .popover-content .note-style h2,.note-popover .popover-content .note-style h3,.note-popover .popover-content .note-style h4,.note-popover .popover-content .note-style h5,.note-popover .popover-content .note-style h6,.panel-heading.note-toolbar .note-style blockquote,.panel-heading.note-toolbar .note-style h1,.panel-heading.note-toolbar .note-style h2,.panel-heading.note-toolbar .note-style h3,.panel-heading.note-toolbar .note-style h4,.panel-heading.note-toolbar .note-style h5,.panel-heading.note-toolbar .note-style h6{margin:0}.note-popover .popover-content .note-color .dropdown-toggle,.panel-heading.note-toolbar .note-color .dropdown-toggle{width:20px;padding-left:5px}.note-popover .popover-content .note-color .dropdown-menu,.panel-heading.note-toolbar .note-color .dropdown-menu{min-width:337px}.note-popover .popover-content .note-color .dropdown-menu .note-palette,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette{display:inline-block;width:160px;margin:0}.note-popover .popover-content .note-color .dropdown-menu .note-palette:first-child,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette:first-child{margin:0 5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-palette-title,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-palette-title{margin:2px 7px;font-size:12px;text-align:center;border-bottom:1px solid #eee}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset{width:100%;padding:0 3px;margin:3px;font-size:11px;cursor:pointer;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-row,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-row{height:20px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset:hover,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset:hover{background:#eee}.note-popover .popover-content .note-para .dropdown-menu,.panel-heading.note-toolbar .note-para .dropdown-menu{min-width:216px;padding:5px}.note-popover .popover-content .note-para .dropdown-menu>div:first-child,.panel-heading.note-toolbar .note-para .dropdown-menu>div:first-child{margin-right:5px}.note-popover .popover-content .dropdown-menu,.panel-heading.note-toolbar .dropdown-menu{min-width:90px}.note-popover .popover-content .dropdown-menu.right,.panel-heading.note-toolbar .dropdown-menu.right{right:0;left:auto}.note-popover .popover-content .dropdown-menu.right:before,.panel-heading.note-toolbar .dropdown-menu.right:before{right:9px;left:auto!important}.note-popover .popover-content .dropdown-menu.right:after,.panel-heading.note-toolbar .dropdown-menu.right:after{right:10px;left:auto!important}.note-popover .popover-content .dropdown-menu.note-check li a i,.panel-heading.note-toolbar .dropdown-menu.note-check li a i{color:#00bfff;visibility:hidden}.note-popover .popover-content .dropdown-menu.note-check li a.checked i,.panel-heading.note-toolbar .dropdown-menu.note-check li a.checked i{visibility:visible}.note-popover .popover-content .note-fontsize-10,.panel-heading.note-toolbar .note-fontsize-10{font-size:10px}.note-popover .popover-content .note-color-palette,.panel-heading.note-toolbar .note-color-palette{line-height:1}.note-popover .popover-content .note-color-palette div .note-color-btn,.panel-heading.note-toolbar .note-color-palette div .note-color-btn{width:20px;height:20px;padding:0;margin:0;border:1px solid #fff}.note-popover .popover-content .note-color-palette div .note-color-btn:hover,.panel-heading.note-toolbar .note-color-palette div .note-color-btn:hover{border:1px solid #000}.note-dialog>div{display:none}.note-dialog .form-group{margin-right:0;margin-left:0}.note-dialog .note-modal-form{margin:0}.note-dialog .note-image-dialog .note-dropzone{min-height:100px;margin-bottom:10px;font-size:30px;line-height:4;color:#d3d3d3;text-align:center;border:4px dashed #d3d3d3}@-moz-document url-prefix(){.note-image-input{height:auto}}.note-placeholder{position:absolute;display:none;color:gray}.note-handle .note-control-selection{position:absolute;display:none;border:1px solid #000}.note-handle .note-control-selection>div{position:absolute}.note-handle .note-control-selection .note-control-selection-bg{width:100%;height:100%;background-color:#000;-webkit-opacity:.3;-khtml-opacity:.3;-moz-opacity:.3;opacity:.3;-ms-filter:alpha(opacity=30);filter:alpha(opacity=30)}.note-handle .note-control-selection .note-control-handle,.note-handle .note-control-selection .note-control-holder{width:7px;height:7px;border:1px solid #000}.note-handle .note-control-selection .note-control-sizing{width:7px;height:7px;background-color:#fff;border:1px solid #000}.note-handle .note-control-selection .note-control-nw{top:-5px;left:-5px;border-right:0;border-bottom:0}.note-handle .note-control-selection .note-control-ne{top:-5px;right:-5px;border-bottom:0;border-left:none}.note-handle .note-control-selection .note-control-sw{bottom:-5px;left:-5px;border-top:0;border-right:0}.note-handle .note-control-selection .note-control-se{right:-5px;bottom:-5px;cursor:se-resize}.note-handle .note-control-selection .note-control-se.note-control-holder{cursor:default;border-top:0;border-left:none}.note-handle .note-control-selection .note-control-selection-info{right:0;bottom:0;padding:5px;margin:5px;font-size:12px;color:#fff;background-color:#000;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-opacity:.7;-khtml-opacity:.7;-moz-opacity:.7;opacity:.7;-ms-filter:alpha(opacity=70);filter:alpha(opacity=70)}.note-hint-popover{min-width:100px;padding:2px}.note-hint-popover .popover-content{max-height:150px;padding:3px;overflow:auto}.note-hint-popover .popover-content .note-hint-group .note-hint-item{display:block!important;padding:3px}.note-hint-popover .popover-content .note-hint-group .note-hint-item.active,.note-hint-popover .popover-content .note-hint-group .note-hint-item:hover{display:block;clear:both;font-weight:400;line-height:1.4;color:#fff;text-decoration:none;white-space:nowrap;cursor:pointer;background-color:#428bca;outline:0}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/node_modules/_summernote@0.8.8@summernote/dist/summernote.css\"],\"names\":[],\"mappings\":\"AAAA,WAAW,uBAAyB,kBAAkB,gBAAmB,kCAAkE,2JAAkO,CAAC,yDAA2D,qBAAqB,0CAA0C,kBAAkB,mCAAmC,wBAAwB,oBAAoB,oBAAoB,sBAAsB,WAAW,iCAAiC,CAAC,y6CAAy6C,qBAAqB,uBAAyB,kBAAkB,gBAAmB,uBAAuB,CAAC,+BAA+B,eAAe,CAAC,+BAA+B,eAAe,CAAC,gCAAgC,eAAe,CAAC,6BAA6B,eAAe,CAAC,gCAAgC,eAAe,CAAC,8BAA8B,eAAe,CAAC,wBAAwB,eAAe,CAAC,oCAAoC,eAAe,CAAC,oCAAoC,eAAe,CAAC,qCAAqC,eAAe,CAAC,kCAAkC,eAAe,CAAC,6BAA6B,eAAe,CAAC,2BAA2B,eAAe,CAAC,2BAA2B,eAAe,CAAC,uBAAuB,eAAe,CAAC,wBAAwB,eAAe,CAAC,+BAA+B,eAAe,CAAC,yBAAyB,eAAe,CAAC,wBAAwB,eAAe,CAAC,uBAAuB,eAAe,CAAC,4BAA4B,eAAe,CAAC,6BAA6B,eAAe,CAAC,6BAA6B,eAAe,CAAC,yBAAyB,eAAe,CAAC,uBAAuB,eAAe,CAAC,wBAAwB,eAAe,CAAC,yBAAyB,eAAe,CAAC,uBAAuB,eAAe,CAAC,wBAAwB,eAAe,CAAC,6BAA6B,eAAe,CAAC,wBAAwB,eAAe,CAAC,8BAA8B,eAAe,CAAC,yBAAyB,eAAe,CAAC,0BAA0B,eAAe,CAAC,2BAA2B,eAAe,CAAC,uBAAuB,eAAe,CAAC,4BAA4B,eAAe,CAAC,4BAA4B,eAAe,CAAC,6BAA6B,eAAe,CAAC,oCAAoC,eAAe,CAAC,yBAAyB,eAAe,CAAC,gCAAgC,eAAe,CAAC,4BAA4B,eAAe,CAAC,6BAA6B,eAAe,CAAC,8BAA8B,eAAe,CAAC,wBAAwB,eAAe,CAAC,8BAA8B,eAAe,CAAC,wBAAwB,eAAe,CAAC,4BAA4B,eAAe,CAAC,uBAAuB,eAAe,CAAC,gCAAgC,eAAe,CAAC,wBAAwB,eAAe,CAAC,aAAa,iBAAiB,CAAC,4BAA4B,kBAAkB,YAAY,aAAa,cAAc,sBAAuB,WAAW,CAAC,mDAAmD,mBAAmB,eAAe,gBAAiB,kBAAkB,qBAAqB,CAAC,kCAAkC,aAAa,CAAC,qCAAqC,aAAa,CAAC,gCAAgC,iBAAiB,CAAC,+CAA+C,SAAS,CAAC,mDAAmD,oBAAoB,CAAC,mDAAmD,kBAAkB,CAAC,oDAAoD,iBAAiB,CAAC,qDAAqD,gBAAgB,CAAC,wBAAwB,wBAAwB,CAAC,mEAAmE,YAAY,CAAC,kEAAkE,aAAa,CAAC,2CAA2C,eAAe,CAAC,0DAA0D,aAAa,cAAc,WAAW,qBAAqB,CAAC,iFAAmF,wBAAwB,CAAC,yDAAyD,aAAa,WAAW,aAAa,gBAAgB,8CAA8C,eAAe,WAAW,sBAAsB,SAAS,wBAAwB,qBAAqB,gBAAgB,gBAAgB,8BAA8B,2BAA2B,0BAA0B,sBAAsB,WAAW,CAAC,mCAAmC,eAAe,MAAM,OAAO,aAAa,oBAAoB,CAAC,kDAAkD,qBAAsB,CAAC,mDAAmD,YAAY,CAAC,wCAAwC,yBAAyB,+BAA+B,6BAA6B,CAAC,wDAAwD,WAAW,WAAW,gBAAgB,gBAAgB,CAAC,uEAAuE,WAAW,gBAAgB,4BAA4B,CAAC,0CAA0C,YAAY,CAAC,sBAAsB,cAAc,CAAC,yCAAyC,qBAAqB,gBAAgB,gBAAgB,uBAAuB,mBAAmB,qBAAqB,CAAC,6BAA6B,mBAAmB,CAAC,2DAA2D,oBAAoB,QAAQ,CAAC,iFAAiF,eAAe,iBAAiB,aAAa,CAAC,yGAAyG,YAAY,WAAW,CAAC,uJAAuJ,cAAc,CAAC,+NAA+N,4BAA4B,UAAU,WAAW,YAAY,cAAc,CAAC,iOAAiO,4BAA4B,UAAU,UAAU,WAAW,mRAAmR,CAAC,6NAA6N,4BAA4B,UAAU,UAAU,WAAW,mRAAmR,CAAC,+nBAA+nB,QAAQ,CAAC,qHAAqH,WAAW,gBAAgB,CAAC,iHAAiH,eAAe,CAAC,6IAA6I,qBAAqB,YAAY,QAAQ,CAAC,qKAAqK,YAAY,CAAC,qLAAqL,eAAe,eAAe,kBAAkB,4BAA4B,CAAC,iLAAiL,WAAW,cAAc,WAAW,eAAe,eAAe,0BAA0B,uBAAuB,iBAAiB,CAAC,6KAA6K,WAAW,CAAC,6LAA6L,eAAe,CAAC,+GAA+G,gBAAgB,WAAW,CAAC,+IAA+I,gBAAgB,CAAC,yFAAyF,cAAc,CAAC,qGAAqG,QAAQ,SAAS,CAAC,mHAAqH,UAAU,mBAAmB,CAAC,iHAAmH,WAAW,mBAAmB,CAAC,6HAA6H,cAAkB,iBAAiB,CAAC,6IAA6I,kBAAkB,CAAC,+FAA+F,cAAc,CAAC,mGAAmG,aAAa,CAAC,2IAA2I,WAAW,YAAY,UAAU,SAAS,qBAAqB,CAAC,uJAAuJ,qBAAqB,CAAC,iBAAiB,YAAY,CAAC,yBAAyB,eAAe,aAAa,CAAC,8BAA8B,QAAQ,CAAC,+CAA+C,iBAAiB,mBAAmB,eAAe,cAAc,cAAgB,kBAAkB,yBAA2B,CAAC,4BAA4B,kBAAkB,WAAW,CAAC,CAAC,kBAAkB,kBAAkB,aAAa,UAAU,CAAC,qCAAqC,kBAAkB,aAAa,qBAAsB,CAAC,yCAAyC,iBAAiB,CAAC,gEAAgE,WAAW,YAAY,sBAAuB,mBAAmB,kBAAkB,gBAAgB,WAAW,6BAA6B,wBAAwB,CAAC,AAAsG,oHAA0D,UAAU,WAAW,qBAAsB,CAAC,0DAA0D,UAAU,WAAW,sBAAuB,qBAAsB,CAAC,sDAAsD,SAAS,UAAU,eAAe,eAAe,CAAC,sDAAsD,SAAS,WAAW,gBAAgB,gBAAgB,CAAC,sDAAsD,YAAY,UAAU,aAAa,cAAc,CAAC,sDAAsD,WAAW,YAAY,gBAAgB,CAAC,0EAA0E,eAAe,aAAa,gBAAgB,CAAC,kEAAkE,QAAQ,SAAS,YAAY,WAAW,eAAe,WAAY,sBAAuB,0BAA0B,uBAAuB,kBAAkB,mBAAmB,kBAAkB,gBAAgB,WAAW,6BAA6B,wBAAwB,CAAC,mBAAmB,gBAAgB,WAAW,CAAC,oCAAoC,iBAAiB,YAAY,aAAa,CAAC,qEAAqE,wBAAwB,WAAW,CAAC,uJAAuJ,cAAc,WAAW,gBAAgB,gBAAgB,WAAY,qBAAqB,mBAAmB,eAAe,yBAAyB,SAAS,CAAC\",\"file\":\"summernote.css\",\"sourcesContent\":[\"@font-face{font-family:\\\"summernote\\\";font-style:normal;font-weight:normal;src:url(\\\"./font/summernote.eot?0d0d5fac99cc8774d89eb08b1a8323c4\\\");src:url(\\\"./font/summernote.eot?#iefix\\\") format(\\\"embedded-opentype\\\"),url(\\\"./font/summernote.woff?0d0d5fac99cc8774d89eb08b1a8323c4\\\") format(\\\"woff\\\"),url(\\\"./font/summernote.ttf?0d0d5fac99cc8774d89eb08b1a8323c4\\\") format(\\\"truetype\\\")}[class^=\\\"note-icon-\\\"]:before,[class*=\\\" note-icon-\\\"]:before{display:inline-block;font:normal normal normal 14px summernote;font-size:inherit;-webkit-font-smoothing:antialiased;text-decoration:inherit;text-rendering:auto;text-transform:none;vertical-align:middle;speak:none;-moz-osx-font-smoothing:grayscale}.note-icon-align-center:before,.note-icon-align-indent:before,.note-icon-align-justify:before,.note-icon-align-left:before,.note-icon-align-outdent:before,.note-icon-align-right:before,.note-icon-align:before,.note-icon-arrow-circle-down:before,.note-icon-arrow-circle-left:before,.note-icon-arrow-circle-right:before,.note-icon-arrow-circle-up:before,.note-icon-arrows-alt:before,.note-icon-arrows-h:before,.note-icon-arrows-v:before,.note-icon-bold:before,.note-icon-caret:before,.note-icon-chain-broken:before,.note-icon-circle:before,.note-icon-close:before,.note-icon-code:before,.note-icon-col-after:before,.note-icon-col-before:before,.note-icon-col-remove:before,.note-icon-eraser:before,.note-icon-font:before,.note-icon-frame:before,.note-icon-italic:before,.note-icon-link:before,.note-icon-magic:before,.note-icon-menu-check:before,.note-icon-minus:before,.note-icon-orderedlist:before,.note-icon-pencil:before,.note-icon-picture:before,.note-icon-question:before,.note-icon-redo:before,.note-icon-row-above:before,.note-icon-row-below:before,.note-icon-row-remove:before,.note-icon-special-character:before,.note-icon-square:before,.note-icon-strikethrough:before,.note-icon-subscript:before,.note-icon-summernote:before,.note-icon-superscript:before,.note-icon-table:before,.note-icon-text-height:before,.note-icon-trash:before,.note-icon-underline:before,.note-icon-undo:before,.note-icon-unorderedlist:before,.note-icon-video:before{display:inline-block;font-family:\\\"summernote\\\";font-style:normal;font-weight:normal;text-decoration:inherit}.note-icon-align-center:before{content:\\\"\\\\f101\\\"}.note-icon-align-indent:before{content:\\\"\\\\f102\\\"}.note-icon-align-justify:before{content:\\\"\\\\f103\\\"}.note-icon-align-left:before{content:\\\"\\\\f104\\\"}.note-icon-align-outdent:before{content:\\\"\\\\f105\\\"}.note-icon-align-right:before{content:\\\"\\\\f106\\\"}.note-icon-align:before{content:\\\"\\\\f107\\\"}.note-icon-arrow-circle-down:before{content:\\\"\\\\f108\\\"}.note-icon-arrow-circle-left:before{content:\\\"\\\\f109\\\"}.note-icon-arrow-circle-right:before{content:\\\"\\\\f10a\\\"}.note-icon-arrow-circle-up:before{content:\\\"\\\\f10b\\\"}.note-icon-arrows-alt:before{content:\\\"\\\\f10c\\\"}.note-icon-arrows-h:before{content:\\\"\\\\f10d\\\"}.note-icon-arrows-v:before{content:\\\"\\\\f10e\\\"}.note-icon-bold:before{content:\\\"\\\\f10f\\\"}.note-icon-caret:before{content:\\\"\\\\f110\\\"}.note-icon-chain-broken:before{content:\\\"\\\\f111\\\"}.note-icon-circle:before{content:\\\"\\\\f112\\\"}.note-icon-close:before{content:\\\"\\\\f113\\\"}.note-icon-code:before{content:\\\"\\\\f114\\\"}.note-icon-col-after:before{content:\\\"\\\\f115\\\"}.note-icon-col-before:before{content:\\\"\\\\f116\\\"}.note-icon-col-remove:before{content:\\\"\\\\f117\\\"}.note-icon-eraser:before{content:\\\"\\\\f118\\\"}.note-icon-font:before{content:\\\"\\\\f119\\\"}.note-icon-frame:before{content:\\\"\\\\f11a\\\"}.note-icon-italic:before{content:\\\"\\\\f11b\\\"}.note-icon-link:before{content:\\\"\\\\f11c\\\"}.note-icon-magic:before{content:\\\"\\\\f11d\\\"}.note-icon-menu-check:before{content:\\\"\\\\f11e\\\"}.note-icon-minus:before{content:\\\"\\\\f11f\\\"}.note-icon-orderedlist:before{content:\\\"\\\\f120\\\"}.note-icon-pencil:before{content:\\\"\\\\f121\\\"}.note-icon-picture:before{content:\\\"\\\\f122\\\"}.note-icon-question:before{content:\\\"\\\\f123\\\"}.note-icon-redo:before{content:\\\"\\\\f124\\\"}.note-icon-row-above:before{content:\\\"\\\\f125\\\"}.note-icon-row-below:before{content:\\\"\\\\f126\\\"}.note-icon-row-remove:before{content:\\\"\\\\f127\\\"}.note-icon-special-character:before{content:\\\"\\\\f128\\\"}.note-icon-square:before{content:\\\"\\\\f129\\\"}.note-icon-strikethrough:before{content:\\\"\\\\f12a\\\"}.note-icon-subscript:before{content:\\\"\\\\f12b\\\"}.note-icon-summernote:before{content:\\\"\\\\f12c\\\"}.note-icon-superscript:before{content:\\\"\\\\f12d\\\"}.note-icon-table:before{content:\\\"\\\\f12e\\\"}.note-icon-text-height:before{content:\\\"\\\\f12f\\\"}.note-icon-trash:before{content:\\\"\\\\f130\\\"}.note-icon-underline:before{content:\\\"\\\\f131\\\"}.note-icon-undo:before{content:\\\"\\\\f132\\\"}.note-icon-unorderedlist:before{content:\\\"\\\\f133\\\"}.note-icon-video:before{content:\\\"\\\\f134\\\"}.note-editor{position:relative}.note-editor .note-dropzone{position:absolute;z-index:100;display:none;color:#87cefa;background-color:white;opacity:.95}.note-editor .note-dropzone .note-dropzone-message{display:table-cell;font-size:28px;font-weight:bold;text-align:center;vertical-align:middle}.note-editor .note-dropzone.hover{color:#098ddf}.note-editor.dragover .note-dropzone{display:table}.note-editor .note-editing-area{position:relative}.note-editor .note-editing-area .note-editable{outline:0}.note-editor .note-editing-area .note-editable sup{vertical-align:super}.note-editor .note-editing-area .note-editable sub{vertical-align:sub}.note-editor .note-editing-area img.note-float-left{margin-right:10px}.note-editor .note-editing-area img.note-float-right{margin-left:10px}.note-editor.note-frame{border:1px solid #a9a9a9}.note-editor.note-frame.codeview .note-editing-area .note-editable{display:none}.note-editor.note-frame.codeview .note-editing-area .note-codable{display:block}.note-editor.note-frame .note-editing-area{overflow:hidden}.note-editor.note-frame .note-editing-area .note-editable{padding:10px;overflow:auto;color:#000;background-color:#fff}.note-editor.note-frame .note-editing-area .note-editable[contenteditable=\\\"false\\\"]{background-color:#e5e5e5}.note-editor.note-frame .note-editing-area .note-codable{display:none;width:100%;padding:10px;margin-bottom:0;font-family:Menlo,Monaco,monospace,sans-serif;font-size:14px;color:#ccc;background-color:#222;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;box-shadow:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;resize:none}.note-editor.note-frame.fullscreen{position:fixed;top:0;left:0;z-index:1050;width:100%!important}.note-editor.note-frame.fullscreen .note-editable{background-color:white}.note-editor.note-frame.fullscreen .note-resizebar{display:none}.note-editor.note-frame .note-statusbar{background-color:#f5f5f5;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.note-editor.note-frame .note-statusbar .note-resizebar{width:100%;height:8px;padding-top:1px;cursor:ns-resize}.note-editor.note-frame .note-statusbar .note-resizebar .note-icon-bar{width:20px;margin:1px auto;border-top:1px solid #a9a9a9}.note-editor.note-frame .note-placeholder{padding:10px}.note-popover.popover{max-width:none}.note-popover.popover .popover-content a{display:inline-block;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle}.note-popover.popover .arrow{left:20px!important}.note-popover .popover-content,.panel-heading.note-toolbar{padding:0 0 5px 5px;margin:0}.note-popover .popover-content>.btn-group,.panel-heading.note-toolbar>.btn-group{margin-top:5px;margin-right:5px;margin-left:0}.note-popover .popover-content .btn-group .note-table,.panel-heading.note-toolbar .btn-group .note-table{min-width:0;padding:5px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker{font-size:18px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher{position:absolute!important;z-index:3;width:10em;height:10em;cursor:pointer}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted{position:relative!important;z-index:1;width:5em;height:5em;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted{position:absolute!important;z-index:2;width:1em;height:1em;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIjd6vvD2f9LKLW+AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKwNDEVT0AAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat}.note-popover .popover-content .note-style h1,.panel-heading.note-toolbar .note-style h1,.note-popover .popover-content .note-style h2,.panel-heading.note-toolbar .note-style h2,.note-popover .popover-content .note-style h3,.panel-heading.note-toolbar .note-style h3,.note-popover .popover-content .note-style h4,.panel-heading.note-toolbar .note-style h4,.note-popover .popover-content .note-style h5,.panel-heading.note-toolbar .note-style h5,.note-popover .popover-content .note-style h6,.panel-heading.note-toolbar .note-style h6,.note-popover .popover-content .note-style blockquote,.panel-heading.note-toolbar .note-style blockquote{margin:0}.note-popover .popover-content .note-color .dropdown-toggle,.panel-heading.note-toolbar .note-color .dropdown-toggle{width:20px;padding-left:5px}.note-popover .popover-content .note-color .dropdown-menu,.panel-heading.note-toolbar .note-color .dropdown-menu{min-width:337px}.note-popover .popover-content .note-color .dropdown-menu .note-palette,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette{display:inline-block;width:160px;margin:0}.note-popover .popover-content .note-color .dropdown-menu .note-palette:first-child,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette:first-child{margin:0 5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-palette-title,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-palette-title{margin:2px 7px;font-size:12px;text-align:center;border-bottom:1px solid #eee}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset{width:100%;padding:0 3px;margin:3px;font-size:11px;cursor:pointer;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-row,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-row{height:20px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset:hover,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset:hover{background:#eee}.note-popover .popover-content .note-para .dropdown-menu,.panel-heading.note-toolbar .note-para .dropdown-menu{min-width:216px;padding:5px}.note-popover .popover-content .note-para .dropdown-menu>div:first-child,.panel-heading.note-toolbar .note-para .dropdown-menu>div:first-child{margin-right:5px}.note-popover .popover-content .dropdown-menu,.panel-heading.note-toolbar .dropdown-menu{min-width:90px}.note-popover .popover-content .dropdown-menu.right,.panel-heading.note-toolbar .dropdown-menu.right{right:0;left:auto}.note-popover .popover-content .dropdown-menu.right::before,.panel-heading.note-toolbar .dropdown-menu.right::before{right:9px;left:auto!important}.note-popover .popover-content .dropdown-menu.right::after,.panel-heading.note-toolbar .dropdown-menu.right::after{right:10px;left:auto!important}.note-popover .popover-content .dropdown-menu.note-check li a i,.panel-heading.note-toolbar .dropdown-menu.note-check li a i{color:deepskyblue;visibility:hidden}.note-popover .popover-content .dropdown-menu.note-check li a.checked i,.panel-heading.note-toolbar .dropdown-menu.note-check li a.checked i{visibility:visible}.note-popover .popover-content .note-fontsize-10,.panel-heading.note-toolbar .note-fontsize-10{font-size:10px}.note-popover .popover-content .note-color-palette,.panel-heading.note-toolbar .note-color-palette{line-height:1}.note-popover .popover-content .note-color-palette div .note-color-btn,.panel-heading.note-toolbar .note-color-palette div .note-color-btn{width:20px;height:20px;padding:0;margin:0;border:1px solid #fff}.note-popover .popover-content .note-color-palette div .note-color-btn:hover,.panel-heading.note-toolbar .note-color-palette div .note-color-btn:hover{border:1px solid #000}.note-dialog>div{display:none}.note-dialog .form-group{margin-right:0;margin-left:0}.note-dialog .note-modal-form{margin:0}.note-dialog .note-image-dialog .note-dropzone{min-height:100px;margin-bottom:10px;font-size:30px;line-height:4;color:lightgray;text-align:center;border:4px dashed lightgray}@-moz-document url-prefix(){.note-image-input{height:auto}}.note-placeholder{position:absolute;display:none;color:gray}.note-handle .note-control-selection{position:absolute;display:none;border:1px solid black}.note-handle .note-control-selection>div{position:absolute}.note-handle .note-control-selection .note-control-selection-bg{width:100%;height:100%;background-color:black;-webkit-opacity:.3;-khtml-opacity:.3;-moz-opacity:.3;opacity:.3;-ms-filter:alpha(opacity=30);filter:alpha(opacity=30)}.note-handle .note-control-selection .note-control-handle{width:7px;height:7px;border:1px solid black}.note-handle .note-control-selection .note-control-holder{width:7px;height:7px;border:1px solid black}.note-handle .note-control-selection .note-control-sizing{width:7px;height:7px;background-color:white;border:1px solid black}.note-handle .note-control-selection .note-control-nw{top:-5px;left:-5px;border-right:0;border-bottom:0}.note-handle .note-control-selection .note-control-ne{top:-5px;right:-5px;border-bottom:0;border-left:none}.note-handle .note-control-selection .note-control-sw{bottom:-5px;left:-5px;border-top:0;border-right:0}.note-handle .note-control-selection .note-control-se{right:-5px;bottom:-5px;cursor:se-resize}.note-handle .note-control-selection .note-control-se.note-control-holder{cursor:default;border-top:0;border-left:none}.note-handle .note-control-selection .note-control-selection-info{right:0;bottom:0;padding:5px;margin:5px;font-size:12px;color:white;background-color:black;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-opacity:.7;-khtml-opacity:.7;-moz-opacity:.7;opacity:.7;-ms-filter:alpha(opacity=70);filter:alpha(opacity=70)}.note-hint-popover{min-width:100px;padding:2px}.note-hint-popover .popover-content{max-height:150px;padding:3px;overflow:auto}.note-hint-popover .popover-content .note-hint-group .note-hint-item{display:block!important;padding:3px}.note-hint-popover .popover-content .note-hint-group .note-hint-item.active,.note-hint-popover .popover-content .note-hint-group .note-hint-item:hover{display:block;clear:both;font-weight:400;line-height:1.4;color:white;text-decoration:none;white-space:nowrap;cursor:pointer;background-color:#428bca;outline:0}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"/QYM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {\r\n  $.extend($.summernote.lang, {\r\n    'zh-CN': {\r\n      font: {\r\n        bold: '粗体',\r\n        italic: '斜体',\r\n        underline: '下划线',\r\n        clear: '清除格式',\r\n        height: '行高',\r\n        name: '字体',\r\n        strikethrough: '删除线',\r\n        subscript: '下标',\r\n        superscript: '上标',\r\n        size: '字号'\r\n      },\r\n      image: {\r\n        image: '图片',\r\n        insert: '插入图片',\r\n        resizeFull: '缩放至 100%',\r\n        resizeHalf: '缩放至 50%',\r\n        resizeQuarter: '缩放至 25%',\r\n        floatLeft: '靠左浮动',\r\n        floatRight: '靠右浮动',\r\n        floatNone: '取消浮动',\r\n        shapeRounded: '形状: 圆角',\r\n        shapeCircle: '形状: 圆',\r\n        shapeThumbnail: '形状: 缩略图',\r\n        shapeNone: '形状: 无',\r\n        dragImageHere: '将图片拖拽至此处',\r\n        selectFromFiles: '本地图片上传',\r\n        maximumFileSize: '文件大小最大值',\r\n        maximumFileSizeError: '文件大小超出最大值。',\r\n        url: '在线图片引用(地址)',\r\n        remove: '移除图片'\r\n      },\r\n      video: {\r\n        video: '视频',\r\n        videoLink: '视频链接',\r\n        insert: '插入视频',\r\n        url: '视频地址',\r\n        providers: '(优酷, 腾讯, Instagram, DailyMotion, Youtube等)'\r\n      },\r\n      link: {\r\n        link: '链接',\r\n        insert: '插入链接',\r\n        unlink: '去除链接',\r\n        edit: '编辑链接',\r\n        textToDisplay: '显示文本',\r\n        url: '链接地址',\r\n        openInNewWindow: '在新窗口打开'\r\n      },\r\n      table: {\r\n        table: '表格'\r\n      },\r\n      hr: {\r\n        insert: '水平线'\r\n      },\r\n      style: {\r\n        style: '样式',\r\n        p: '普通',\r\n        blockquote: '引用',\r\n        pre: '代码',\r\n        h1: '标题 1',\r\n        h2: '标题 2',\r\n        h3: '标题 3',\r\n        h4: '标题 4',\r\n        h5: '标题 5',\r\n        h6: '标题 6'\r\n      },\r\n      lists: {\r\n        unordered: '无序列表',\r\n        ordered: '有序列表'\r\n      },\r\n      options: {\r\n        help: '帮助',\r\n        fullscreen: '全屏',\r\n        codeview: '源代码'\r\n      },\r\n      paragraph: {\r\n        paragraph: '段落',\r\n        outdent: '减少缩进',\r\n        indent: '增加缩进',\r\n        left: '左对齐',\r\n        center: '居中对齐',\r\n        right: '右对齐',\r\n        justify: '两端对齐'\r\n      },\r\n      color: {\r\n        recent: '最近使用',\r\n        more: '更多',\r\n        background: '背景',\r\n        foreground: '前景',\r\n        transparent: '透明',\r\n        setTransparent: '透明',\r\n        reset: '重置',\r\n        resetToDefault: '默认'\r\n      },\r\n      shortcut: {\r\n        shortcuts: '快捷键',\r\n        close: '关闭',\r\n        textFormatting: '文本格式',\r\n        action: '动作',\r\n        paragraphFormatting: '段落格式',\r\n        documentStyle: '文档样式',\r\n        extraKeys: '额外按键'\r\n      },\r\n      history: {\r\n        undo: '撤销',\r\n        redo: '重做'\r\n      },\r\n      help: {\r\n        insertParagraph: '插入段落',\r\n        undo: '撤销',\r\n        redo: '重做',\r\n        tab: '增加缩进',\r\n        untab: '减少缩进',\r\n        bold: '粗体',\r\n        italic: '斜体',\r\n        underline: '下划线',\r\n        strikethrough: '删除线',\r\n        removeFormat: '清除格式',\r\n        justifyLeft: '左对齐',\r\n        justifyCenter: '居中对齐',\r\n        justifyRight: '右对齐',\r\n        justifyFull: '两端对齐',\r\n        insertUnorderedList: '无序列表',\r\n        insertOrderedList: '有序列表',\r\n        outdent: '减少缩进',\r\n        indent: '增加缩进',\r\n        formatPara: '设置选中内容样式为 普通',\r\n        formatH1: '设置选中内容样式为 标题1',\r\n        formatH2: '设置选中内容样式为 标题2',\r\n        formatH3: '设置选中内容样式为 标题3',\r\n        formatH4: '设置选中内容样式为 标题4',\r\n        formatH5: '设置选中内容样式为 标题5',\r\n        formatH6: '设置选中内容样式为 标题6',\r\n        insertHorizontalRule: '插入水平线',\r\n        'linkDialog.show': '显示链接对话框'\r\n      }\r\n    }\r\n  });\r\n})(jQuery);\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"jxdf\")))\n\n/***/ }),\n\n/***/ \"/SmK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"Qnm5\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"8bSs\")(\"fe083462\", content, true);\n\n/***/ }),\n\n/***/ \"1JdY\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_vue_cropper_vue__ = __webpack_require__(\"r0eM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_5daee910_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_vue_cropper_vue__ = __webpack_require__(\"DvhC\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"A5hA\")\n}\nvar normalizeComponent = __webpack_require__(\"/Xao\")\n/* script */\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-5daee910\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_vue_cropper_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_5daee910_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_vue_cropper_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"A5hA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"oIVi\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"8bSs\")(\"075b8c6e\", content, true);\n\n/***/ }),\n\n/***/ \"DvhC\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:\"cropper\",staticClass:\"vue-cropper\"},[_c('div',{staticClass:\"cropper-box\"},[_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.loading),expression:\"!loading\"}],staticClass:\"cropper-box-canvas\",style:({\n\t\t\t\t\t'width': _vm.trueWidth + 'px',\n\t\t\t\t\t'height': _vm.trueHeight + 'px',\n\t\t\t\t\t'transform': 'scale(' + _vm.scale + ',' + _vm.scale + ') ' + 'translate3d('+ _vm.x / _vm.scale + 'px,' + _vm.y / _vm.scale + 'px,' + '0)'\n\t\t\t\t\t+ 'rotateZ('+ _vm.rotate * 90 +'deg)'\n\t\t\t\t\t})},[_c('img',{ref:\"cropperImg\",attrs:{\"src\":_vm.imgs,\"alt\":\"cropper-img\"}})])]),_vm._v(\" \"),_c('div',{staticClass:\"cropper-drag-box\",class:{'cropper-move': _vm.move && !_vm.crop, 'cropper-crop': _vm.crop, 'cropper-modal': _vm.cropping},on:{\"mousedown\":_vm.startMove,\"touchstart\":_vm.startMove,\"mouseover\":_vm.scaleImg,\"mouseout\":_vm.cancleScale}}),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.cropping),expression:\"cropping\"}],staticClass:\"cropper-crop-box\",style:({\n\t\t\t\t\t'width': _vm.cropW + 'px',\n\t\t\t\t\t'height': _vm.cropH + 'px',\n\t\t\t\t\t'transform': 'translate3d('+ _vm.cropOffsertX + 'px,' + _vm.cropOffsertY + 'px,' + '0)'\n\t\t\t\t})},[_c('span',{staticClass:\"cropper-view-box\"},[_c('img',{style:({\n\t\t\t\t\t\t'width': _vm.trueWidth + 'px',\n\t\t\t\t\t\t'height': _vm.trueHeight + 'px',\n\t\t\t\t\t\t'transform': 'scale(' + _vm.scale + ',' + _vm.scale + ') ' + 'translate3d('+ (_vm.x - _vm.cropOffsertX) / _vm.scale  + 'px,' + (_vm.y - _vm.cropOffsertY) / _vm.scale + 'px,' + '0)'\n\t\t\t\t\t\t+ 'rotateZ('+ _vm.rotate * 90 +'deg)'\n\t\t\t\t\t\t}),attrs:{\"src\":_vm.imgs,\"alt\":\"cropper-img\"}})]),_vm._v(\" \"),_c('span',{staticClass:\"cropper-face cropper-move\",on:{\"mousedown\":_vm.cropMove,\"touchstart\":_vm.cropMove}}),_vm._v(\" \"),(_vm.info)?_c('span',{staticClass:\"crop-info\",style:({'top': _vm.cropInfo})},[_vm._v(_vm._s(this.cropW)+\" × \"+_vm._s(this.cropH))]):_vm._e(),_vm._v(\" \"),(!_vm.fixedBox)?_c('span',[_c('span',{staticClass:\"crop-line line-w\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-a\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 1, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 1, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-s\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-d\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 2, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 2, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point1\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 1, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 1, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point2\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point3\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 2, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 2, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point4\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 1, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 1, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point5\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 2, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 2, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point6\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 1, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 1, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point7\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point8\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 2, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 2, 2)}}})]):_vm._e()])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"Ln7P\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticStyle:{\"margin-left\":\"1%\"},attrs:{\"id\":\"CourseInfo\"}},[_c('div',{staticClass:\"col-md-12 \"},[_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"12\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程信息\")])],1),_c('p'),_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程名称：  \"+_vm._s(_vm.course))])],1),_vm._v(\" \"),_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"授课教师：  \"+_vm._s(_vm.teacher))])],1),_vm._v(\" \"),_c('div',[_c('p',{staticClass:\"text-left\",staticStyle:{\"float\":\"left\",\"text-align\":\"center\"}},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程图片： \")])],1),_vm._v(\" \"),_c('form',{attrs:{\"id\":\"uploadForm\",\"enctype\":\"multipart/form-data\"}},[_c('p',{staticClass:\"text-left\"},[_c('img',{staticStyle:{\"float\":\"left\",\"text-align\":\"center\"},attrs:{\"src\":_vm.coverImgUrl,\"id\":\"show\"}}),_c('br'),_vm._v(\" \"),_c('button',{staticClass:\"btn input-file\",attrs:{\"id\":\"cropper-vue\",\"type\":\"button\",\"data-toggle\":\"modal\",\"data-target\":\"#myModal\"}},[_vm._v(\"∧选择课程方面\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"modal fade\",attrs:{\"id\":\"myModal\",\"tabindex\":\"-1\",\"role\":\"dialog\",\"aria-labelledby\":\"myModalLabel\",\"aria-hidden\":\"true\"}},[_c('div',{staticClass:\"modal-dialog\",staticStyle:{\"width\":\"85%\"}},[_c('div',{staticClass:\"modal-content\",staticStyle:{\"height\":\"650px\"}},[_c('cropper',{staticStyle:{\"margin\":\"1% auto auto auto\"},on:{\"transfer\":_vm.transfer,\"isModelShow\":_vm.isModelShow}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-default btn-close\",staticStyle:{\"display\":\"none\"},attrs:{\"id\":\"model-close\",\"type\":\"button\",\"data-dismiss\":\"modal\"}},[_vm._v(\"关闭\")])],1)])]),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"10%\",\"height\":\"200px\"}},[_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程简介：\")])],1),_vm._v(\" \"),_c('div',{staticClass:\"summernote\",attrs:{\"id\":\"summernote\"}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"45%\"},attrs:{\"id\":\"save\"},on:{\"click\":_vm.save}},[_vm._v(\"保存\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-info\",attrs:{\"id\":\"edit\"},on:{\"click\":_vm.edit}},[_vm._v(\"编辑\")])])])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"Maxp\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_summernote_dist_summernote_css__ = __webpack_require__(\"nCkV\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_summernote_dist_summernote_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_summernote_dist_summernote_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_summernote_dist_summernote_js__ = __webpack_require__(\"Wj0Y\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_summernote_dist_summernote_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_summernote_dist_summernote_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__static_summernote_lang_summernote_zh_CN_js__ = __webpack_require__(\"/QYM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__static_summernote_lang_summernote_zh_CN_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__static_summernote_lang_summernote_zh_CN_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(\"jxdf\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cropper__ = __webpack_require__(\"o5+c\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n// import CustomModel from './model'\n\n//summernote富文本\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  name: 'classname',\n  components: {\n    //  'CustomModel': CustomModel,\n    cropper: __WEBPACK_IMPORTED_MODULE_4__cropper__[\"a\" /* default */]\n  },\n  data: function data() {\n    return {\n      name: 'classname',\n      course: '',\n      teacher: '老师',\n      coverImgUrl: '',\n      uploadcoverImgUrl: '',\n      markupStr: '',\n      courseId: 0,\n      modelSrc: '',\n      isShow: false,\n      urlUs: ''\n    };\n  },\n\n  watch: {},\n  methods: {\n    null: function _null() {\n      $('#summernote').summernote('destroy');\n    },\n    isModelShow: function isModelShow() {\n      this.isShow = arguments.length <= 0 ? undefined : arguments[0];\n      if (!(arguments.length <= 0 ? undefined : arguments[0])) {\n        $('#model-close').click();\n        this.updateCourseInfo();\n      }\n      console.log(arguments.length <= 0 ? undefined : arguments[0]);\n    },\n    transfer: function transfer() {\n      this.coverImgUrl = arguments.length <= 0 ? undefined : arguments[0];\n    },\n    updateCourseInfo: function updateCourseInfo() {\n      var _this = this;\n\n      axios({\n        method: 'post',\n        url: '/api/updateCourseInfo',\n        data: {\n          courseId: this.courseId,\n          description: this.markupStr,\n          coverImgUrl: this.coverImgUrl\n        }\n      }).then(function (response) {\n        coverBus.$emit('coverImgUrlChange', _this.coverImgUrl);\n      }).catch(function (error) {\n        alert(error);\n      });\n    },\n    getCourseInfo: function getCourseInfo() {\n      var _this2 = this;\n\n      axios({\n        method: 'post',\n        url: '/api/getInitCourseInfo',\n        data: {\n          courseId: this.courseId\n        }\n      }).then(function (response) {\n        _this2.course = response.data.result.name;\n        _this2.teacher = response.data.result.teacher.nickname;\n        _this2.coverImgUrl = response.data.result.coverImgUrl;\n        _this2.markupStr = response.data.result.description;\n        $('#summernote').summernote('code', _this2.markupStr);\n        console.log(response.data.result.description);\n        console.log(response.data.result);\n        _this2.null();\n      }).catch(function (error) {\n        bus.$emit(\"dialog\", {\n          type: \"error\", //success default error warn\n          body: \" 课程信息获取失败！\",\n          auto: false, //是否自动隐藏\n          time: 5000 //毫秒\n        });\n      });\n    },\n    save: function save() {\n      this.markupStr = $('#summernote').summernote('code');\n      $('#summernote').summernote('destroy');\n      this.updateCourseInfo();\n      console.log(this.markupStr);\n      coverBus.$emit('coverImageUrlChange', this.coverImgUrl);\n      bus.$emit(\"dialog\", {\n        type: \"success\", //success default error warn\n        body: \" 课程信息已保存！\",\n        auto: true, //是否自动隐藏\n        time: 5000 //毫秒\n      });\n    },\n    edit: function edit() {\n      $('#summernote').summernote({ focus: true });\n    },\n    upload: function upload() {\n      var _this3 = this;\n\n      var formData = new FormData();\n      formData.append('file', $('#file')[0].files[0]);\n      var config = {\n        headers: { 'Content-Type': 'multipart/form-data' }\n      };\n      axios.post(\"/api/courseInfo/upload\", formData, config).then(function (response) {\n        _this3.coverImgUrl = response.data.result;\n        console.log(_this3.coverImgUrl);\n      }).catch(function (error) {\n        alert(error);\n      });\n\n      alert(\"操作成功！\");\n    },\n    C: function C() {\n      var r = new FileReader();\n      var f = document.getElementById('file').files[0];\n      r.readAsDataURL(f);\n      r.onload = function (e) {\n        document.getElementById('show').src = this.result;\n      };\n    }\n  },\n  beforeCreate: function beforeCreate() {},\n  created: function created() {\n\n    var a = window.sessionStorage.getItem(\"courseId\");\n    console.log(a);\n    if (a != undefined) {\n      this.courseId = 0;\n      this.courseId = a;\n    } else {\n      this.$router.push({ name: 'Index' });\n    }\n  },\n  beforeMount: function beforeMount() {},\n  mounted: function mounted() {\n\n    this.getCourseInfo();\n\n    $(document).ready(function () {\n\n      $('#summernote').summernote({\n        height: 250,\n        tabsize: 2,\n        lang: 'zh-CN',\n        htmlMode: true,\n        disableDragAndDrop: false,\n        focus: true,\n        toolbar: [\n        // [groupName, [list of button]]\n        ['style', ['bold', 'italic', 'underline', 'clear']], ['font', ['strikethrough', 'superscript', 'subscript']], ['fontsize', ['fontsize']], ['color', ['color']], ['para', ['ul', 'ol', 'paragraph']], ['height', ['height']], ['insert', ['picture']]],\n        callbacks: {\n          onImageUpload: function onImageUpload(files) {\n            console.log(\"1111\");\n            sendFile(files[0]);\n          }\n        }\n      });\n    });\n\n    function sendFile(file) {\n      console.log(\"222\");\n      var data = new FormData();\n      data.append(\"file\", file);\n      var config = {\n        headers: { 'Content-Type': 'multipart/form-data' }\n      };\n      axios.post(\"/api/courseInfo/upload\", data, config).then(function (response) {\n        $(\"#summernote\").summernote('insertImage', response.data.result, 'image name'); // the insertImage API\n      }).catch(function (error) {\n        alert(error);\n      });\n    }\n  },\n  beforeUpdate: function beforeUpdate() {},\n  updated: function updated() {},\n  beforeDestroy: function beforeDestroy() {},\n  destroyed: function destroyed() {}\n});\n\n/***/ }),\n\n/***/ \"MbIj\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"vue/fonts/summernote.372a283.eot\";\n\n/***/ }),\n\n/***/ \"OYI4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"vue/fonts/summernote.372a283.eot\";\n\n/***/ }),\n\n/***/ \"Qnm5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"BkJT\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".content[data-v-3bb4743c]{margin:auto;max-width:80%;margin-bottom:100px}.des[data-v-3bb4743c]{line-height:30px}code.language-html[data-v-3bb4743c]{padding:10px 20px;margin:10px 0;display:block;background-color:#333;color:#fff;overflow-x:auto;font-family:Consolas,Monaco,Droid,Sans,Mono,Source,Code,Pro,Menlo,Lucida,Type,Writer,Ubuntu;border-radius:5px;white-space:pre}.show-info[data-v-3bb4743c]{margin-bottom:50px}.show-info h2[data-v-3bb4743c]{line-height:50px}.title[data-v-3bb4743c]{display:block;text-decoration:none;text-align:center;line-height:1.5;margin:20px 0;background-image:-webkit-linear-gradient(left,#3498db,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db);color:transparent;-webkit-background-clip:text;background-size:200% 100%;-webkit-animation:slide-data-v-3bb4743c 5s infinite linear;animation:slide-data-v-3bb4743c 5s infinite linear;font-size:40px}.test[data-v-3bb4743c]{height:500px}.model[data-v-3bb4743c]{position:fixed;z-index:10;width:100%;height:100%;overflow:auto;top:0;left:0;background:rgba(0,0,0,.8)}.model-show[data-v-3bb4743c]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:100%}.model img[data-v-3bb4743c]{background-position:0 0,10px 10px;background-size:20px 20px;background-image:linear-gradient(45deg,#eee 25%,transparent 0,transparent 75%,#eee 0,#eee),linear-gradient(45deg,#eee 25%,#fff 0,#fff 75%,#eee 0,#eee)}.c-item[data-v-3bb4743c],.model img[data-v-3bb4743c]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.c-item[data-v-3bb4743c]{display:block;padding:10px 0}@-webkit-keyframes slide-data-v-3bb4743c{0%{background-position:0 0}to{background-position:-100% 0}}@keyframes slide-data-v-3bb4743c{0%{background-position:0 0}to{background-position:-100% 0}}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/cropper.vue\"],\"names\":[],\"mappings\":\"AACA,0BACE,YAAa,AACb,cAAe,AACf,mBAAqB,CACtB,AACD,sBACE,gBAAkB,CACnB,AACD,oCACE,kBAAmB,AACnB,cAAiB,AACjB,cAAe,AACf,sBAAuB,AACvB,WAAY,AACZ,gBAAiB,AACjB,4FAAqH,AACrH,kBAAmB,AACnB,eAAiB,CAClB,AACD,4BACE,kBAAoB,CACrB,AACD,+BACE,gBAAkB,CACnB,AAKD,wBACE,cAAe,AACf,qBAAsB,AACtB,kBAAmB,AACnB,gBAAiB,AACjB,cAAiB,AACjB,2KAA4K,AAC5K,kBAAmB,AACnB,6BAA8B,AAC9B,0BAA2B,AAC3B,2DAA4D,AACpD,mDAAoD,AAC5D,cAAgB,CACjB,AACD,uBACG,YAAc,CAChB,AACD,wBACE,eAAgB,AAChB,WAAY,AACZ,WAAY,AACZ,YAAa,AACb,cAAe,AACf,MAAO,AACP,OAAQ,AACR,yBAA+B,CAChC,AACD,6BACE,oBAAqB,AACrB,oBAAqB,AACrB,aAAc,AACZ,wBAAyB,AACrB,qBAAsB,AAClB,uBAAwB,AAChC,yBAA0B,AACtB,sBAAuB,AACnB,mBAAoB,AAC9B,WAAY,AACZ,WAAa,CACd,AACD,4BAKE,kCAAwC,AACxC,0BAA2B,AACzB,sJAAsL,CACzL,AACD,qDARE,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAY3B,AAPD,yBACE,cAAe,AACf,cAAgB,CAKjB,AACD,yCACA,GACM,uBAAyB,CAC9B,AACD,GACM,2BAA6B,CAClC,CACA,AACD,iCACA,GACM,uBAAyB,CAC9B,AACD,GACM,2BAA6B,CAClC,CACA\",\"file\":\"cropper.vue\",\"sourcesContent\":[\"\\n.content[data-v-3bb4743c] {\\n\\t\\tmargin: auto;\\n\\t\\tmax-width: 80%;\\n\\t\\tmargin-bottom: 100px;\\n}\\n.des[data-v-3bb4743c] {\\n\\t\\tline-height: 30px;\\n}\\ncode.language-html[data-v-3bb4743c] {\\n\\t\\tpadding: 10px 20px;\\n\\t\\tmargin: 10px 0px;\\n\\t\\tdisplay: block;\\n\\t\\tbackground-color: #333;\\n\\t\\tcolor: #fff;\\n\\t\\toverflow-x: auto;\\n\\t\\tfont-family: Consolas, Monaco, Droid, Sans, Mono, Source, Code, Pro, Menlo, Lucida, Sans, Type, Writer, Ubuntu, Mono;\\n\\t\\tborder-radius: 5px;\\n\\t\\twhite-space: pre;\\n}\\n.show-info[data-v-3bb4743c] {\\n\\t\\tmargin-bottom: 50px;\\n}\\n.show-info h2[data-v-3bb4743c] {\\n\\t\\tline-height: 50px;\\n}\\n\\n\\t/*.title, .title:hover, .title-focus, .title:visited {\\n\\t\\tcolor: black;\\n\\t}*/\\n.title[data-v-3bb4743c] {\\n\\t\\tdisplay: block;\\n\\t\\ttext-decoration: none;\\n\\t\\ttext-align: center;\\n\\t\\tline-height: 1.5;\\n\\t\\tmargin: 20px 0px;\\n\\t\\tbackground-image: -webkit-linear-gradient(left,#3498db,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db);\\n\\t\\tcolor: transparent;\\n\\t\\t-webkit-background-clip: text;\\n\\t\\tbackground-size: 200% 100%;\\n\\t\\t-webkit-animation: slide-data-v-3bb4743c 5s infinite linear;\\n\\t\\t        animation: slide-data-v-3bb4743c 5s infinite linear;\\n\\t\\tfont-size: 40px;\\n}\\n.test[data-v-3bb4743c] {\\n\\t  height: 500px;\\n}\\n.model[data-v-3bb4743c] {\\n\\t\\tposition: fixed;\\n\\t\\tz-index: 10;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\toverflow: auto;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\tbackground: rgba(0, 0, 0, 0.8);\\n}\\n.model-show[data-v-3bb4743c] {\\n\\t\\tdisplay: -webkit-box;\\n\\t\\tdisplay: -ms-flexbox;\\n\\t\\tdisplay: flex;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n    -webkit-box-align: center;\\n        -ms-flex-align: center;\\n            align-items: center;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n}\\n.model img[data-v-3bb4743c] {\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n\\t\\tbackground-position: 0px 0px, 10px 10px;\\n\\t\\tbackground-size: 20px 20px;\\n    background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100%),linear-gradient(45deg, #eee 25%, white 25%, white 75%, #eee 75%, #eee 100%);\\n}\\n.c-item[data-v-3bb4743c] {\\n\\t\\tdisplay: block;\\n\\t\\tpadding: 10px 0;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n@-webkit-keyframes slide-data-v-3bb4743c {\\n0%  {\\n      background-position: 0 0;\\n}\\n100% {\\n      background-position: -100% 0;\\n}\\n}\\n@keyframes slide-data-v-3bb4743c {\\n0%  {\\n      background-position: 0 0;\\n}\\n100% {\\n      background-position: -100% 0;\\n}\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"RUcL\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"vue/fonts/summernote.ce9ce49.ttf\";\n\n/***/ }),\n\n/***/ \"Upgw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_CourseInfo_vue__ = __webpack_require__(\"Maxp\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_9e4d1e1c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_CourseInfo_vue__ = __webpack_require__(\"Ln7P\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"+N4l\")\n}\nvar normalizeComponent = __webpack_require__(\"/Xao\")\n/* script */\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-9e4d1e1c\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_CourseInfo_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_9e4d1e1c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_CourseInfo_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"Wj0Y\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Super simple wysiwyg editor v0.8.8\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013- Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2017-09-09T11:03Z\n */\n(function (factory) {\n  /* global define */\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"jxdf\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  var isSupportAmd = \"function\" === 'function' && __webpack_require__(\"grDu\");\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    // Webpack\n    if (true) { // jshint ignore:line\n      try {\n        // If CodeMirror can't be resolved, `require.resolve` will throw an\n        // exception and `hasCodeMirror` won't be set to `true`.\n        /*require.resolve*/(\"dRO2\");\n        hasCodeMirror = true;\n      } catch (e) {\n        // do nothing\n      }\n    } else if (typeof require !== 'undefined') {\n      // Browserify\n      if (typeof require.resolve !== 'undefined') {\n        try {\n          // If CodeMirror can't be resolved, `require.resolve` will throw an\n          // exception and `hasCodeMirror` won't be set to `true`.\n          require.resolve('codemirror');\n          hasCodeMirror = true;\n        } catch (e) {\n          // do nothing\n        }\n      // Almond/Require\n      } else if (typeof require.specified !== 'undefined') {\n        hasCodeMirror = require.specified('codemirror');\n      }\n    }\n  }\n\n  var isSupportTouch =\n    (('ontouchstart' in window) ||\n     (navigator.MaxTouchPoints > 0) ||\n     (navigator.msMaxTouchPoints > 0));\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    isSupportTouch: isSupportTouch,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     * @param {Function} func\n     * @param {Number} wait\n     * @param {Boolean} immediate\n     * @return {Function}\n     */\n    var debounce = function (func, wait, immediate) {\n      var timeout;\n      return function () {\n        var context = this, args = arguments;\n        var later = function () {\n          timeout = null;\n          if (!immediate) {\n            func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n          func.apply(context, args);\n        }\n      };\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel,\n      debounce: debounce\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all false values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isData = makePredByNodeName('DATA');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node) &&\n             !isData(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n      \n      if (node) {\n        return node.childNodes.length;\n      }\n      \n      return 0;\n      \n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      if (!ancestor) {\n        return false;\n      }\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    /**\n     * @method isCustomStyleTag\n     *\n     * assert if a node contains a \"note-styletag\" class,\n     * which implies that's a custom-made style tag node\n     *\n     * @param {Node} an HTML DOM node\n     */\n    var isCustomStyleTag = function (node) {\n      return node && !dom.isText(node) && list.contains(node.classList, 'note-styletag');\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isData: isData,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents,\n      isCustomStyleTag: isCustomStyleTag\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n      // trigger custom onDestroy callback\n      this.triggerEvent('destroy', this);\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n      this.triggerEvent('disable', false);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n\n      this.triggerEvent('disable', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    /**\n     *Some buttons need to change their visual style immediately once they get pressed\n     */\n    this.createInvokeHandlerAndUpdateState = function (namespace, value) {\n      return function (event) {\n        self.createInvokeHandler(namespace, value)(event);\n        self.invoke('buttons.updateCurrentStyle');\n      };\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        var $target = $(event.target);\n        self.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n\n      // Update options\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n      options.tooltip = options.tooltip === 'auto' ? !agent.isSupportTouch : options.tooltip;\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      var option = (typeof item === 'object') ? item.option : undefined;\n\n      var dataValue = 'data-value=\"' + value + '\"';\n      var dataOption = (option !== undefined) ? ' data-option=\"' + option + '\"' : '';\n      return '<li><a href=\"#\" ' + (dataValue + dataOption) + '>' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownButtonContents = function (contents, options) {\n    return contents + ' ' + icon(options.icons.caret, 'span');\n  };\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    if (options.tooltip) {\n      $node.find('.note-color-btn').tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var checkbox = renderer.create('<div class=\"checkbox\"></div>', function ($node, options) {\n      $node.html([\n          ' <label' + (options.id ? ' for=\"' + options.id + '\"' : '') + '>',\n          ' <input type=\"checkbox\"' + (options.id ? ' id=\"' + options.id + '\"' : ''),\n          (options.checked ? ' checked' : '') + '/>',\n          (options.text ? options.text : ''),\n          '</label>'\n      ].join(''));\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    dropdown: dropdown,\n    dropdownButtonContents: dropdownButtonContents,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    checkbox: checkbox,\n    icon: icon,\n    options: {},\n\n    button: function ($node, options) {\n      return renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n        if (options && options.tooltip && self.options.tooltip) {\n          $node.attr({\n            title: options.tooltip\n          }).tooltip({\n            container: 'body',\n            trigger: 'hover',\n            placement: 'bottom'\n          });\n        }\n      })($node, options);\n    },\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      self.options = options;\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table',\n        addRowAbove: 'Add row above',\n        addRowBelow: 'Add row below',\n        addColLeft: 'Add column left',\n        addColRight: 'Add column right',\n        delRow: 'Delete row',\n        delCol: 'Delete column',\n        delTable: 'Delete table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        p: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n      'DELETE': 46,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE,\n          keyMap.DELETE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnCell: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n      // isOnData: judge whether range is on data node or not\n      this.isOnData = makeIsOn(dom.isData);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',\n          'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading, pre or custom-made styleTag with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n\n  /**\n   * @class Create a virtual table to create what actions to do in change.\n   * @param {object} startPoint Cell selected to apply change.\n   * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where\n   * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction\n   * @param {object} domTable Dom element of table to make changes.\n   */\n  var TableResultAction = function (startPoint, where, action, domTable) {\n    var _startPoint = { 'colPos': 0, 'rowPos': 0 };\n    var _virtualTable = [];\n    var _actionCellList = [];\n\n    //////////////////////////////////////////////\n    // Private functions\n    //////////////////////////////////////////////\n\n    /**\n     * Set the startPoint of action.\n     */\n    function setStartPoint() {\n      if (!startPoint || !startPoint.tagName || (startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th')) {\n        console.error('Impossible to identify start Cell point.', startPoint);\n        return;\n      }\n      _startPoint.colPos = startPoint.cellIndex;\n      if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {\n        console.error('Impossible to identify start Row point.', startPoint);\n        return;\n      }\n      _startPoint.rowPos = startPoint.parentElement.rowIndex;\n    }\n\n    /**\n     * Define virtual table position info object.\n     * \n     * @param {int} rowIndex Index position in line of virtual table.\n     * @param {int} cellIndex Index position in column of virtual table.\n     * @param {object} baseRow Row affected by this position.\n     * @param {object} baseCell Cell affected by this position.\n     * @param {bool} isSpan Inform if it is an span cell/row.\n     */\n    function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {\n      var objPosition = {\n        'baseRow': baseRow,\n        'baseCell': baseCell,\n        'isRowSpan': isRowSpan,\n        'isColSpan': isColSpan,\n        'isVirtual': isVirtualCell\n      };\n      if (!_virtualTable[rowIndex]) {\n        _virtualTable[rowIndex] = [];\n      }\n      _virtualTable[rowIndex][cellIndex] = objPosition;\n    }\n\n    /**\n     * Create action cell object.\n     * \n     * @param {object} virtualTableCellObj Object of specific position on virtual table.\n     * @param {enum} resultAction Action to be applied in that item.\n     */\n    function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {\n      return {\n        'baseCell': virtualTableCellObj.baseCell,\n        'action': resultAction,\n        'virtualTable': {\n          'rowIndex': virtualRowPosition,\n          'cellIndex': virtualColPosition\n        }\n      };\n    }\n\n    /**\n     * Recover free index of row to append Cell.\n     * \n     * @param {int} rowIndex Index of row to find free space.\n     * @param {int} cellIndex Index of cell to find free space in table.\n     */\n    function recoverCellIndex(rowIndex, cellIndex) {\n      if (!_virtualTable[rowIndex]) {\n        return cellIndex;\n      }\n      if (!_virtualTable[rowIndex][cellIndex]) {\n        return cellIndex;\n      }\n\n      var newCellIndex = cellIndex;\n      while (_virtualTable[rowIndex][newCellIndex]) {\n        newCellIndex++;\n        if (!_virtualTable[rowIndex][newCellIndex]) {\n          return newCellIndex;\n        }\n      }\n    }\n\n    /**\n     * Recover info about row and cell and add information to virtual table.\n     * \n     * @param {object} row Row to recover information.\n     * @param {object} cell Cell to recover information.\n     */\n    function addCellInfoToVirtual(row, cell) {\n      var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);\n      var cellHasColspan = (cell.colSpan > 1);\n      var cellHasRowspan = (cell.rowSpan > 1);\n      var isThisSelectedCell = (row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos);\n      setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);\n\n      // Add span rows to virtual Table.\n      var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;\n      if (rowspanNumber > 1) {\n        for (var rp = 1; rp < rowspanNumber; rp++) {\n          var rowspanIndex = row.rowIndex + rp;\n          adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);\n          setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);\n        }\n      }\n\n      // Add span cols to virtual table.\n      var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;\n      if (colspanNumber > 1) {\n        for (var cp = 1; cp < colspanNumber; cp++) {\n          var cellspanIndex = recoverCellIndex(row.rowIndex, (cellIndex + cp));\n          adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);\n          setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);\n        }\n      }\n    }\n\n    /**\n     * Process validation and adjust of start point if needed\n     * \n     * @param {int} rowIndex \n     * @param {int} cellIndex \n     * @param {object} cell \n     * @param {bool} isSelectedCell \n     */\n    function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {\n      if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {\n        _startPoint.colPos++;\n      }\n    }\n\n    /**\n     * Create virtual table of cells with all cells, including span cells.\n     */\n    function createVirtualTable() {\n      var rows = domTable.rows;\n      for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n        var cells = rows[rowIndex].cells;\n        for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n          addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);\n        }\n      }\n    }\n\n    /**\n     * Get action to be applied on the cell.\n     * \n     * @param {object} cell virtual table cell to apply action\n     */\n    function getDeleteResultActionToCell(cell) {\n      switch (where) {\n        case TableResultAction.where.Column:\n          if (cell.isColSpan) {\n            return TableResultAction.resultAction.SubtractSpanCount;\n          }\n          break;\n        case TableResultAction.where.Row:\n          if (!cell.isVirtual && cell.isRowSpan) {\n            return TableResultAction.resultAction.AddCell;\n          }\n          else if (cell.isRowSpan) {\n            return TableResultAction.resultAction.SubtractSpanCount;\n          }\n          break;\n      }\n      return TableResultAction.resultAction.RemoveCell;\n    }\n\n    /**\n     * Get action to be applied on the cell.\n     * \n     * @param {object} cell virtual table cell to apply action\n     */\n    function getAddResultActionToCell(cell) {\n      switch (where) {\n        case TableResultAction.where.Column:\n          if (cell.isColSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n          } else if (cell.isRowSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n          }\n          break;\n        case TableResultAction.where.Row:\n          if (cell.isRowSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n          } else if (cell.isColSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n          }\n          break;\n      }\n      return TableResultAction.resultAction.AddCell;\n    }\n\n    function init() {\n      setStartPoint();\n      createVirtualTable();\n    }\n\n    //////////////////////////////////////////////\n    // Public functions\n    //////////////////////////////////////////////\n\n    /**\n     * Recover array os what to do in table.\n     */\n    this.getActionList = function () {\n      var fixedRow = (where === TableResultAction.where.Row) ? _startPoint.rowPos : -1;\n      var fixedCol = (where === TableResultAction.where.Column) ? _startPoint.colPos : -1;\n\n      var actualPosition = 0;\n      var canContinue = true;\n      while (canContinue) {\n        var rowPosition = (fixedRow >= 0) ? fixedRow : actualPosition;\n        var colPosition = (fixedCol >= 0) ? fixedCol : actualPosition;\n        var row = _virtualTable[rowPosition];\n        if (!row) {\n          canContinue = false;\n          return _actionCellList;\n        }\n        var cell = row[colPosition];\n        if (!cell) {\n          canContinue = false;\n          return _actionCellList;\n        }\n\n        // Define action to be applied in this cell\n        var resultAction = TableResultAction.resultAction.Ignore;\n        switch (action) {\n          case TableResultAction.requestAction.Add:\n            resultAction = getAddResultActionToCell(cell);\n            break;\n          case TableResultAction.requestAction.Delete:\n            resultAction = getDeleteResultActionToCell(cell);\n            break;\n        }\n        _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));\n        actualPosition++;\n      }\n\n      return _actionCellList;\n    };\n\n    init();\n  };\n  /**\n  * \n  * Where action occours enum.\n  */\n  TableResultAction.where = { 'Row': 0, 'Column': 1 };\n  /**\n  * \n  * Requested action to apply enum.\n  */\n  TableResultAction.requestAction = { 'Add': 0, 'Delete': 1 };\n  /**\n  * \n  * Result action to be executed enum.\n  */\n  TableResultAction.resultAction = { 'Ignore': 0, 'SubtractSpanCount': 1, 'RemoveCell': 2, 'AddCell': 3, 'SumSpanCount': 4 };\n\n  /**\n   * \n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * Add a new row\n     *\n     * @param {WrappedRange} rng\n     * @param {String} position (top/bottom)\n     * @return {Node}\n     */\n    this.addRow = function (rng, position) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n\n      var currentTr = $(cell).closest('tr');\n      var trAttributes = this.recoverAttributes(currentTr);\n      var html = $('<tr' + trAttributes + '></tr>');\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Row,\n        TableResultAction.requestAction.Add, $(currentTr).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var idCell = 0; idCell < actions.length; idCell++) {\n        var currentCell = actions[idCell];\n        var tdAttributes = this.recoverAttributes(currentCell.baseCell);\n        switch (currentCell.action) {\n          case TableResultAction.resultAction.AddCell:\n            html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            break;\n          case TableResultAction.resultAction.SumSpanCount:\n            if (position === 'top') {\n              var baseCellTr = currentCell.baseCell.parent;\n              var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;\n              if (isTopFromRowSpan) {\n                var newTd = $('<div></div>').append($('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();\n                html.append(newTd);\n                break;\n              }\n            }\n            var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);\n            rowspanNumber++;\n            currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);\n            break;\n        }\n      }\n\n      if (position === 'top') {\n        currentTr.before(html);\n      }\n      else {\n        var cellHasRowspan = (cell.rowSpan > 1);\n        if (cellHasRowspan) {\n          var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);\n          $($(currentTr).parent().find('tr')[lastTrIndex]).after($(html));\n          return;\n        }\n        currentTr.after(html);\n      }\n    };\n\n    /**\n     * Add a new col\n     *\n     * @param {WrappedRange} rng\n     * @param {String} position (left/right)\n     * @return {Node}\n     */\n    this.addCol = function (rng, position) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var rowsGroup = $(row).siblings();\n      rowsGroup.push(row);\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Column,\n        TableResultAction.requestAction.Add, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        var currentCell = actions[actionIndex];\n        var tdAttributes = this.recoverAttributes(currentCell.baseCell);\n        switch (currentCell.action) {\n          case TableResultAction.resultAction.AddCell:\n            if (position === 'right') {\n              $(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            } else {\n              $(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            }\n            break;\n          case TableResultAction.resultAction.SumSpanCount:\n            if (position === 'right') {\n              var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);\n              colspanNumber++;\n              currentCell.baseCell.setAttribute('colSpan', colspanNumber);\n            } else {\n              $(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            }\n            break;\n        }\n      }\n    };\n\n    /*\n    * Copy attributes from element.\n    *\n    * @param {object} Element to recover attributes.\n    * @return {string} Copied string elements.\n    */\n    this.recoverAttributes = function (el) {\n      var resultStr = '';\n\n      if (!el) {\n        return resultStr;\n      }\n\n      var attrList = el.attributes || [];\n\n      for (var i = 0; i < attrList.length; i++) {\n        if (attrList[i].name.toLowerCase() === 'id') {\n          continue;\n        }\n\n        if (attrList[i].specified) {\n          resultStr += ' ' + attrList[i].name + '=\\'' + attrList[i].value + '\\'';\n        }\n      }\n\n      return resultStr;\n    };\n\n    /**\n     * Delete current row\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteRow = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var cellPos = row.children('td, th').index($(cell));\n      var rowPos = row[0].rowIndex;\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Row,\n        TableResultAction.requestAction.Delete, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        if (!actions[actionIndex]) {\n          continue;\n        }\n\n        var baseCell = actions[actionIndex].baseCell;\n        var virtualPosition = actions[actionIndex].virtualTable;\n        var hasRowspan = (baseCell.rowSpan && baseCell.rowSpan > 1);\n        var rowspanNumber = (hasRowspan) ? parseInt(baseCell.rowSpan, 10) : 0;\n        switch (actions[actionIndex].action) {\n          case TableResultAction.resultAction.Ignore:\n            continue;\n          case TableResultAction.resultAction.AddCell:\n            var nextRow = row.next('tr')[0];\n            if (!nextRow) { continue; }\n            var cloneRow = row[0].cells[cellPos];\n            if (hasRowspan) {\n              if (rowspanNumber > 2) {\n                rowspanNumber--;\n                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);\n                nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);\n                nextRow.cells[cellPos].innerHTML = '';\n              } else if (rowspanNumber === 2) {\n                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);\n                nextRow.cells[cellPos].removeAttribute('rowSpan');\n                nextRow.cells[cellPos].innerHTML = '';\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.SubtractSpanCount:\n            if (hasRowspan) {\n              if (rowspanNumber > 2) {\n                rowspanNumber--;\n                baseCell.setAttribute('rowSpan', rowspanNumber);\n                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              } else if (rowspanNumber === 2) {\n                baseCell.removeAttribute('rowSpan');\n                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.RemoveCell:\n            // Do not need remove cell because row will be deleted.\n            continue;\n        }\n      }\n      row.remove();\n    };\n\n    /**\n     * Delete current col\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteCol = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var cellPos = row.children('td, th').index($(cell));\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Column,\n        TableResultAction.requestAction.Delete, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        if (!actions[actionIndex]) {\n          continue;\n        }\n        switch (actions[actionIndex].action) {\n          case TableResultAction.resultAction.Ignore:\n            continue;\n          case TableResultAction.resultAction.SubtractSpanCount:\n            var baseCell = actions[actionIndex].baseCell;\n            var hasColspan = (baseCell.colSpan && baseCell.colSpan > 1);\n            if (hasColspan) {\n              var colspanNumber = (baseCell.colSpan) ? parseInt(baseCell.colSpan, 10) : 0;\n              if (colspanNumber > 2) {\n                colspanNumber--;\n                baseCell.setAttribute('colSpan', colspanNumber);\n                if (baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              } else if (colspanNumber === 2) {\n                baseCell.removeAttribute('colSpan');\n                if (baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.RemoveCell:\n            dom.remove(actions[actionIndex].baseCell, true);\n            continue;\n        }\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n\n    /**\n     * Delete current table\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteTable = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      $(cell).closest('table').remove();\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (!event.isDefaultPrevented()) {\n          if (options.shortcuts) {\n            self.handleKeyMap(event);\n          } else {\n            self.preventDefaultEditableShortCuts(event);\n          }\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, func.debounce(function () {\n        context.triggerEvent('change', $editable.html());\n      }, 100));\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode) {\n        if (options.width) {\n          $editor.outerWidth(options.width);\n        }\n        if (options.height) {\n          $editable.outerHeight(options.height);\n        }\n        if (options.maxHeight) {\n          $editable.css('max-height', options.maxHeight);\n        }\n        if (options.minHeight) {\n          $editable.css('min-height', options.minHeight);\n        }\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    this.preventDefaultEditableShortCuts = function (event) {\n      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n      if ((event.ctrlKey || event.metaKey) &&\n        list.contains([66, 73, 85], event.keyCode)) {\n        event.preventDefault();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName, $target) {\n      var onApplyCustomStyle = context.options.callbacks.onApplyCustomStyle;\n      if (onApplyCustomStyle) {\n        onApplyCustomStyle.call(this, $target, context, this.onFormatBlock);\n      } else {\n        this.onFormatBlock(tagName);\n      }\n    });\n\n    this.onFormatBlock = function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    };\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      // handle spaced urls from input\n      if (typeof linkUrl === 'string') {\n        linkUrl = linkUrl.trim();\n      }\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      } else {\n        // if url doesn't match an URL schema, set http:// as default\n        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n          linkUrl : 'http://' + linkUrl;\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n      var linkInfo = {\n        range: rng,\n        text: rng.toString(),\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n\n      // Define isNewWindow when anchor exists.\n      if ($anchor.length) {\n        linkInfo.isNewWindow = $anchor.attr('target') === '_blank';\n      }\n\n      return linkInfo;\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * Set foreground color\n     *\n     * @param {String} colorCode foreground color code\n     */\n    this.foreColor = this.wrapCommand(function (colorInfo) {\n      document.execCommand('styleWithCSS', false, true);\n      document.execCommand('foreColor', false, colorInfo);\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n     /**\n     * @method addRow\n     *\n     *\n     */\n    this.addRow = function (position) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.addRow(rng, position);\n        afterCommand();\n      }\n    };\n\n     /**\n     * @method addCol\n     *\n     *\n     */\n    this.addCol = function (position) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.addCol(rng, position);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteRow\n     *\n     *\n     */\n    this.deleteRow = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteRow(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteCol\n     *\n     *\n     */\n    this.deleteCol = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteCol(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteTable\n     *\n     *\n     */\n    this.deleteTable = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteTable(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.toggleClass('note-float-left', value === 'left');\n      $target.toggleClass('note-float-right', value === 'right');\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      var src = node && node.src;\n      if (dom.isImg(node) && src.indexOf('data:') === 0) {\n        var decodedData = atob(node.src.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n    var documentEventHandlers = {};\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    var detachDocumentEvent = function () {\n      Object.keys(documentEventHandlers).forEach(function (key) {\n        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n      });\n      documentEventHandlers = {};\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        documentEventHandlers.onDrop = function (e) {\n          e.preventDefault();\n        };\n        $document.on('drop', documentEventHandlers.onDrop);\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      documentEventHandlers.onDragenter = function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      };\n\n      documentEventHandlers.onDragleave = function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      };\n\n      documentEventHandlers.onDrop = function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      };\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', documentEventHandlers.onDragenter)\n        .on('dragleave', documentEventHandlers.onDragleave)\n        .on('drop', documentEventHandlers.onDrop);\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n\n    this.destroy = function () {\n      detachDocumentEvent();\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      new Promise(function(resolve) { resolve(); }).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(\"dRO2\")]; ((function (cm) {\n        CodeMirror = cm;\n      }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}).catch(__webpack_require__.oe);\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        this.destroy();\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n        var onMouseMove = function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        };\n\n        $document\n          .on('mousemove', onMouseMove)\n          .one('mouseup', function () {\n            $document.off('mousemove', onMouseMove);\n          });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n      $statusbar.remove();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var self = this;\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    this.resizeTo = function (size) {\n      $editable.css('height', size.h);\n      $codable.css('height', size.h);\n      if ($codable.data('cmeditor')) {\n        $codable.data('cmeditor').setsize(null, size.h);\n      }\n    };\n\n    this.onResize = function () {\n      self.resizeTo({\n        h: $window.height() - $toolbar.outerHeight()\n      });\n    };\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n        $window.on('resize', this.onResize).trigger('resize');\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize', this.onResize);\n        this.resizeTo({ h: $editable.data('orgHeight') });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      },\n      'summernote.disable': function () {\n        self.hide();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          var onMouseMove = function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          };\n\n          $document\n            .on('mousemove', onMouseMove)\n            .one('mouseup', function (e) {\n              e.preventDefault();\n              $document.off('mousemove', onMouseMove);\n              context.invoke('editor.afterCommand');\n            });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n\n      // Listen for scrolling on the handle overlay.\n      this.$handle.on('wheel', function (e) {\n        e.preventDefault();\n        self.update();\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      if (context.isDisabled()) {\n        return false;\n      }\n\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var position = $image.position();\n        var pos = {\n          left: position.left + parseInt($image.css('marginLeft'), 10),\n          top: position.top + parseInt($image.css('marginTop'), 10)\n        };\n\n        // exclude margin\n        var imageSize = {\n          w: $image.outerWidth(false),\n          h: $image.outerHeight(false)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n\n      this.update();\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (!options.shortcuts || !shortcut) {\n        return '';\n      }\n\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.addTablePopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.magic), options),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandlerAndUpdateState('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandlerAndUpdateState('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandlerAndUpdateState('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandlerAndUpdateState('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandlerAndUpdateState('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandlerAndUpdateState('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents('<span class=\"note-current-fontname\"/>', options),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandlerAndUpdateState('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents('<span class=\"note-current-fontsize\"/>', options),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandlerAndUpdateState('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.dropdownButtonContents('', options),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<div class=\"note-palette\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-light\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"note-palette\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-light\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event'),\n                    tooltip: options.tooltip\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.alignLeft), options),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.textHeight), options),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.table), options),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    /**\n     * table : [\n     *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],\n     *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]\n     * ],\n     */\n    this.addTablePopoverButtons = function () {\n      context.memo('button.addRowUp', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowAbove),\n          tooltip: lang.table.addRowAbove,\n          click: context.createInvokeHandler('editor.addRow', 'top')\n        }).render();\n      });\n      context.memo('button.addRowDown', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowBelow),\n          tooltip: lang.table.addRowBelow,\n          click: context.createInvokeHandler('editor.addRow', 'bottom')\n        }).render();\n      });\n      context.memo('button.addColLeft', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colBefore),\n          tooltip: lang.table.addColLeft,\n          click: context.createInvokeHandler('editor.addCol', 'left')\n        }).render();\n      });\n      context.memo('button.addColRight', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colAfter),\n          tooltip: lang.table.addColRight,\n          click: context.createInvokeHandler('editor.addCol', 'right')\n        }).render();\n      });\n      context.memo('button.deleteRow', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowRemove),\n          tooltip: lang.table.delRow,\n          click: context.createInvokeHandler('editor.deleteRow')\n        }).render();\n      });\n      context.memo('button.deleteCol', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colRemove),\n          tooltip: lang.table.delCol,\n          click: context.createInvokeHandler('editor.deleteCol')\n        }).render();\n      });\n      context.memo('button.deleteTable', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.table.delTable,\n          click: context.createInvokeHandler('editor.deleteTable')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    /**\n     * @param {jQuery} [$container]\n     */\n    this.updateCurrentStyle = function ($container) {\n      var $cont = $container || $toolbar;\n      \n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates($cont, {\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $cont.find('.dropdown-fontname a').each(function () {\n          var $item = $(this);\n          // always compare string to avoid creating another func.\n          var isChecked = ($item.data('value') + '') === (fontName + '');\n          $item.toggleClass('checked', isChecked);\n        });\n        $cont.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $cont.find('.dropdown-fontsize a').each(function () {\n          var $item = $(this);\n          // always compare with string to avoid creating another func.\n          var isChecked = ($item.data('value') + '') === (fontSize + '');\n          $item.toggleClass('checked', isChecked);\n        });\n        $cont.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $cont.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function ($container, infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($container.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      this.changeContainer(false);\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.changeContainer = function (isFullscreen) {\n      if (isFullscreen) {\n        $toolbar.prependTo($editor);\n      } else {\n        if (options.toolbarContainer) {\n          $toolbar.appendTo(options.toolbarContainer);\n        }\n      }\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n\n      this.changeContainer(isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group note-form-group\">' +\n                   '<label class=\"note-form-label\">' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control '+\n                   ' note-form-control  note-input\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group note-form-group\">' +\n                   '<label class=\"note-form-label\">' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control note-form-control ' +\n                   'note-input\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n      (!options.disableLinkTarget ?\n          $('<div/>').append(ui.checkbox({ id: 'sn-checkbox-open-in-new-window', text: lang.link.openInNewWindow, checked: true }).render())\n              .html()\n          : '');\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' +\n      'note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * toggle update button\n     */\n    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text;\n          }\n\n          $linkText.val(linkInfo.text);\n\n          var handleLinkTextUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          };\n\n          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n            setTimeout(handleLinkTextUpdate, 0);\n          });\n\n          var handleLinkUrlUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          };\n\n          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n            setTimeout(handleLinkUrlUpdate, 0);\n          }).val(linkInfo.url).trigger('focus');\n\n          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          var isChecked = linkInfo.isNewWindow !== undefined ?\n            linkInfo.isNewWindow : context.options.linkTargetBlank;\n\n          $openInNewWindow.prop('checked', isChecked);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            ui.hideDialog(self.$dialog);\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input paste keypress');\n          $linkUrl.off('input paste keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.disable summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content,.note-popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-form-group note-group-select-from-files\">' +\n                   '<label class=\"note-form-label\">' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control note-form-control note-input\" '+\n                   ' type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' + \n                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n                   '<label class=\"note-form-label\">' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control note-form-control note-input ' +\n                   ' col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' +\n      'note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n\n  /**\n   * Image popover module\n   *  mouse events that show/hide popover will be handled by Handle.js.\n   *  Handle.js will receive the events and invoke 'imagePopover.update'.\n   */\n  var ImagePopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editable = context.layoutInfo.editable;\n    var editable = $editable[0];\n    var options = context.options;\n\n    this.events = {\n      'summernote.disable': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        var posEditor = dom.posFromPlaceholder(editable);\n\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: Math.min(pos.top, posEditor.top)\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var TablePopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        self.update(e.target);\n      },\n      'summernote.keyup summernote.scroll summernote.change': function () {\n        self.update();\n      },\n      'summernote.disable': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.table);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-table-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.table);\n\n      // [workaround] Disable Firefox's default table editor\n      if (agent.isFF) {\n        document.execCommand('enableInlineTableEditing', false, false);\n      }\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (context.isDisabled()) {\n        return false;\n      }\n\n      var isCell = dom.isCell(target);\n\n      if (isCell) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n\n      return isCell;\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group note-form-group row-fluid\">' +\n          '<label class=\"note-form-label\">' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control  note-form-control note-input span12\" ' + \n          ' type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' + \n      ' note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*(\\d+)[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var qqRegExp = /\\/\\/v\\.qq\\.com.*?vid=(.+)/;\n      var qqMatch = url.match(qqRegExp);\n\n      var qqRegExp2 = /\\/\\/v\\.qq\\.com\\/x?\\/?(page|cover).*?\\/([^\\/]+)\\.html\\??.*/;\n      var qqMatch2 = url.match(qqRegExp2);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if ((qqMatch && qqMatch[1].length) || (qqMatch2 && qqMatch2[2].length)) {\n        var vid = ((qqMatch && qqMatch[1].length) ? qqMatch[1]:qqMatch2[2]);\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '310')\n            .attr('width', '500')\n            .attr('src', 'http://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.8</a> · ',\n        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body,.note-modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.disable summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n          context.invoke('buttons.updateCurrentStyle', this.$popover);\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.disable summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content,.note-popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        // XXX: consider to move codes to editor for recording redo/undo.\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.triggerEvent('change', context.layoutInfo.editable.html(), context.layoutInfo.editable);\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.8',\n    ui: ui,\n    dom: dom,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'tablePopover': TablePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n\n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        table: [\n          ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],\n          ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n      linkTargetBlank: true,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n      tooltip: 'auto',\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'rowBelow': 'note-icon-row-below',\n        'colBefore': 'note-icon-col-before',\n        'colAfter': 'note-icon-col-after',\n        'rowAbove': 'note-icon-row-above',\n        'rowRemove': 'note-icon-row-remove',\n        'colRemove': 'note-icon-col-remove',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-menu-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n/***/ }),\n\n/***/ \"cvcb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"vue/fonts/summernote.608fd10.woff\";\n\n/***/ }),\n\n/***/ \"dRO2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\nfunction findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  var dir = from > to ? -1 : 1;\n  for (;;) {\n    if (from == to) { return from }\n    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n    if (mid == from) { return pred(mid) ? from : to }\n    if (pred(mid)) { to = mid; }\n    else { from = mid + dir; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\", 0) }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (direction == \"ltr\") {\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\nStringStream.prototype.baseToken = function () {\n  var oracle = this.lineOracle;\n  return oracle && oracle.baseToken(this.pos)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n  this.baseTokens = null;\n  this.baseTokenPos = 1;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.baseToken = function (n) {\n    var this$1 = this;\n\n  if (!this.baseTokens) { return null }\n  while (this.baseTokens[this.baseTokenPos] <= n)\n    { this$1.baseTokenPos += 2; }\n  var type = this.baseTokens[this.baseTokenPos + 1];\n  return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n          size: this.baseTokens[this.baseTokenPos] - n}\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    context.baseTokens = st;\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n    context.state = state;\n    context.baseTokens = null;\n    context.baseTokenPos = 1;\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\nfunction widgetTopHeight(lineObj) {\n  var height = 0;\n  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n    { height += widgetHeight(lineObj.widgets[i]); } } }\n  return height\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets) {\n    var height = widgetTopHeight(lineObj);\n    rect.top += height; rect.bottom += height;\n  }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = part.level == 1;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  y -= widgetTopHeight(lineObj);\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\n// Returns true if the given side of a box is after the given\n// coordinates, in top-to-bottom, left-to-right order.\nfunction boxIsAfter(box, x, y, left) {\n  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  // Move y into line-local coordinate space\n  y -= heightAtLine(lineObj);\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  // When directly calling `measureCharPrepared`, we have to adjust\n  // for the widgets at this line.\n  var widgetHeight$$1 = widgetTopHeight(lineObj);\n  var begin = 0, end = lineObj.text.length, ltr = true;\n\n  var order = getOrder(lineObj, cm.doc.direction);\n  // If the line isn't plain left-to-right text, first figure out\n  // which bidi section the coordinates fall into.\n  if (order) {\n    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n    ltr = part.level != 1;\n    // The awkward -1 offsets are needed because findFirst (called\n    // on these below) will treat its first bound as inclusive,\n    // second as exclusive, but we want to actually address the\n    // characters in the part's range\n    begin = ltr ? part.from : part.to - 1;\n    end = ltr ? part.to : part.from - 1;\n  }\n\n  // A binary search to find the first character whose bounding box\n  // starts after the coordinates. If we run across any whose box wrap\n  // the coordinates, store that.\n  var chAround = null, boxAround = null;\n  var ch = findFirst(function (ch) {\n    var box = measureCharPrepared(cm, preparedMeasure, ch);\n    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n    if (!boxIsAfter(box, x, y, false)) { return false }\n    if (box.top <= y && box.left <= x) {\n      chAround = ch;\n      boxAround = box;\n    }\n    return true\n  }, begin, end);\n\n  var baseX, sticky, outside = false;\n  // If a box around the coordinates was found, use that\n  if (boxAround) {\n    // Distinguish coordinates nearer to the left or right side of the box\n    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n    ch = chAround + (atStart ? 0 : 1);\n    sticky = atStart ? \"after\" : \"before\";\n    baseX = atLeft ? boxAround.left : boxAround.right;\n  } else {\n    // (Adjust for extended bound, if necessary.)\n    if (!ltr && (ch == end || ch == begin)) { ch++; }\n    // To determine which side to associate with, get the box to the\n    // left of the character and compare it's vertical position to the\n    // coordinates\n    sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n      \"after\" : \"before\";\n    // Now get accurate coordinates for this place, in order to get a\n    // base X position\n    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n    baseX = coords.left;\n    outside = y < coords.top || y >= coords.bottom;\n  }\n\n  ch = skipExtendingChars(lineObj.text, ch, 1);\n  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n}\n\nfunction coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n  // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n  // situation, we can take this ordering to correspond to the visual\n  // ordering. This finds the first part whose end is after the given\n  // coordinates.\n  var index = findFirst(function (i) {\n    var part = order[i], ltr = part.level != 1;\n    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                   \"line\", lineObj, preparedMeasure), x, y, true)\n  }, 0, order.length - 1);\n  var part = order[index];\n  // If this isn't the first part, the part's start is also after\n  // the coordinates, and the coordinates aren't on the same line as\n  // that start, move one part back.\n  if (index > 0) {\n    var ltr = part.level != 1;\n    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                             \"line\", lineObj, preparedMeasure);\n    if (boxIsAfter(start, x, y, true) && start.top > y)\n      { part = order[index - 1]; }\n  }\n  return part\n}\n\nfunction coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n  // In a wrapped line, rtl text on wrapping boundaries can do things\n  // that don't correspond to the ordering in our `order` array at\n  // all, so a binary search doesn't work, and we want to return a\n  // part that only spans one line so that the binary search in\n  // coordsCharInner is safe. As such, we first find the extent of the\n  // wrapped line, and then do a flat search in which we discard any\n  // spans that aren't on the line.\n  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n  var begin = ref.begin;\n  var end = ref.end;\n  if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n  var part = null, closestDist = null;\n  for (var i = 0; i < order.length; i++) {\n    var p = order[i];\n    if (p.from >= end || p.to <= begin) { continue }\n    var ltr = p.level != 1;\n    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n    // Weigh against spans ending before this, so that they are only\n    // picked if nothing ends after\n    var dist = endX < x ? x - endX + 1e9 : endX - x;\n    if (!part || closestDist > dist) {\n      part = p;\n      closestDist = dist;\n    }\n  }\n  if (!part) { part = order[order.length - 1]; }\n  // Clip the part to the wrapped line.\n  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n  return part\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  if ( primary === void 0 ) primary = true;\n\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (!primary && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\nfunction cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n  var docLTR = doc.direction == \"ltr\";\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    function wrapX(pos, dir, side) {\n      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n      var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n      var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n      return coords(ch, prop)[prop]\n    }\n\n    var order = getOrder(lineObj, doc.direction);\n    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n      var ltr = dir == \"ltr\";\n      var fromPos = coords(from, ltr ? \"left\" : \"right\");\n      var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n      var first = i == 0, last = !order || i == order.length - 1;\n      if (toPos.top - fromPos.top <= 3) { // Single line\n        var openLeft = (docLTR ? openStart : openEnd) && first;\n        var openRight = (docLTR ? openEnd : openStart) && last;\n        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n        add(left, fromPos.top, right - left, fromPos.bottom);\n      } else { // Multiple lines\n        var topLeft, topRight, botLeft, botRight;\n        if (ltr) {\n          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n          topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n          botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n          botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n        } else {\n          topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n          botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n        }\n        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n      }\n\n      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n      if (cmpCoords(toPos, start) < 0) { start = toPos; }\n      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n      if (cmpCoords(toPos, end) < 0) { end = toPos; }\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n    var w = line.widgets[i], parent = w.node.parentNode;\n    if (parent) { w.height = parent.offsetHeight; }\n  } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt();\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var assign;\n    (assign = [to, from], from = assign[0], to = assign[1], assign); }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0 || cm.doc.direction == \"rtl\") {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\n\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    if (/\\'$/.test(name))\n      { cm.state.keySeq = null; }\n    else\n      { stopSeq.set(50, function () {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      }); }\n    if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n  }\n  return dispatchKeyInner(cm, name, e, handle)\n}\n\nfunction dispatchKeyInner(cm, name, e, handle) {\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n// Used when mouse-selecting to adjust the anchor to the proper side\n// of a bidi jump depending on the visual position of the head.\nfunction bidiSimplify(cm, range$$1) {\n  var anchor = range$$1.anchor;\n  var head = range$$1.head;\n  var anchorLine = getLine(cm.doc, anchor.line);\n  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n  var order = getOrder(anchorLine);\n  if (!order) { return range$$1 }\n  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n  if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n  // Compute the relative visual position of the head compared to the\n  // anchor (<0 is to the left, >0 to the right)\n  var leftSide;\n  if (head.line != anchor.line) {\n    leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n  } else {\n    var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n    if (headIndex == boundary - 1 || headIndex == boundary)\n      { leftSide = dir < 0; }\n    else\n      { leftSide = dir > 0; }\n  }\n\n  var usePart = order[boundary + (leftSide ? -1 : 0)];\n  var from = leftSide == (usePart.level == 1);\n  var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  if (e.touches) {\n    mX = e.touches[0].clientX;\n    mY = e.touches[0].clientY;\n  } else {\n    try { mX = e.clientX; mY = e.clientY; }\n    catch(e) { return false }\n  }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find(0)))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.32.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n/***/ }),\n\n/***/ \"k5vd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"BkJT\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \"img[data-v-9e4d1e1c]{height:150px;width:180px;margin:1% 1% 0}.m[data-v-9e4d1e1c]{width:800px;margin-left:auto;margin-right:auto}.input-file[data-v-9e4d1e1c]{display:inline-block;position:relative;overflow:hidden;text-align:center;width:auto;background-color:#2c7;border:1px solid #ddd;border-radius:4px;padding:5px 10px;font-size:12px;font-weight:400;line-height:18px;color:#fff;text-decoration:none}.input-file input[type=file][data-v-9e4d1e1c]{position:absolute;top:0;right:0;font-size:14px;background-color:#fff;-webkit-transform:translate(-300px) scale(4);transform:translate(-300px) scale(4);height:40px;opacity:0;filter:alpha(opacity=0)}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/CourseInfo.vue\"],\"names\":[],\"mappings\":\"AACA,qBACE,aAAc,AACd,YAAa,AACb,cAAoB,CACrB,AACD,oBAAqB,YAAa,AAAC,iBAAkB,AAAC,iBAAmB,CACxE,AACD,6BACE,qBAAsB,AACtB,kBAAmB,AACnB,gBAAiB,AACjB,kBAAmB,AACnB,WAAY,AACZ,sBAAuB,AACvB,sBAAuB,AACvB,kBAAmB,AACnB,iBAAkB,AAClB,eAAgB,AAChB,gBAAoB,AACpB,iBAAkB,AAClB,WAAW,AACX,oBAAsB,CACvB,AACD,8CACE,kBAAmB,AACnB,MAAO,AACP,QAAS,AACT,eAAgB,AAChB,sBAAuB,AACvB,6CAAmD,AAC3C,qCAA2C,AACnD,YAAa,AACb,UAAW,AACX,uBAAyB,CAC1B\",\"file\":\"CourseInfo.vue\",\"sourcesContent\":[\"\\nimg[data-v-9e4d1e1c]{\\n  height: 150px;\\n  width: 180px;\\n  margin: 1% 1% 0% 1%;\\n}\\n.m[data-v-9e4d1e1c]{ width: 800px; margin-left: auto; margin-right: auto;\\n}\\n.input-file[data-v-9e4d1e1c]{\\n  display: inline-block;\\n  position: relative;\\n  overflow: hidden;\\n  text-align: center;\\n  width: auto;\\n  background-color: #2c7;\\n  border: solid 1px #ddd;\\n  border-radius: 4px;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  font-weight: normal;\\n  line-height: 18px;\\n  color:#fff;\\n  text-decoration: none;\\n}\\n.input-file input[type=\\\"file\\\"][data-v-9e4d1e1c] {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  font-size: 14px;\\n  background-color: #fff;\\n  -webkit-transform: translate(-300px, 0px) scale(4);\\n          transform: translate(-300px, 0px) scale(4);\\n  height: 40px;\\n  opacity: 0;\\n  filter: alpha(opacity=0);\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"kqM6\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(\"hRKE\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_cropper__ = __webpack_require__(\"1JdY\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n\tdata: function data() {\n\t\treturn {\n\t\t\tmodel: false,\n\t\t\tmodelBtn: false,\n\t\t\tmodelSrc: '',\n\t\t\tcrap: false,\n\t\t\timageU: '',\n\t\t\tcoverImgUrl: '',\n\t\t\texample2: {\n\t\t\t\timg: '',\n\t\t\t\tinfo: true,\n\t\t\t\tsize: 1,\n\t\t\t\toutputType: 'jpeg',\n\t\t\t\tcanScale: true,\n\t\t\t\tautoCrop: true,\n\t\t\t\t// 只有自动截图开启 宽度高度才生效\n\t\t\t\twidth: 400,\n\t\t\t\theight: 300,\n\t\t\t\tfixed: true,\n\t\t\t\tfixedNumber: [4, 3]\n\t\t\t},\n\t\t\tdownImg: '#',\n\t\t\tisShow: false\n\t\t};\n\t},\n\tmethods: {\n\t\tsumitImageFile: function sumitImageFile(base64Codes) {\n\t\t\tvar _this = this;\n\n\t\t\tvar form = document.forms[0];\n\n\t\t\tvar formData = new FormData(); //这里连带form里的其他参数也一起提交了,如果不需要提交其他参数可以直接FormData无参数的构造函数\n\n\t\t\t//convertBase64UrlToBlob函数是将base64编码转换为Blob\n\t\t\tformData.append(\"file\", this.convertBase64UrlToBlob(base64Codes)); //append函数的第一个参数是后台获取数据的参数名,和html标签的input的name属性功能相同\n\n\n\t\t\taxios.post(\"/api/courseInfo/upload\", formData).then(function (response) {\n\t\t\t\t_this.coverImgUrl = response.data.result;\n\t\t\t\t_this.$refs.cropper2.clearCrop();\n\t\t\t\t_this.$emit('transfer', _this.coverImgUrl);\n\t\t\t\t_this.$emit(\"isModelShow\", _this.isShow);\n\t\t\t\t_this.$refs.cropper2.clearCrop();\n\t\t\t\tbus.$emit(\"dialog\", {\n\t\t\t\t\ttype: \"success\", //success default error warn\n\t\t\t\t\tbody: \" 课程封面上传成功！\",\n\t\t\t\t\tauto: true, //是否自动隐藏\n\t\t\t\t\ttime: 5000 //毫秒\n\t\t\t\t});\n\t\t\t}).catch(function (error) {\n\t\t\t\tbus.$emit(\"dialog\", {\n\t\t\t\t\ttype: \"error\", //success default error warn\n\t\t\t\t\tbody: \" 课程封面上传失败！\",\n\t\t\t\t\tauto: false, //是否自动隐藏\n\t\t\t\t\ttime: 5000 //毫秒\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tconvertBase64UrlToBlob: function convertBase64UrlToBlob(urlData) {\n\n\t\t\tvar bytes = atob(urlData.split(',')[1]); //去掉url的头，并转换为byte\n\n\t\t\t//处理异常,将ascii码小于0的转换为大于0\n\t\t\tvar ab = new ArrayBuffer(bytes.length);\n\t\t\tvar ia = new Uint8Array(ab);\n\t\t\tfor (var i = 0; i < bytes.length; i++) {\n\t\t\t\tia[i] = bytes.charCodeAt(i);\n\t\t\t}\n\n\t\t\treturn new Blob([ab], { type: 'image/png' });\n\t\t},\n\t\tfinish2: function finish2(type) {\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.$refs.cropper2.getCropData(function (data) {\n\t\t\t\t_this2.model = true;\n\t\t\t\t_this2.modelBtn = false;\n\t\t\t\t_this2.modelSrc = data;\n\t\t\t});\n\t\t},\n\t\tupload: function upload(type) {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.$refs.cropper2.getCropData(function (data) {\n\t\t\t\t_this3.model = true;\n\t\t\t\t_this3.modelBtn = true;\n\t\t\t\t_this3.modelSrc = data;\n\t\t\t\t// this.imageU = this.modelSrc\t\n\t\t\t});\n\t\t},\n\t\taddDB: function addDB(type) {\n\t\t\tvar _this4 = this;\n\n\t\t\tthis.$refs.cropper2.getCropData(function (data) {\n\t\t\t\t_this4.sumitImageFile(data);\n\t\t\t});\n\t\t},\n\t\tuploadImg: function uploadImg(e, num) {\n\t\t\tvar _this5 = this;\n\n\t\t\tthis.modelSrc = '';\n\t\t\t//上传图片\n\t\t\t// this.option.img\n\t\t\tvar file = e.target.files[0];\n\t\t\tif (!/\\.(gif|jpg|jpeg|png|bmp|GIF|JPG|PNG)$/.test(e.target.value)) {\n\t\t\t\talert('图片类型必须是.gif,jpeg,jpg,png,bmp中的一种');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function (e) {\n\t\t\t\tvar data = void 0;\n\t\t\t\tif (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(e.target.result) === 'object') {\n\t\t\t\t\t// 把Array Buffer转化为blob 如果是base64不需要\n\t\t\t\t\tdata = window.URL.createObjectURL(new Blob([e.target.result]));\n\t\t\t\t} else {\n\t\t\t\t\tdata = e.target.result;\n\t\t\t\t}\n\t\t\t\tif (num === 1) {\n\t\t\t\t\t_this5.option.img = data;\n\t\t\t\t} else if (num === 2) {\n\t\t\t\t\t_this5.example2.img = data;\n\t\t\t\t}\n\t\t\t};\n\t\t\t// 转化为base64\n\t\t\treader.readAsDataURL(file);\n\t\t\t// 转化为blob\n\t\t\t// reader.readAsArrayBuffer(file)\n\t\t\tthis.$refs.cropper2.startCrop();\n\t\t},\n\t\tdown: function down(type) {\n\t\t\tvar _this6 = this;\n\n\t\t\tvar aLink = document.createElement('a');\n\t\t\taLink.download = 'demo';\n\t\t\t// 输出\n\t\t\tif (type === 'blob') {\n\t\t\t\tthis.$refs.cropper2.getCropBlob(function (data) {\n\t\t\t\t\t_this6.downImg = window.URL.createObjectURL(data);\n\t\t\t\t\taLink.href = window.URL.createObjectURL(data);\n\t\t\t\t\taLink.click();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.$refs.cropper2.getCropData(function (data) {\n\n\t\t\t\t\t_this6.downImg = data;\n\t\t\t\t\taLink.href = data;\n\t\t\t\t\taLink.click();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\tcomponents: {\n\t\tvueCropper: __WEBPACK_IMPORTED_MODULE_1__vue_cropper__[\"a\" /* default */]\n\n\t},\n\tmounted: function mounted() {}\n});\n\n/***/ }),\n\n/***/ \"nCkV\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"/AwD\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"8bSs\")(\"7db8ffc5\", content, true);\n\n/***/ }),\n\n/***/ \"o5+c\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_cropper_vue__ = __webpack_require__(\"kqM6\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_3bb4743c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_cropper_vue__ = __webpack_require__(\"tQYy\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"/SmK\")\n}\nvar normalizeComponent = __webpack_require__(\"/Xao\")\n/* script */\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-3bb4743c\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_script_index_0_cropper_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_5_0_vue_loader_lib_template_compiler_index_id_data_v_3bb4743c_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_13_5_0_vue_loader_lib_selector_type_template_index_0_cropper_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"oIVi\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"BkJT\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".vue-cropper[data-v-5daee910]{position:relative;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;direction:ltr;-ms-touch-action:none;touch-action:none;background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC\\\")}.cropper-box-canvas[data-v-5daee910],.cropper-box[data-v-5daee910],.cropper-crop-box[data-v-5daee910],.cropper-drag-box[data-v-5daee910],.cropper-face[data-v-5daee910]{position:absolute;top:0;right:0;bottom:0;left:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.cropper-box-canvas img[data-v-5daee910]{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-transform:none;transform:none}.cropper-box[data-v-5daee910]{overflow:hidden}.cropper-move[data-v-5daee910]{cursor:move}.cropper-crop[data-v-5daee910]{cursor:crosshair}.cropper-modal[data-v-5daee910]{background:rgba(0,0,0,.5)}.cropper-view-box[data-v-5daee910]{display:block;overflow:hidden;width:100%;height:100%;outline:1px solid #39f;outline-color:rgba(51,153,255,.75)}.cropper-view-box[data-v-5daee910],.cropper-view-box img[data-v-5daee910]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.cropper-face[data-v-5daee910]{top:0;left:0;background-color:#fff;opacity:.1}.crop-info[data-v-5daee910]{position:absolute;left:0;min-width:65px;text-align:center;color:#fff;line-height:20px;background-color:rgba(0,0,0,.8);font-size:12px}.crop-line[data-v-5daee910]{position:absolute;display:block;width:100%;height:100%;opacity:.1}.line-w[data-v-5daee910]{top:-3px;left:0;height:5px;cursor:n-resize}.line-a[data-v-5daee910]{top:0;left:-3px;width:5px;cursor:w-resize}.line-s[data-v-5daee910]{bottom:-3px;left:0;height:5px;cursor:s-resize}.line-d[data-v-5daee910]{top:0;right:-3px;width:5px;cursor:e-resize}.crop-point[data-v-5daee910]{position:absolute;width:8px;height:8px;opacity:.75;background-color:#39f;border-radius:100%}.point1[data-v-5daee910]{top:-4px;left:-4px;cursor:nw-resize}.point2[data-v-5daee910]{top:-5px;left:50%;margin-left:-3px;cursor:n-resize}.point3[data-v-5daee910]{top:-4px;right:-4px;cursor:ne-resize}.point4[data-v-5daee910]{top:50%;left:-4px;margin-top:-3px;cursor:w-resize}.point5[data-v-5daee910]{top:50%;right:-4px;margin-top:-3px;cursor:w-resize}.point6[data-v-5daee910]{bottom:-5px;left:-4px;cursor:sw-resize}.point7[data-v-5daee910]{bottom:-5px;left:50%;margin-left:-3px;cursor:s-resize}.point8[data-v-5daee910]{bottom:-5px;right:-4px;cursor:nw-resize}@media screen and (max-width:500px){.crop-point[data-v-5daee910]{position:absolute;width:20px;height:20px;opacity:.45;background-color:#39f;border-radius:100%}.point1[data-v-5daee910]{top:-10px;left:-10px}.point2[data-v-5daee910],.point4[data-v-5daee910],.point5[data-v-5daee910],.point7[data-v-5daee910]{display:none}.point3[data-v-5daee910]{top:-10px;right:-10px}.point4[data-v-5daee910]{top:0;left:0}.point6[data-v-5daee910]{bottom:-10px;left:-10px}.point8[data-v-5daee910]{bottom:-10px;right:-10px}}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/vue-cropper.vue\"],\"names\":[],\"mappings\":\"AACA,8BACE,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,8BAA+B,AACvB,sBAAuB,AAC/B,iBAAkB,AAClB,yBAA0B,AAC1B,sBAAuB,AACvB,qBAAsB,AACtB,cAAe,AACf,sBAAuB,AACnB,kBAAmB,AACtB,8QAAgR,CAClR,AACD,wKACE,kBAAmB,AACnB,MAAO,AACP,QAAS,AACT,SAAU,AACV,OAAQ,AACR,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAC3B,AACD,yCACE,kBAAmB,AACnB,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,iBAAkB,AAC1B,uBAAwB,AAChB,cAAgB,CACzB,AACD,8BACE,eAAiB,CAClB,AACD,+BACE,WAAa,CACd,AACD,+BACI,gBAAkB,CACrB,AACD,gCACE,yBAA+B,CAChC,AAID,mCACE,cAAe,AACf,gBAAiB,AACjB,WAAY,AACZ,YAAa,AACb,uBAAwB,AACtB,kCAAwC,CAK3C,AACD,0EALE,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAO3B,AACD,+BACE,MAAO,AACP,OAAQ,AACR,sBAAuB,AACvB,UAAa,CACd,AACD,4BACE,kBAAmB,AACnB,OAAU,AACV,eAAgB,AAChB,kBAAmB,AACnB,WAAa,AACb,iBAAkB,AAClB,gCAAqC,AACrC,cAAgB,CACjB,AACD,4BACE,kBAAmB,AACnB,cAAe,AACf,WAAY,AACZ,YAAa,AACb,UAAY,CACb,AACD,yBACE,SAAU,AACR,OAAQ,AACR,WAAY,AACZ,eAAiB,CACpB,AACD,yBACE,MAAO,AACL,UAAW,AACX,UAAW,AACX,eAAiB,CACpB,AACD,yBACE,YAAa,AACb,OAAQ,AACR,WAAY,AACZ,eAAiB,CAClB,AACD,yBACE,MAAO,AACL,WAAY,AACZ,UAAW,AACX,eAAiB,CACpB,AACD,6BACE,kBAAmB,AACnB,UAAW,AACT,WAAY,AACZ,YAAa,AACb,sBAAuB,AACzB,kBAAoB,CACrB,AACD,yBACE,SAAU,AACR,UAAW,AACX,gBAAkB,CACrB,AACD,yBACE,SAAU,AACR,SAAU,AACV,iBAAkB,AAClB,eAAiB,CACpB,AACD,yBACE,SAAU,AACR,WAAY,AACZ,gBAAkB,CACrB,AACD,yBACE,QAAS,AACP,UAAW,AACX,gBAAiB,AACjB,eAAiB,CACpB,AACD,yBACE,QAAS,AACP,WAAY,AACZ,gBAAiB,AACjB,eAAiB,CACpB,AACD,yBACE,YAAa,AACb,UAAW,AACX,gBAAkB,CACnB,AACD,yBACE,YAAa,AACb,SAAU,AACV,iBAAkB,AAClB,eAAiB,CAClB,AACD,yBACE,YAAa,AACb,WAAY,AACZ,gBAAkB,CACnB,AACD,oCACA,6BACG,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,YAAa,AACb,sBAAuB,AACvB,kBAAoB,CACtB,AACD,yBACG,UAAW,AACT,UAAY,CAChB,AACD,oGACG,YAAc,CAChB,AACD,yBACG,UAAW,AACX,WAAa,CACf,AACD,yBACG,MAAO,AACP,MAAQ,CACV,AACD,yBACG,aAAc,AACd,UAAY,CACd,AACD,yBACG,aAAc,AACd,WAAa,CACf,CACA\",\"file\":\"vue-cropper.vue\",\"sourcesContent\":[\"\\n.vue-cropper[data-v-5daee910] {\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\t-webkit-box-sizing: border-box;\\n\\t\\t        box-sizing: border-box;\\n\\t\\tuser-select: none;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t-moz-user-select: none;\\n\\t\\t-ms-user-select: none;\\n\\t\\tdirection: ltr;\\n\\t\\t-ms-touch-action: none;\\n\\t\\t    touch-action: none;\\n  \\tbackground-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC');\\n}\\n.cropper-box[data-v-5daee910], .cropper-box-canvas[data-v-5daee910], .cropper-drag-box[data-v-5daee910], .cropper-crop-box[data-v-5daee910], .cropper-face[data-v-5daee910]{\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tright: 0;\\n\\t\\tbottom: 0;\\n\\t\\tleft: 0;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-box-canvas img[data-v-5daee910] {\\n\\t\\tposition: relative;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n\\t\\t-webkit-transform: none;\\n\\t\\t        transform: none;\\n}\\n.cropper-box[data-v-5daee910] {\\n\\t\\toverflow: hidden;\\n}\\n.cropper-move[data-v-5daee910] {\\n\\t\\tcursor: move;\\n}\\n.cropper-crop[data-v-5daee910] {\\n    cursor: crosshair;\\n}\\n.cropper-modal[data-v-5daee910] {\\n\\t\\tbackground: rgba(0, 0, 0, 0.5);\\n}\\n.cropper-crop-box[data-v-5daee910] {\\n\\t\\t/*border: 2px solid #39f;*/\\n}\\n.cropper-view-box[data-v-5daee910] {\\n\\t\\tdisplay: block;\\n\\t\\toverflow: hidden;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\toutline: 1px solid #39f;\\n    outline-color: rgba(51, 153, 255, 0.75);\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-view-box img[data-v-5daee910] {\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-face[data-v-5daee910] {\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\tbackground-color: #fff;\\n\\t\\topacity: 0.1;\\n}\\n.crop-info[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0px;\\n\\t\\tmin-width: 65px;\\n\\t\\ttext-align: center;\\n\\t\\tcolor: white;\\n\\t\\tline-height: 20px;\\n\\t\\tbackground-color: rgba(0, 0, 0, 0.8);\\n\\t\\tfont-size: 12px;\\n}\\n.crop-line[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\tdisplay: block;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\topacity: .1;\\n}\\n.line-w[data-v-5daee910] {\\n\\t\\ttop: -3px;\\n    left: 0;\\n    height: 5px;\\n    cursor: n-resize;\\n}\\n.line-a[data-v-5daee910] {\\n\\t\\ttop: 0;\\n    left: -3px;\\n    width: 5px;\\n    cursor: w-resize;\\n}\\n.line-s[data-v-5daee910] {\\n\\t\\tbottom: -3px;\\n\\t\\tleft: 0;\\n\\t\\theight: 5px;\\n\\t\\tcursor: s-resize;\\n}\\n.line-d[data-v-5daee910] {\\n\\t\\ttop: 0;\\n    right: -3px;\\n    width: 5px;\\n    cursor: e-resize;\\n}\\n.crop-point[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 8px;\\n    height: 8px;\\n    opacity: .75;\\n    background-color: #39f;\\n\\t\\tborder-radius: 100%;\\n}\\n.point1[data-v-5daee910] {\\n\\t\\ttop: -4px;\\n    left: -4px;\\n    cursor: nw-resize;\\n}\\n.point2[data-v-5daee910] {\\n\\t\\ttop: -5px;\\n    left: 50%;\\n    margin-left: -3px;\\n    cursor: n-resize;\\n}\\n.point3[data-v-5daee910] {\\n\\t\\ttop: -4px;\\n    right: -4px;\\n    cursor: ne-resize;\\n}\\n.point4[data-v-5daee910] {\\n\\t\\ttop: 50%;\\n    left: -4px;\\n    margin-top: -3px;\\n    cursor: w-resize;\\n}\\n.point5[data-v-5daee910] {\\n\\t\\ttop: 50%;\\n    right: -4px;\\n    margin-top: -3px;\\n    cursor: w-resize;\\n}\\n.point6[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tleft: -4px;\\n\\t\\tcursor: sw-resize;\\n}\\n.point7[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tleft: 50%;\\n\\t\\tmargin-left: -3px;\\n\\t\\tcursor: s-resize;\\n}\\n.point8[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tright: -4px;\\n\\t\\tcursor: nw-resize;\\n}\\n@media screen and (max-width: 500px) {\\n.crop-point[data-v-5daee910] {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\twidth: 20px;\\n\\t\\t\\theight: 20px;\\n\\t\\t\\topacity: .45;\\n\\t\\t\\tbackground-color: #39f;\\n\\t\\t\\tborder-radius: 100%;\\n}\\n.point1[data-v-5daee910] {\\n\\t\\t\\ttop: -10px;\\n\\t    left: -10px;\\n}\\n.point2[data-v-5daee910], .point4[data-v-5daee910], .point5[data-v-5daee910], .point7[data-v-5daee910] {\\n\\t\\t\\tdisplay: none;\\n}\\n.point3[data-v-5daee910] {\\n\\t\\t\\ttop: -10px;\\n\\t\\t\\tright: -10px;\\n}\\n.point4[data-v-5daee910] {\\n\\t\\t\\ttop: 0;\\n\\t\\t\\tleft: 0;\\n}\\n.point6[data-v-5daee910] {\\n\\t\\t\\tbottom: -10px;\\n\\t\\t\\tleft: -10px;\\n}\\n.point8[data-v-5daee910] {\\n\\t\\t\\tbottom: -10px;\\n\\t\\t\\tright: -10px;\\n}\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"r0eM\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_exif_js__ = __webpack_require__(\"yOBD\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_exif_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__static_exif_js__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n\tdata: function data() {\n\t\treturn {\n\t\t\t// 容器高宽\n\t\t\tw: 0,\n\t\t\th: 0,\n\t\t\t// 图片缩放比例\n\t\t\tscale: 1,\n\t\t\t// 图片偏移x轴\n\t\t\tx: 0,\n\t\t\t// 图片偏移y轴\n\t\t\ty: 0,\n\t\t\t// 图片加载\n\t\t\tloading: true,\n\t\t\t// 图片真实宽度\n\t\t\ttrueWidth: 0,\n\t\t\t// 图片真实高度\n\t\t\ttrueHeight: 0,\n\t\t\t// 是否可以拖动图片\n\t\t\tmove: true,\n\t\t\t// 移动的x\n\t\t\tmoveX: 0,\n\t\t\t// 移动的y\n\t\t\tmoveY: 0,\n\t\t\t// 开启截图\n\t\t\tcrop: false,\n\t\t\t// 正在截图\n\t\t\tcropping: false,\n\t\t\t// 裁剪框大小\n\t\t\tcropW: 0,\n\t\t\tcropH: 0,\n\t\t\tcropOldW: 0,\n\t\t\tcropOldH: 0,\n\t\t\t// 判断是否能够改变\n\t\t\tcanChangeX: false,\n\t\t\tcanChangeY: false,\n\t\t\t// 改变的基准点\n\t\t\tchangeCropTypeX: 1,\n\t\t\tchangeCropTypeY: 1,\n\t\t\t// 裁剪框的坐标轴\n\t\t\tcropX: 0,\n\t\t\tcropY: 0,\n\t\t\tcropChangeX: 0,\n\t\t\tcropChangeY: 0,\n\t\t\tcropOffsertX: 0,\n\t\t\tcropOffsertY: 0,\n\t\t\t// 支持的滚动事件\n\t\t\tsupport: '',\n\t\t\t// 移动端手指缩放\n\t\t\ttouches: [],\n\t\t\ttouchNow: false,\n\t\t\t// 图片旋转\n\t\t\trotate: 0,\n\t\t\tisIos: false,\n\t\t\torientation: 0,\n\t\t\timgs: ''\n\t\t};\n\t},\n\tprops: {\n\t\timg: {\n\t\t\ttype: String,\n\t\t\tdefault: ''\n\t\t},\n\t\t// 输出图片压缩比\n\t\toutputSize: {\n\t\t\ttype: Number,\n\t\t\tdefault: 1\n\t\t},\n\t\toutputType: {\n\t\t\ttype: String,\n\t\t\tdefault: 'jpeg'\n\t\t},\n\t\tinfo: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\t// 是否开启滚轮放大缩小\n\t\tcanScale: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\t// 是否自成截图框\n\t\tautoCrop: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tautoCropWidth: {\n\t\t\ttype: Number,\n\t\t\tdefault: 0\n\t\t},\n\t\tautoCropHeight: {\n\t\t\ttype: Number,\n\t\t\tdefault: 0\n\t\t},\n\t\t// 是否开启固定宽高比\n\t\tfixed: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\t// 宽高比 w/h\n\t\tfixedNumber: {\n\t\t\ttype: Array,\n\t\t\tdefault: function _default() {\n\t\t\t\treturn [1, 1];\n\t\t\t}\n\t\t},\n\t\t// 固定大小 禁止改变截图框大小\n\t\tfixedBox: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\t// 输出截图是否缩放\n\t\tfull: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t}\n\t},\n\tcomputed: {\n\t\tcropInfo: function cropInfo() {\n\t\t\treturn this.cropOffsertY > 20 ? '-20px' : '0px';\n\t\t}\n\t},\n\twatch: {\n\t\t// 如果图片改变， 重新布局\n\t\timg: function img() {\n\t\t\t// 当传入图片时, 读取图片信息同时展示\n\t\t\tthis.checkedImg();\n\t\t},\n\t\timgs: function imgs() {\n\t\t\tthis.reload();\n\t\t},\n\t\tcropW: function cropW() {\n\t\t\tthis.cropW = ~~this.cropW;\n\t\t\tthis.showPreview();\n\t\t},\n\t\tcropH: function cropH() {\n\t\t\tthis.cropH = ~~this.cropH;\n\t\t\tthis.showPreview();\n\t\t},\n\t\tcropOffsertX: function cropOffsertX() {\n\t\t\tthis.showPreview();\n\t\t},\n\t\tcropOffsertY: function cropOffsertY() {\n\t\t\tthis.showPreview();\n\t\t},\n\t\tscale: function scale() {\n\t\t\tthis.showPreview();\n\t\t},\n\t\tx: function x() {\n\t\t\tthis.showPreview();\n\t\t},\n\t\ty: function y() {\n\t\t\tthis.showPreview();\n\t\t},\n\t\trotate: function rotate() {\n\t\t\tthis.showPreview();\n\t\t}\n\t},\n\tmethods: {\n\t\t// 校验图片\n\t\tcheckedImg: function checkedImg() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.loading = true;\n\t\t\tthis.scale = 1;\n\t\t\tthis.clearCrop();\n\t\t\tvar canvas = document.createElement('canvas');\n\t\t\tvar img = new Image();\n\t\t\tvar rotate = 0;\n\t\t\timg.onload = function () {\n\t\t\t\tvar width = img.width;\n\t\t\t\tvar height = img.height;\n\t\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\t\tctx.save();\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__static_exif_js___default.a.getData(img, function () {\n\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__static_exif_js___default.a.getAllTags(img);\n\t\t\t\t\t_this.orientation = __WEBPACK_IMPORTED_MODULE_0__static_exif_js___default.a.getTag(img, 'Orientation');\n\t\t\t\t\tswitch (_this.orientation) {\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\trotate = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\trotate = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\trotate = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\trotate = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (rotate === 0) {\n\t\t\t\t\t\t_this.imgs = _this.img;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (rotate) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase -3:\n\t\t\t\t\t\t\t// 旋转90度 或者-270度 宽度和高度对调\n\t\t\t\t\t\t\tcanvas.width = height;\n\t\t\t\t\t\t\tcanvas.height = width;\n\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\tctx.drawImage(img, 0, -height, width, height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\tctx.drawImage(img, -width, -height, width, height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\tcanvas.width = height;\n\t\t\t\t\t\t\tcanvas.height = width;\n\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\tctx.drawImage(img, -width, 0, width, height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t\tcanvas.toBlob(function (blob) {\n\t\t\t\t\t\tvar data = URL.createObjectURL(blob);\n\t\t\t\t\t\t_this.imgs = data;\n\t\t\t\t\t}, 'image/' + _this.outputType, 1);\n\t\t\t\t});\n\t\t\t};\n\t\t\timg.crossOrigin = '*';\n\t\t\timg.src = this.img;\n\t\t},\n\n\t\t// 当按下鼠标键\n\t\tstartMove: function startMove(e) {\n\t\t\te.preventDefault();\n\t\t\t// 如果move 为true 表示当前可以拖动\n\t\t\tif (this.move && !this.crop) {\n\t\t\t\t// 开始移动\n\t\t\t\tthis.moveX = (e.clientX ? e.clientX : e.touches[0].clientX) - this.x;\n\t\t\t\tthis.moveY = (e.clientY ? e.clientY : e.touches[0].clientY) - this.y;\n\t\t\t\tif (e.touches) {\n\t\t\t\t\twindow.addEventListener('touchmove', this.moveImg);\n\t\t\t\t\twindow.addEventListener('touchend', this.leaveImg);\n\t\t\t\t\tif (e.touches.length == 2) {\n\t\t\t\t\t\t// 记录手指刚刚放上去\n\t\t\t\t\t\tthis.touches = e.touches;\n\t\t\t\t\t\twindow.addEventListener('touchmove', this.touchScale);\n\t\t\t\t\t\twindow.addEventListener('touchend', this.cancleTouchScale);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twindow.addEventListener('mousemove', this.moveImg);\n\t\t\t\t\twindow.addEventListener('mouseup', this.leaveImg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 截图ing\n\t\t\t\tthis.cropping = true;\n\t\t\t\t// 绑定截图事件\n\t\t\t\twindow.addEventListener('mousemove', this.createCrop);\n\t\t\t\twindow.addEventListener('mouseup', this.endCrop);\n\t\t\t\twindow.addEventListener('touchmove', this.createCrop);\n\t\t\t\twindow.addEventListener('touchend', this.endCrop);\n\t\t\t\tthis.cropOffsertX = e.offsetX ? e.offsetX : e.touches[0].pageX - this.$refs.cropper.offsetLeft;\n\t\t\t\tthis.cropOffsertY = e.offsetY ? e.offsetY : e.touches[0].pageY - this.$refs.cropper.offsetTop;\n\t\t\t\tthis.cropX = e.clientX ? e.clientX : e.touches[0].clientX;\n\t\t\t\tthis.cropY = e.clientY ? e.clientY : e.touches[0].clientY;\n\t\t\t\tthis.cropChangeX = this.cropOffsertX;\n\t\t\t\tthis.cropChangeY = this.cropOffsertY;\n\t\t\t\tthis.cropW = 0;\n\t\t\t\tthis.cropH = 0;\n\t\t\t}\n\t\t},\n\n\n\t\t// 移动端缩放\n\t\ttouchScale: function touchScale(e) {\n\t\t\tvar _this2 = this;\n\n\t\t\te.preventDefault();\n\t\t\t// 记录变化量\n\t\t\t// 第一根手指\n\t\t\tvar oldTouch1 = {\n\t\t\t\tx: this.touches[0].clientX,\n\t\t\t\ty: this.touches[0].clientY\n\t\t\t};\n\t\t\tvar newTouch1 = {\n\t\t\t\tx: e.touches[0].clientX,\n\t\t\t\ty: e.touches[0].clientY\n\t\t\t\t// 第二根手指\n\t\t\t};var oldTouch2 = {\n\t\t\t\tx: this.touches[1].clientX,\n\t\t\t\ty: this.touches[1].clientY\n\t\t\t};\n\t\t\tvar newTouch2 = {\n\t\t\t\tx: e.touches[1].clientX,\n\t\t\t\ty: e.touches[1].clientY\n\t\t\t};\n\t\t\tvar oldL = Math.sqrt(Math.pow(oldTouch1.x - oldTouch2.x, 2) + Math.pow(oldTouch1.y - oldTouch2.y, 2));\n\t\t\tvar newL = Math.sqrt(Math.pow(newTouch1.x - newTouch2.x, 2) + Math.pow(newTouch1.y - newTouch2.y, 2));\n\t\t\tvar cha = ~~(newL - oldL);\n\t\t\t// 根据图片本身大小 决定每次改变大小的系数, 图片越大系数越小\n\t\t\t// 1px - 0.2\n\t\t\tvar coe = 1;\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth;\n\t\t\tcoe = coe > 0.1 ? 0.1 : coe;\n\t\t\tvar num = coe * cha;\n\t\t\tif (!this.touchNow) {\n\t\t\t\tthis.touchNow = true;\n\t\t\t\tif (cha > 0) {\n\t\t\t\t\tthis.scale += Math.abs(num);\n\t\t\t\t} else if (cha < 0) {\n\t\t\t\t\tthis.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale;\n\t\t\t\t}\n\t\t\t\tthis.touches = e.touches;\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t_this2.touchNow = false;\n\t\t\t\t}, 8);\n\t\t\t}\n\t\t},\n\t\tcancleTouchScale: function cancleTouchScale(e) {\n\t\t\twindow.removeEventListener('touchmove', this.touchScale);\n\t\t},\n\n\n\t\t// 移动图片\n\t\tmoveImg: function moveImg(e) {\n\t\t\tvar _this3 = this;\n\n\t\t\te.preventDefault();\n\t\t\tif (e.touches && e.touches.length === 2) {\n\t\t\t\tthis.touches = e.touches;\n\t\t\t\twindow.addEventListener('touchmove', this.touchScale);\n\t\t\t\twindow.addEventListener('touchend', this.cancleTouchScale);\n\t\t\t\twindow.removeEventListener('touchmove', this.moveImg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches[0].clientX;\n\t\t\tvar nowY = e.clientY ? e.clientY : e.touches[0].clientY;\n\t\t\tthis.$nextTick(function () {\n\t\t\t\t_this3.x = ~~(nowX - _this3.moveX);\n\t\t\t\t_this3.y = ~~(nowY - _this3.moveY);\n\t\t\t});\n\t\t},\n\n\t\t// 移动图片结束\n\t\tleaveImg: function leaveImg(e) {\n\t\t\twindow.removeEventListener('mousemove', this.moveImg);\n\t\t\twindow.removeEventListener('touchmove', this.moveImg);\n\t\t\twindow.removeEventListener('mouseup', this.leaveImg);\n\t\t\twindow.removeEventListener('touchend', this.leaveImg);\n\t\t},\n\n\t\t// 缩放图片\n\t\tscaleImg: function scaleImg() {\n\t\t\tthis.support = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\";\n\t\t\tif (this.canScale) {\n\t\t\t\twindow.addEventListener(this.support, this.changeSize);\n\t\t\t}\n\t\t},\n\n\t\t// 移出框\n\t\tcancleScale: function cancleScale() {\n\t\t\tif (this.canScale) {\n\t\t\t\twindow.removeEventListener(this.support, this.changeSize);\n\t\t\t}\n\t\t},\n\n\t\t// 改变大小函数\n\t\tchangeSize: function changeSize(e) {\n\t\t\tvar change = e.deltaY || e.wheelDelta;\n\t\t\t// 根据图片本身大小 决定每次改变大小的系数, 图片越大系数越小\n\t\t\tvar isFirefox = navigator.userAgent.indexOf('Firefox');\n\t\t\tchange = isFirefox > 0 ? change * 30 : change;\n\t\t\t// 1px - 0.2\n\t\t\tvar coe = 0.2;\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth;\n\t\t\tvar num = coe * change;\n\t\t\tnum < 0 ? this.scale += Math.abs(num) : this.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale;\n\t\t\te.preventDefault();\n\t\t},\n\n\n\t\t// 修改图片大小函数\n\t\tchangeScale: function changeScale(num) {\n\t\t\tnum = num || 1;\n\t\t\tvar coe = 20;\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth;\n\t\t\tnum = num * coe;\n\t\t\tnum > 0 ? this.scale += Math.abs(num) : this.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale;\n\t\t},\n\n\t\t// 创建截图框\n\t\tcreateCrop: function createCrop(e) {\n\t\t\tvar _this4 = this;\n\n\t\t\te.preventDefault();\n\t\t\t// 移动生成大小\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches ? e.touches[0].clientX : 0;\n\t\t\tvar nowY = e.clientY ? e.clientY : e.touches ? e.touches[0].clientY : 0;\n\t\t\tthis.$nextTick(function () {\n\t\t\t\tvar fw = ~~(nowX - _this4.cropX);\n\t\t\t\tvar fh = ~~(nowY - _this4.cropY);\n\t\t\t\tif (fw > 0) {\n\t\t\t\t\t_this4.cropW = fw + _this4.cropChangeX > _this4.w ? _this4.w - _this4.cropChangeX : fw;\n\t\t\t\t\t_this4.cropOffsertX = _this4.cropChangeX;\n\t\t\t\t} else {\n\t\t\t\t\t_this4.cropW = _this4.w - _this4.cropChangeX + Math.abs(fw) > _this4.w ? _this4.cropChangeX : Math.abs(fw);\n\t\t\t\t\t_this4.cropOffsertX = _this4.cropChangeX + fw > 0 ? _this4.cropChangeX + fw : 0;\n\t\t\t\t}\n\n\t\t\t\tif (!_this4.fixed) {\n\t\t\t\t\tif (fh > 0) {\n\t\t\t\t\t\t_this4.cropH = fh + _this4.cropChangeY > _this4.h ? _this4.h - _this4.cropChangeY : fh;\n\t\t\t\t\t\t_this4.cropOffsertY = _this4.cropChangeY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this4.cropH = _this4.h - _this4.cropChangeY + Math.abs(fh) > _this4.h ? _this4.cropChangeY : Math.abs(fh);\n\t\t\t\t\t\t_this4.cropOffsertY = _this4.cropChangeY + fh > 0 ? _this4.cropChangeY + fh : 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar fixedHeight = ~~(_this4.cropW / _this4.fixedNumber[0] * _this4.fixedNumber[1]);\n\t\t\t\t\tif (fixedHeight + _this4.cropOffsertY > _this4.h) {\n\t\t\t\t\t\t_this4.cropH = _this4.h - _this4.cropOffsertY;\n\t\t\t\t\t\t_this4.cropW = ~~(_this4.cropH / _this4.fixedNumber[1] * _this4.fixedNumber[0]);\n\t\t\t\t\t\tif (fw > 0) {\n\t\t\t\t\t\t\t_this4.cropOffsertX = _this4.cropChangeX;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this4.cropOffsertX = _this4.cropChangeX - _this4.cropW;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this4.cropH = fixedHeight;\n\t\t\t\t\t}\n\t\t\t\t\t_this4.cropOffsertY = _this4.cropOffsertY;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t// 改变截图框大小\n\t\tchangeCropSize: function changeCropSize(e, w, h, typeW, typeH) {\n\t\t\te.preventDefault();\n\t\t\twindow.addEventListener('mousemove', this.changeCropNow);\n\t\t\twindow.addEventListener('mouseup', this.changeCropEnd);\n\t\t\twindow.addEventListener('touchmove', this.changeCropNow);\n\t\t\twindow.addEventListener('touchend', this.changeCropEnd);\n\t\t\tthis.canChangeX = w;\n\t\t\tthis.canChangeY = h;\n\t\t\tthis.changeCropTypeX = typeW;\n\t\t\tthis.changeCropTypeY = typeH;\n\t\t\tthis.cropX = e.clientX ? e.clientX : e.touches[0].clientX;\n\t\t\tthis.cropY = e.clientY ? e.clientY : e.touches[0].clientY;\n\t\t\tthis.cropOldW = this.cropW;\n\t\t\tthis.cropOldH = this.cropH;\n\t\t\tthis.cropChangeX = this.cropOffsertX;\n\t\t\tthis.cropChangeY = this.cropOffsertY;\n\t\t\tif (this.fixed) {\n\t\t\t\tif (this.canChangeX && this.canChangeY) {\n\t\t\t\t\tthis.canChangeY = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t// 正在改变\n\t\tchangeCropNow: function changeCropNow(e) {\n\t\t\tvar _this5 = this;\n\n\t\t\te.preventDefault();\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches ? e.touches[0].clientX : 0;\n\t\t\tvar nowY = e.clientY ? e.clientY : e.touches ? e.touches[0].clientY : 0;\n\t\t\tthis.$nextTick(function () {\n\t\t\t\tvar fw = ~~(nowX - _this5.cropX);\n\t\t\t\tvar fh = ~~(nowY - _this5.cropY);\n\t\t\t\tif (_this5.canChangeX) {\n\t\t\t\t\tif (_this5.changeCropTypeX === 1) {\n\t\t\t\t\t\tif (_this5.cropOldW - fw > 0) {\n\t\t\t\t\t\t\t_this5.cropW = _this5.w - _this5.cropChangeX - fw <= _this5.w ? _this5.cropOldW - fw : _this5.cropOldW + _this5.cropChangeX;\n\t\t\t\t\t\t\t_this5.cropOffsertX = _this5.w - _this5.cropChangeX - fw <= _this5.w ? _this5.cropChangeX + fw : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this5.cropW = Math.abs(fw) + _this5.cropChangeX <= _this5.w ? Math.abs(fw) - _this5.cropOldW : _this5.w - _this5.cropOldW - _this5.cropChangeX;\n\t\t\t\t\t\t\t_this5.cropOffsertX = _this5.cropChangeX + _this5.cropOldW;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (_this5.changeCropTypeX === 2) {\n\t\t\t\t\t\tif (_this5.cropOldW + fw > 0) {\n\t\t\t\t\t\t\t_this5.cropW = _this5.cropOldW + fw + _this5.cropOffsertX <= _this5.w ? _this5.cropOldW + fw : _this5.w - _this5.cropOffsertX;\n\t\t\t\t\t\t\t_this5.cropOffsertX = _this5.cropChangeX;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this5.cropW = _this5.w - _this5.cropChangeX + Math.abs(fw + _this5.cropOldW) <= _this5.w ? Math.abs(fw + _this5.cropOldW) : _this5.cropChangeX;\n\t\t\t\t\t\t\t_this5.cropOffsertX = _this5.w - _this5.cropChangeX + Math.abs(fw + _this5.cropOldW) <= _this5.w ? _this5.cropChangeX - Math.abs(fw + _this5.cropOldW) : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_this5.canChangeY) {\n\t\t\t\t\tif (_this5.changeCropTypeY === 1) {\n\t\t\t\t\t\tif (_this5.cropOldH - fh > 0) {\n\t\t\t\t\t\t\t_this5.cropH = _this5.h - _this5.cropChangeY - fh <= _this5.h ? _this5.cropOldH - fh : _this5.cropOldH + _this5.cropChangeY;\n\t\t\t\t\t\t\t_this5.cropOffsertY = _this5.h - _this5.cropChangeY - fh <= _this5.h ? _this5.cropChangeY + fh : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this5.cropH = Math.abs(fh) + _this5.cropChangeY <= _this5.h ? Math.abs(fh) - _this5.cropOldH : _this5.h - _this5.cropOldH - _this5.cropChangeY;\n\t\t\t\t\t\t\t_this5.cropOffsertY = _this5.cropChangeY + _this5.cropOldH;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (_this5.changeCropTypeY === 2) {\n\t\t\t\t\t\tif (_this5.cropOldH + fh > 0) {\n\t\t\t\t\t\t\t_this5.cropH = _this5.cropOldH + fh + _this5.cropOffsertY <= _this5.h ? _this5.cropOldH + fh : _this5.h - _this5.cropOffsertY;\n\t\t\t\t\t\t\t_this5.cropOffsertY = _this5.cropChangeY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this5.cropH = _this5.h - _this5.cropChangeY + Math.abs(fh + _this5.cropOldH) <= _this5.h ? Math.abs(fh + _this5.cropOldH) : _this5.cropChangeY;\n\t\t\t\t\t\t\t_this5.cropOffsertY = _this5.h - _this5.cropChangeY + Math.abs(fh + _this5.cropOldH) <= _this5.h ? _this5.cropChangeY - Math.abs(fh + _this5.cropOldH) : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_this5.canChangeX && _this5.fixed) {\n\t\t\t\t\tvar fixedHeight = ~~(_this5.cropW / _this5.fixedNumber[0] * _this5.fixedNumber[1]);\n\t\t\t\t\tif (fixedHeight + _this5.cropOffsertY > _this5.h) {\n\t\t\t\t\t\t_this5.cropH = _this5.h - _this5.cropOffsertY;\n\t\t\t\t\t\t_this5.cropW = ~~(_this5.cropH / _this5.fixedNumber[1] * _this5.fixedNumber[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this5.cropH = fixedHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_this5.canChangeY && _this5.fixed) {\n\t\t\t\t\tvar fixedWidth = ~~(_this5.cropH / _this5.fixedNumber[1] * _this5.fixedNumber[0]);\n\t\t\t\t\tif (fixedWidth + _this5.cropOffsertX > _this5.w) {\n\t\t\t\t\t\t_this5.cropW = _this5.w - _this5.cropOffsertX;\n\t\t\t\t\t\t_this5.cropH = ~~(_this5.cropW / _this5.fixedNumber[0] * _this5.fixedNumber[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this5.cropW = fixedWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t// 结束改变\n\t\tchangeCropEnd: function changeCropEnd(e) {\n\t\t\twindow.removeEventListener('mousemove', this.changeCropNow);\n\t\t\twindow.removeEventListener('mouseup', this.changeCropEnd);\n\t\t\twindow.removeEventListener('touchmove', this.changeCropNow);\n\t\t\twindow.removeEventListener('touchend', this.changeCropEnd);\n\t\t},\n\n\n\t\t// 创建完成\n\t\tendCrop: function endCrop() {\n\t\t\tif (this.cropW === 0 && this.cropH === 0) {\n\t\t\t\tthis.cropping = false;\n\t\t\t}\n\t\t\twindow.removeEventListener('mousemove', this.createCrop);\n\t\t\twindow.removeEventListener('mouseup', this.endCrop);\n\t\t\twindow.removeEventListener('touchmove', this.createCrop);\n\t\t\twindow.removeEventListener('touchend', this.endCrop);\n\t\t},\n\n\t\t// 开始截图\n\t\tstartCrop: function startCrop() {\n\t\t\tthis.crop = true;\n\t\t\t// console.log('开始截图')\n\t\t},\n\n\t\t// 停止截图\n\t\tstopCrop: function stopCrop() {\n\t\t\tthis.crop = false;\n\t\t\t// console.log('停止截图')\n\t\t},\n\n\t\t// 清除截图\n\t\tclearCrop: function clearCrop() {\n\t\t\tthis.cropping = false;\n\t\t\tthis.cropW = 0;\n\t\t\tthis.cropH = 0;\n\t\t\t// console.log('清除截图')\n\t\t},\n\n\t\t// 截图移动\n\t\tcropMove: function cropMove(e) {\n\t\t\te.preventDefault();\n\t\t\twindow.addEventListener('mousemove', this.moveCrop);\n\t\t\twindow.addEventListener('mouseup', this.leaveCrop);\n\t\t\twindow.addEventListener('touchmove', this.moveCrop);\n\t\t\twindow.addEventListener('touchend', this.leaveCrop);\n\t\t\tthis.cropX = (e.clientX ? e.clientX : e.touches[0].clientX) - this.cropOffsertX;\n\t\t\tthis.cropY = (e.clientY ? e.clientY : e.touches[0].clientY) - this.cropOffsertY;\n\t\t},\n\t\tmoveCrop: function moveCrop(e) {\n\t\t\tvar _this6 = this;\n\n\t\t\te.preventDefault();\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches[0].clientX;\n\t\t\tvar nowY = e.clientY ? e.clientY : e.touches[0].clientY;\n\t\t\tthis.$nextTick(function () {\n\t\t\t\tvar fw = ~~(nowX - _this6.cropX);\n\t\t\t\tvar fh = ~~(nowY - _this6.cropY);\n\t\t\t\tif (fw <= 1) {\n\t\t\t\t\t_this6.cropOffsertX = 1;\n\t\t\t\t} else if (~~(fw + _this6.cropW) > _this6.w) {\n\t\t\t\t\t_this6.cropOffsertX = _this6.w - _this6.cropW - 1;\n\t\t\t\t} else {\n\t\t\t\t\t_this6.cropOffsertX = fw;\n\t\t\t\t}\n\n\t\t\t\tif (fh <= 1) {\n\t\t\t\t\t_this6.cropOffsertY = 1;\n\t\t\t\t} else if (~~(fh + _this6.cropH) > _this6.h) {\n\t\t\t\t\t_this6.cropOffsertY = _this6.h - _this6.cropH - 1;\n\t\t\t\t} else {\n\t\t\t\t\t_this6.cropOffsertY = fh;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tleaveCrop: function leaveCrop(e) {\n\t\t\twindow.removeEventListener('mousemove', this.moveCrop);\n\t\t\twindow.removeEventListener('mouseup', this.leaveCrop);\n\t\t\twindow.removeEventListener('touchmove', this.moveCrop);\n\t\t\twindow.removeEventListener('touchend', this.leaveCrop);\n\t\t},\n\n\t\t// 获取转换成base64 的图片信息\n\t\tgetCropData: function getCropData(cb) {\n\t\t\tvar _this7 = this;\n\n\t\t\tvar canvas = document.createElement('canvas');\n\t\t\tvar img = new Image();\n\t\t\tvar rotate = this.rotate;\n\t\t\tvar trueWidth = this.trueWidth;\n\t\t\tvar trueHeight = this.trueHeight;\n\t\t\tvar cropOffsertX = this.cropOffsertX;\n\t\t\tvar cropOffsertY = this.cropOffsertY;\n\t\t\timg.onload = function () {\n\t\t\t\tif (~~_this7.cropW !== 0) {\n\t\t\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\t\t\tvar width = _this7.cropW;\n\t\t\t\t\tvar height = _this7.cropH;\n\t\t\t\t\tvar imgW = trueWidth * _this7.scale;\n\t\t\t\t\tvar imgH = trueHeight * _this7.scale;\n\t\t\t\t\t// 图片x轴偏移\n\t\t\t\t\tvar dx = _this7.x - cropOffsertX + _this7.trueWidth * (1 - _this7.scale) / 2;\n\t\t\t\t\t// 图片y轴偏移\n\t\t\t\t\tvar dy = _this7.y - cropOffsertY + _this7.trueHeight * (1 - _this7.scale) / 2;\n\t\t\t\t\t// console.log(dx, dy)\n\t\t\t\t\t//保存状态\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\tctx.save();\n\t\t\t\t\tswitch (rotate) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (!_this7.full) {\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx, dy, imgW, imgH);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// 输出原图比例截图\n\t\t\t\t\t\t\t\tcanvas.width = width / _this7.scale;\n\t\t\t\t\t\t\t\tcanvas.height = height / _this7.scale;\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx / _this7.scale, dy / _this7.scale, imgW / _this7.scale, imgH / _this7.scale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase -3:\n\t\t\t\t\t\t\tif (!_this7.full) {\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\n\t\t\t\t\t\t\t\tdx = dx + (imgW - imgH) / 2;\n\t\t\t\t\t\t\t\tdy = dy + (imgH - imgW) / 2;\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tctx.drawImage(img, dy, -dx - imgH, imgW, imgH);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanvas.width = width / _this7.scale;\n\t\t\t\t\t\t\t\tcanvas.height = height / _this7.scale;\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\n\t\t\t\t\t\t\t\tdx = dx / _this7.scale + (imgW / _this7.scale - imgH / _this7.scale) / 2;\n\t\t\t\t\t\t\t\tdy = dy / _this7.scale + (imgH / _this7.scale - imgW / _this7.scale) / 2;\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tctx.drawImage(img, dy, -dx - imgH / _this7.scale, imgW / _this7.scale, imgH / _this7.scale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\tif (!_this7.full) {\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dx - imgW, -dy - imgH, imgW, imgH);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanvas.width = width / _this7.scale;\n\t\t\t\t\t\t\t\tcanvas.height = height / _this7.scale;\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tdx = dx / _this7.scale;\n\t\t\t\t\t\t\t\tdy = dy / _this7.scale;\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dx - imgW / _this7.scale, -dy - imgH / _this7.scale, imgW / _this7.scale, imgH / _this7.scale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\tif (!_this7.full) {\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\n\t\t\t\t\t\t\t\tdx = dx + (imgW - imgH) / 2;\n\t\t\t\t\t\t\t\tdy = dy + (imgH - imgW) / 2;\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dy - imgW, dx, imgW, imgH);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanvas.width = width / _this7.scale;\n\t\t\t\t\t\t\t\tcanvas.height = height / _this7.scale;\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\n\t\t\t\t\t\t\t\tdx = dx / _this7.scale + (imgW / _this7.scale - imgH / _this7.scale) / 2;\n\t\t\t\t\t\t\t\tdy = dy / _this7.scale + (imgH / _this7.scale - imgW / _this7.scale) / 2;\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dy - imgW / _this7.scale, dx, imgW / _this7.scale, imgH / _this7.scale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (!_this7.full) {\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx, dy, imgW, imgH);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// 输出原图比例截图\n\t\t\t\t\t\t\t\tcanvas.width = width / _this7.scale;\n\t\t\t\t\t\t\t\tcanvas.height = height / _this7.scale;\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx / _this7.scale, dy / _this7.scale, imgW / _this7.scale, imgH / _this7.scale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t} else {\n\t\t\t\t\tvar _width = trueWidth * _this7.scale;\n\t\t\t\t\tvar _height = trueHeight * _this7.scale;\n\t\t\t\t\tvar _ctx = canvas.getContext('2d');\n\t\t\t\t\t_ctx.save();\n\t\t\t\t\tswitch (rotate) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tcanvas.width = _width;\n\t\t\t\t\t\t\tcanvas.height = _height;\n\t\t\t\t\t\t\t_ctx.drawImage(img, 0, 0, _width, _height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase -3:\n\t\t\t\t\t\t\t// 旋转90度 或者-270度 宽度和高度对调\n\t\t\t\t\t\t\tcanvas.width = _height;\n\t\t\t\t\t\t\tcanvas.height = _width;\n\t\t\t\t\t\t\t_ctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t_ctx.drawImage(img, 0, -_height, _width, _height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcase -2:\n\t\t\t\t\t\t\tcanvas.width = _width;\n\t\t\t\t\t\t\tcanvas.height = _height;\n\t\t\t\t\t\t\t_ctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t_ctx.drawImage(img, -_width, -_height, _width, _height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase -1:\n\t\t\t\t\t\t\tcanvas.width = _height;\n\t\t\t\t\t\t\tcanvas.height = _width;\n\t\t\t\t\t\t\t_ctx.rotate(rotate * 90 * Math.PI / 180);\n\t\t\t\t\t\t\t_ctx.drawImage(img, -_width, 0, _width, _height);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tcanvas.width = _width;\n\t\t\t\t\t\t\tcanvas.height = _height;\n\t\t\t\t\t\t\t_ctx.drawImage(img, 0, 0, _width, _height);\n\t\t\t\t\t}\n\t\t\t\t\t_ctx.restore();\n\t\t\t\t}\n\t\t\t\tvar data = canvas.toDataURL('image/' + _this7.outputType, _this7.outputSize);\n\t\t\t\tcb(data);\n\t\t\t};\n\t\t\t// 判断图片是否是base64\n\t\t\tvar s = this.img.substr(0, 4);\n\t\t\tif (s !== 'data') {\n\t\t\t\timg.crossOrigin = 'anonymous';\n\t\t\t}\n\t\t\timg.src = this.imgs;\n\t\t},\n\n\t\t//转化base64 为blob对象\n\t\tgetCropBlob: function getCropBlob(cb) {\n\t\t\tthis.getCropData(function (data) {\n\t\t\t\tvar arr = data.split(',');\n\t\t\t\tvar mime = arr[0].match(/:(.*?);/)[1];\n\t\t\t\tvar bstr = atob(arr[1]);\n\t\t\t\tvar n = bstr.length;\n\t\t\t\tvar u8arr = new Uint8Array(n);\n\t\t\t\twhile (n--) {\n\t\t\t\t\tu8arr[n] = bstr.charCodeAt(n);\n\t\t\t\t}\n\t\t\t\tcb(new Blob([u8arr], {\n\t\t\t\t\ttype: mime\n\t\t\t\t}));\n\t\t\t});\n\t\t},\n\n\n\t\t// 自动预览函数\n\t\tshowPreview: function showPreview() {\n\t\t\tvar obj = {};\n\t\t\tobj.div = {\n\t\t\t\t'width': this.cropW + 'px',\n\t\t\t\t'height': this.cropH + 'px'\n\t\t\t};\n\t\t\tobj.img = {\n\t\t\t\t'width': this.trueWidth + 'px',\n\t\t\t\t'height': this.trueHeight + 'px',\n\t\t\t\t'transform': 'scale(' + this.scale + ',' + this.scale + ') ' + 'translate3d(' + (this.x - this.cropOffsertX) / this.scale + 'px,' + (this.y - this.cropOffsertY) / this.scale + 'px,' + '0)' + 'rotateZ(' + this.rotate * 90 + 'deg)'\n\t\t\t};\n\t\t\tobj.w = this.cropW;\n\t\t\tobj.h = this.cropH;\n\t\t\tobj.url = this.imgs;\n\t\t\tthis.$emit('realTime', obj);\n\t\t},\n\n\t\t// reload 图片布局函数\n\t\treload: function reload() {\n\t\t\tvar _this8 = this;\n\n\t\t\tvar img = new Image();\n\t\t\timg.onload = function () {\n\t\t\t\t// 读取图片的信息原始信息， 解析是否需要旋转\n\t\t\t\t// 读取图片的旋转信息\n\t\t\t\t// 得到外层容器的宽度高度\n\t\t\t\t_this8.w = ~~window.getComputedStyle(_this8.$refs.cropper).width.replace('px', '');\n\t\t\t\t_this8.h = ~~window.getComputedStyle(_this8.$refs.cropper).height.replace('px', '');\n\n\t\t\t\t// 存入图片真实高度\n\t\t\t\t_this8.trueWidth = img.width;\n\t\t\t\t_this8.trueHeight = img.height;\n\n\t\t\t\tif (_this8.trueWidth > _this8.w) {\n\t\t\t\t\t// 如果图片宽度大于容器宽度\n\t\t\t\t\t_this8.scale = _this8.w / _this8.trueWidth;\n\t\t\t\t}\n\n\t\t\t\tif (_this8.trueHeight * _this8.scale > _this8.h) {\n\t\t\t\t\t_this8.scale = _this8.h / _this8.trueHeight;\n\t\t\t\t}\n\n\t\t\t\t_this8.$nextTick(function () {\n\t\t\t\t\t_this8.x = -(_this8.trueWidth - _this8.trueWidth * _this8.scale) / 2 + (_this8.w - _this8.trueWidth * _this8.scale) / 2;\n\t\t\t\t\t_this8.y = -(_this8.trueHeight - _this8.trueHeight * _this8.scale) / 2 + (_this8.h - _this8.trueHeight * _this8.scale) / 2;\n\t\t\t\t\t_this8.loading = false;\n\t\t\t\t\t// 获取是否开启了自动截图\n\t\t\t\t\tif (_this8.autoCrop) {\n\t\t\t\t\t\t_this8.goAutoCrop();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\timg.src = this.imgs;\n\t\t},\n\n\t\t// 自动截图函数\n\t\tgoAutoCrop: function goAutoCrop() {\n\t\t\tthis.cropping = true;\n\t\t\t// 截图框默认大小\n\t\t\t// 如果为0 那么计算容器大小 默认为80%\n\t\t\tvar w = this.autoCropWidth;\n\t\t\tvar h = this.autoCropHeight;\n\t\t\tif (w === 0 || h === 0) {\n\t\t\t\tw = this.w * 0.8;\n\t\t\t\th = this.h * 0.8;\n\t\t\t}\n\t\t\tw = w > this.w ? this.w : w;\n\t\t\th = h > this.h ? this.h : h;\n\t\t\tif (this.fixed) {\n\t\t\t\th = w / this.fixedNumber[0] * this.fixedNumber[1];\n\t\t\t}\n\t\t\t// 如果比例之后 高度大于h\n\t\t\tif (h > this.h) {\n\t\t\t\th = this.h;\n\t\t\t\tw = h / this.fixedNumber[1] * this.fixedNumber[0];\n\t\t\t}\n\t\t\tthis.changeCrop(w, h);\n\t\t},\n\n\t\t// 手动改变截图框大小函数\n\t\tchangeCrop: function changeCrop(w, h) {\n\t\t\t// 判断是否大于容器\n\t\t\tthis.cropW = w;\n\t\t\tthis.cropH = h;\n\t\t\t// 居中走一走\n\t\t\tthis.cropOffsertX = (this.w - w) / 2;\n\t\t\tthis.cropOffsertY = (this.h - h) / 2;\n\t\t},\n\n\t\t// 重置函数， 恢复组件置初始状态\n\t\trefresh: function refresh() {\n\t\t\t// console.log('refresh')\n\t\t},\n\n\n\t\t// 向左边旋转\n\t\trotateLeft: function rotateLeft() {\n\t\t\tthis.rotate = this.rotate <= -3 ? 0 : this.rotate - 1;\n\t\t},\n\n\n\t\t// 向右边旋转\n\t\trotateRight: function rotateRight() {\n\t\t\tthis.rotate = this.rotate >= 3 ? 0 : this.rotate + 1;\n\t\t},\n\n\n\t\t// 清除旋转\n\t\trotateClear: function rotateClear() {\n\t\t\tthis.rotate = 0;\n\t\t}\n\t},\n\tmounted: function mounted() {\n\t\tthis.showPreview();\n\t\tthis.checkedImg();\n\t\tvar u = navigator.userAgent;\n\t\tthis.isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n\t}\n});\n\n/***/ }),\n\n/***/ \"tQYy\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"wrapper\"},[_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.model),expression:\"model\"}],staticClass:\"model\",on:{\"click\":function($event){_vm.model = false}}},[_c('div',{staticClass:\"model-show\"},[_c('img',{attrs:{\"src\":_vm.modelSrc,\"alt\":\"\"}})]),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.modelBtn),expression:\"modelBtn\"}],staticClass:\"container\",staticStyle:{\"width\":\"20%\",\"margin-top\":\"-10%\",\"margin-left\":\"44%\"},on:{\"click\":function($event){_vm.modelBtn = false}}},[_c('div',{staticStyle:{\"margin-left\":\"-25%\",\"margin-top\":\"-2%\"}},[_c('font',{attrs:{\"size\":\"2\",\"color\":\"#ffffff\",\"face\":\"微软雅黑\"}},[_vm._v(\"✱ 【确定】后将会上传图片为【课程封面】\")]),_c('br')],1),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"4%\"}},[_c('button',{staticClass:\"btn btn-info\",on:{\"click\":_vm.addDB}},[_vm._v(\"确定\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"5%\"}},[_vm._v(\"取消\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('div',{staticClass:\"show-info\"},[_c('h2',{staticClass:\"title\"},[_vm._v(\"选择课程封面图片\")]),_vm._v(\" \"),_c('div',{staticClass:\"test\"},[_c('vueCropper',{ref:\"cropper2\",attrs:{\"img\":_vm.example2.img,\"outputSize\":_vm.example2.size,\"outputType\":_vm.example2.outputType,\"info\":_vm.example2.info,\"canScale\":_vm.example2.canScale,\"autoCrop\":_vm.example2.autoCrop,\"autoCropWidth\":_vm.example2.width,\"autoCropHeight\":_vm.example2.height,\"fixed\":_vm.example2.fixed,\"fixedNumber\":_vm.example2.fixedNumber}})],1),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"1%\"}},[_c('label',{staticClass:\"btn btn-warning\",attrs:{\"for\":\"upload2\"}},[_vm._v(\"选择图片\")]),_vm._v(\" \"),_c('input',{staticStyle:{\"position\":\"absolute\",\"clip\":\"rect(0 0 0 0)\"},attrs:{\"type\":\"file\",\"id\":\"upload2\",\"accept\":\"image/png, image/jpeg, image/gif, image/jpg\"},on:{\"change\":function($event){_vm.uploadImg($event, 2)}}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-info\",staticStyle:{\"margin-left\":\"1%\"},on:{\"click\":function($event){_vm.finish2('base64')}}},[_vm._v(\"预览\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"1%\"},on:{\"click\":_vm.upload}},[_vm._v(\"完成\")])])])])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"yOBD\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\r\n\r\n    var debug = false;\r\n\r\n    var root = this;\r\n\r\n    var EXIF = function(obj) {\r\n        if (obj instanceof EXIF) return obj;\r\n        if (!(this instanceof EXIF)) return new EXIF(obj);\r\n        this.EXIFwrapped = obj;\r\n    };\r\n\r\n    if (true) {\r\n        if (typeof module !== 'undefined' && module.exports) {\r\n            exports = module.exports = EXIF;\r\n        }\r\n        exports.EXIF = EXIF;\r\n    } else {\r\n        root.EXIF = EXIF;\r\n    }\r\n\r\n    var ExifTags = EXIF.Tags = {\r\n\r\n        // version tags\r\n        0x9000 : \"ExifVersion\",             // EXIF version\r\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\r\n\r\n        // colorspace tags\r\n        0xA001 : \"ColorSpace\",              // Color space information tag\r\n\r\n        // image configuration\r\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\r\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\r\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\r\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\r\n\r\n        // user information\r\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\r\n        0x9286 : \"UserComment\",             // Comments by user\r\n\r\n        // related file\r\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\r\n\r\n        // date and time\r\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\r\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\r\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\r\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\r\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\r\n\r\n        // picture-taking conditions\r\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\r\n        0x829D : \"FNumber\",                 // F number\r\n        0x8822 : \"ExposureProgram\",         // Exposure program\r\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\r\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\r\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\r\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\r\n        0x9202 : \"ApertureValue\",           // Lens aperture\r\n        0x9203 : \"BrightnessValue\",         // Value of brightness\r\n        0x9204 : \"ExposureBias\",            // Exposure bias\r\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\r\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\r\n        0x9207 : \"MeteringMode\",            // Metering mode\r\n        0x9208 : \"LightSource\",             // Kind of light source\r\n        0x9209 : \"Flash\",                   // Flash status\r\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\r\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\r\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\r\n        0xA20C : \"SpatialFrequencyResponse\",    //\r\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\r\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\r\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\r\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\r\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\r\n        0xA217 : \"SensingMethod\",           // Image sensor type\r\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\r\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\r\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\r\n        0xA401 : \"CustomRendered\",          // Special processing\r\n        0xA402 : \"ExposureMode\",            // Exposure mode\r\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\r\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\r\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\r\n        0xA406 : \"SceneCaptureType\",        // Type of scene\r\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\r\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\r\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\r\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\r\n        0xA40B : \"DeviceSettingDescription\",    //\r\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\r\n\r\n        // other tags\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\r\n    };\r\n\r\n    var TiffTags = EXIF.TiffTags = {\r\n        0x0100 : \"ImageWidth\",\r\n        0x0101 : \"ImageHeight\",\r\n        0x8769 : \"ExifIFDPointer\",\r\n        0x8825 : \"GPSInfoIFDPointer\",\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0x0102 : \"BitsPerSample\",\r\n        0x0103 : \"Compression\",\r\n        0x0106 : \"PhotometricInterpretation\",\r\n        0x0112 : \"Orientation\",\r\n        0x0115 : \"SamplesPerPixel\",\r\n        0x011C : \"PlanarConfiguration\",\r\n        0x0212 : \"YCbCrSubSampling\",\r\n        0x0213 : \"YCbCrPositioning\",\r\n        0x011A : \"XResolution\",\r\n        0x011B : \"YResolution\",\r\n        0x0128 : \"ResolutionUnit\",\r\n        0x0111 : \"StripOffsets\",\r\n        0x0116 : \"RowsPerStrip\",\r\n        0x0117 : \"StripByteCounts\",\r\n        0x0201 : \"JPEGInterchangeFormat\",\r\n        0x0202 : \"JPEGInterchangeFormatLength\",\r\n        0x012D : \"TransferFunction\",\r\n        0x013E : \"WhitePoint\",\r\n        0x013F : \"PrimaryChromaticities\",\r\n        0x0211 : \"YCbCrCoefficients\",\r\n        0x0214 : \"ReferenceBlackWhite\",\r\n        0x0132 : \"DateTime\",\r\n        0x010E : \"ImageDescription\",\r\n        0x010F : \"Make\",\r\n        0x0110 : \"Model\",\r\n        0x0131 : \"Software\",\r\n        0x013B : \"Artist\",\r\n        0x8298 : \"Copyright\"\r\n    };\r\n\r\n    var GPSTags = EXIF.GPSTags = {\r\n        0x0000 : \"GPSVersionID\",\r\n        0x0001 : \"GPSLatitudeRef\",\r\n        0x0002 : \"GPSLatitude\",\r\n        0x0003 : \"GPSLongitudeRef\",\r\n        0x0004 : \"GPSLongitude\",\r\n        0x0005 : \"GPSAltitudeRef\",\r\n        0x0006 : \"GPSAltitude\",\r\n        0x0007 : \"GPSTimeStamp\",\r\n        0x0008 : \"GPSSatellites\",\r\n        0x0009 : \"GPSStatus\",\r\n        0x000A : \"GPSMeasureMode\",\r\n        0x000B : \"GPSDOP\",\r\n        0x000C : \"GPSSpeedRef\",\r\n        0x000D : \"GPSSpeed\",\r\n        0x000E : \"GPSTrackRef\",\r\n        0x000F : \"GPSTrack\",\r\n        0x0010 : \"GPSImgDirectionRef\",\r\n        0x0011 : \"GPSImgDirection\",\r\n        0x0012 : \"GPSMapDatum\",\r\n        0x0013 : \"GPSDestLatitudeRef\",\r\n        0x0014 : \"GPSDestLatitude\",\r\n        0x0015 : \"GPSDestLongitudeRef\",\r\n        0x0016 : \"GPSDestLongitude\",\r\n        0x0017 : \"GPSDestBearingRef\",\r\n        0x0018 : \"GPSDestBearing\",\r\n        0x0019 : \"GPSDestDistanceRef\",\r\n        0x001A : \"GPSDestDistance\",\r\n        0x001B : \"GPSProcessingMethod\",\r\n        0x001C : \"GPSAreaInformation\",\r\n        0x001D : \"GPSDateStamp\",\r\n        0x001E : \"GPSDifferential\"\r\n    };\r\n\r\n     // EXIF 2.3 Spec\r\n    var IFD1Tags = EXIF.IFD1Tags = {\r\n        0x0100: \"ImageWidth\",\r\n        0x0101: \"ImageHeight\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0103: \"Compression\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x0111: \"StripOffsets\",\r\n        0x0112: \"Orientation\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x011A: \"XResolution\",\r\n        0x011B: \"YResolution\",\r\n        0x011C: \"PlanarConfiguration\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\r\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x0214: \"ReferenceBlackWhite\"\r\n    };\r\n\r\n    var StringValues = EXIF.StringValues = {\r\n        ExposureProgram : {\r\n            0 : \"Not defined\",\r\n            1 : \"Manual\",\r\n            2 : \"Normal program\",\r\n            3 : \"Aperture priority\",\r\n            4 : \"Shutter priority\",\r\n            5 : \"Creative program\",\r\n            6 : \"Action program\",\r\n            7 : \"Portrait mode\",\r\n            8 : \"Landscape mode\"\r\n        },\r\n        MeteringMode : {\r\n            0 : \"Unknown\",\r\n            1 : \"Average\",\r\n            2 : \"CenterWeightedAverage\",\r\n            3 : \"Spot\",\r\n            4 : \"MultiSpot\",\r\n            5 : \"Pattern\",\r\n            6 : \"Partial\",\r\n            255 : \"Other\"\r\n        },\r\n        LightSource : {\r\n            0 : \"Unknown\",\r\n            1 : \"Daylight\",\r\n            2 : \"Fluorescent\",\r\n            3 : \"Tungsten (incandescent light)\",\r\n            4 : \"Flash\",\r\n            9 : \"Fine weather\",\r\n            10 : \"Cloudy weather\",\r\n            11 : \"Shade\",\r\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\r\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\r\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\r\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\r\n            17 : \"Standard light A\",\r\n            18 : \"Standard light B\",\r\n            19 : \"Standard light C\",\r\n            20 : \"D55\",\r\n            21 : \"D65\",\r\n            22 : \"D75\",\r\n            23 : \"D50\",\r\n            24 : \"ISO studio tungsten\",\r\n            255 : \"Other\"\r\n        },\r\n        Flash : {\r\n            0x0000 : \"Flash did not fire\",\r\n            0x0001 : \"Flash fired\",\r\n            0x0005 : \"Strobe return light not detected\",\r\n            0x0007 : \"Strobe return light detected\",\r\n            0x0009 : \"Flash fired, compulsory flash mode\",\r\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\r\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\r\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\r\n            0x0018 : \"Flash did not fire, auto mode\",\r\n            0x0019 : \"Flash fired, auto mode\",\r\n            0x001D : \"Flash fired, auto mode, return light not detected\",\r\n            0x001F : \"Flash fired, auto mode, return light detected\",\r\n            0x0020 : \"No flash function\",\r\n            0x0041 : \"Flash fired, red-eye reduction mode\",\r\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\r\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\r\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\r\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\r\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\r\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\r\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\r\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\r\n        },\r\n        SensingMethod : {\r\n            1 : \"Not defined\",\r\n            2 : \"One-chip color area sensor\",\r\n            3 : \"Two-chip color area sensor\",\r\n            4 : \"Three-chip color area sensor\",\r\n            5 : \"Color sequential area sensor\",\r\n            7 : \"Trilinear sensor\",\r\n            8 : \"Color sequential linear sensor\"\r\n        },\r\n        SceneCaptureType : {\r\n            0 : \"Standard\",\r\n            1 : \"Landscape\",\r\n            2 : \"Portrait\",\r\n            3 : \"Night scene\"\r\n        },\r\n        SceneType : {\r\n            1 : \"Directly photographed\"\r\n        },\r\n        CustomRendered : {\r\n            0 : \"Normal process\",\r\n            1 : \"Custom process\"\r\n        },\r\n        WhiteBalance : {\r\n            0 : \"Auto white balance\",\r\n            1 : \"Manual white balance\"\r\n        },\r\n        GainControl : {\r\n            0 : \"None\",\r\n            1 : \"Low gain up\",\r\n            2 : \"High gain up\",\r\n            3 : \"Low gain down\",\r\n            4 : \"High gain down\"\r\n        },\r\n        Contrast : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        Saturation : {\r\n            0 : \"Normal\",\r\n            1 : \"Low saturation\",\r\n            2 : \"High saturation\"\r\n        },\r\n        Sharpness : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        SubjectDistanceRange : {\r\n            0 : \"Unknown\",\r\n            1 : \"Macro\",\r\n            2 : \"Close view\",\r\n            3 : \"Distant view\"\r\n        },\r\n        FileSource : {\r\n            3 : \"DSC\"\r\n        },\r\n\r\n        Components : {\r\n            0 : \"\",\r\n            1 : \"Y\",\r\n            2 : \"Cb\",\r\n            3 : \"Cr\",\r\n            4 : \"R\",\r\n            5 : \"G\",\r\n            6 : \"B\"\r\n        }\r\n    };\r\n\r\n    function addEvent(element, event, handler) {\r\n        if (element.addEventListener) {\r\n            element.addEventListener(event, handler, false);\r\n        } else if (element.attachEvent) {\r\n            element.attachEvent(\"on\" + event, handler);\r\n        }\r\n    }\r\n\r\n    function imageHasData(img) {\r\n        return !!(img.exifdata);\r\n    }\r\n\r\n\r\n    function base64ToArrayBuffer(base64, contentType) {\r\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\r\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\r\n        var binary = atob(base64);\r\n        var len = binary.length;\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        for (var i = 0; i < len; i++) {\r\n            view[i] = binary.charCodeAt(i);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    function objectURLToBlob(url, callback) {\r\n        var http = new XMLHttpRequest();\r\n        http.open(\"GET\", url, true);\r\n        http.responseType = \"blob\";\r\n        http.onload = function(e) {\r\n            if (this.status == 200 || this.status === 0) {\r\n                callback(this.response);\r\n            }\r\n        };\r\n        http.send();\r\n    }\r\n\r\n    function getImageData(img, callback) {\r\n        function handleBinaryFile(binFile) {\r\n            var data = findEXIFinJPEG(binFile);\r\n            img.exifdata = data || {};\r\n            var iptcdata = findIPTCinJPEG(binFile);\r\n            img.iptcdata = iptcdata || {};\r\n            if (EXIF.isXmpEnabled) {\r\n               var xmpdata= findXMPinJPEG(binFile);\r\n               img.xmpdata = xmpdata || {};               \r\n            }\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n\r\n        if (img.src) {\r\n            if (/^data\\:/i.test(img.src)) { // Data URI\r\n                var arrayBuffer = base64ToArrayBuffer(img.src);\r\n                handleBinaryFile(arrayBuffer);\r\n\r\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\r\n                var fileReader = new FileReader();\r\n                fileReader.onload = function(e) {\r\n                    handleBinaryFile(e.target.result);\r\n                };\r\n                objectURLToBlob(img.src, function (blob) {\r\n                    fileReader.readAsArrayBuffer(blob);\r\n                });\r\n            } else {\r\n                var http = new XMLHttpRequest();\r\n                http.onload = function() {\r\n                    if (this.status == 200 || this.status === 0) {\r\n                        handleBinaryFile(http.response);\r\n                    } else {\r\n                        throw \"Could not load image\";\r\n                    }\r\n                    http = null;\r\n                };\r\n                http.open(\"GET\", img.src, true);\r\n                http.responseType = \"arraybuffer\";\r\n                http.send(null);\r\n            }\r\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\r\n            var fileReader = new FileReader();\r\n            fileReader.onload = function(e) {\r\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\r\n                handleBinaryFile(e.target.result);\r\n            };\r\n\r\n            fileReader.readAsArrayBuffer(img);\r\n        }\r\n    }\r\n\r\n    function findEXIFinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            marker;\r\n\r\n        while (offset < length) {\r\n            if (dataView.getUint8(offset) != 0xFF) {\r\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\r\n                return false; // not a valid marker, something is wrong\r\n            }\r\n\r\n            marker = dataView.getUint8(offset + 1);\r\n            if (debug) console.log(marker);\r\n\r\n            // we could implement handling for other markers here,\r\n            // but we're only looking for 0xFFE1 for EXIF data\r\n\r\n            if (marker == 225) {\r\n                if (debug) console.log(\"Found 0xFFE1 marker\");\r\n\r\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\r\n\r\n                // offset += 2 + file.getShortAt(offset+2, true);\r\n\r\n            } else {\r\n                offset += 2 + dataView.getUint16(offset+2);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function findIPTCinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength;\r\n\r\n\r\n        var isFieldSegmentStart = function(dataView, offset){\r\n            return (\r\n                dataView.getUint8(offset) === 0x38 &&\r\n                dataView.getUint8(offset+1) === 0x42 &&\r\n                dataView.getUint8(offset+2) === 0x49 &&\r\n                dataView.getUint8(offset+3) === 0x4D &&\r\n                dataView.getUint8(offset+4) === 0x04 &&\r\n                dataView.getUint8(offset+5) === 0x04\r\n            );\r\n        };\r\n\r\n        while (offset < length) {\r\n\r\n            if ( isFieldSegmentStart(dataView, offset )){\r\n\r\n                // Get the length of the name header (which is padded to an even number of bytes)\r\n                var nameHeaderLength = dataView.getUint8(offset+7);\r\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\r\n                // Check for pre photoshop 6 format\r\n                if(nameHeaderLength === 0) {\r\n                    // Always 4\r\n                    nameHeaderLength = 4;\r\n                }\r\n\r\n                var startOffset = offset + 8 + nameHeaderLength;\r\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\r\n\r\n                return readIPTCData(file, startOffset, sectionLength);\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n            // Not the marker, continue searching\r\n            offset++;\r\n\r\n        }\r\n\r\n    }\r\n    var IptcFieldMap = {\r\n        0x78 : 'caption',\r\n        0x6E : 'credit',\r\n        0x19 : 'keywords',\r\n        0x37 : 'dateCreated',\r\n        0x50 : 'byline',\r\n        0x55 : 'bylineTitle',\r\n        0x7A : 'captionWriter',\r\n        0x69 : 'headline',\r\n        0x74 : 'copyright',\r\n        0x0F : 'category'\r\n    };\r\n    function readIPTCData(file, startOffset, sectionLength){\r\n        var dataView = new DataView(file);\r\n        var data = {};\r\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\r\n        var segmentStartPos = startOffset;\r\n        while(segmentStartPos < startOffset+sectionLength) {\r\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\r\n                segmentType = dataView.getUint8(segmentStartPos+2);\r\n                if(segmentType in IptcFieldMap) {\r\n                    dataSize = dataView.getInt16(segmentStartPos+3);\r\n                    segmentSize = dataSize + 5;\r\n                    fieldName = IptcFieldMap[segmentType];\r\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\r\n                    // Check if we already stored a value with this name\r\n                    if(data.hasOwnProperty(fieldName)) {\r\n                        // Value already stored with this name, create multivalue field\r\n                        if(data[fieldName] instanceof Array) {\r\n                            data[fieldName].push(fieldValue);\r\n                        }\r\n                        else {\r\n                            data[fieldName] = [data[fieldName], fieldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        data[fieldName] = fieldValue;\r\n                    }\r\n                }\r\n\r\n            }\r\n            segmentStartPos++;\r\n        }\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\r\n        var entries = file.getUint16(dirStart, !bigEnd),\r\n            tags = {},\r\n            entryOffset, tag,\r\n            i;\r\n\r\n        for (i=0;i<entries;i++) {\r\n            entryOffset = dirStart + i*12 + 2;\r\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\r\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n        }\r\n        return tags;\r\n    }\r\n\r\n\r\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n        var type = file.getUint16(entryOffset+2, !bigEnd),\r\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\r\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\r\n            offset,\r\n            vals, val, n,\r\n            numerator, denominator;\r\n\r\n        switch (type) {\r\n            case 1: // byte, 8-bit unsigned int\r\n            case 7: // undefined, 8-bit byte, value depending on field\r\n                if (numValues == 1) {\r\n                    return file.getUint8(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint8(offset + n);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 2: // ascii, 8-bit byte\r\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                return getStringFromDB(file, offset, numValues-1);\r\n\r\n            case 3: // short, 16 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint16(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 4: // long, 32 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 5:    // rational = two long values, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    numerator = file.getUint32(valueOffset, !bigEnd);\r\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\r\n                    val = new Number(numerator / denominator);\r\n                    val.numerator = numerator;\r\n                    val.denominator = denominator;\r\n                    return val;\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\r\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\r\n                        vals[n] = new Number(numerator / denominator);\r\n                        vals[n].numerator = numerator;\r\n                        vals[n].denominator = denominator;\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 9: // slong, 32 bit signed int\r\n                if (numValues == 1) {\r\n                    return file.getInt32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Given an IFD (Image File Directory) start offset\r\n    * returns an offset to next IFD or 0 if it's the last IFD.\r\n    */\r\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\r\n        //the first 2bytes means the number of directory entries contains in this IFD\r\n        var entries = dataView.getUint16(dirStart, !bigEnd);\r\n\r\n        // After last directory entry, there is a 4bytes of data,\r\n        // it means an offset to next IFD.\r\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\r\n\r\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\r\n    }\r\n\r\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\r\n        // get the IFD1 offset\r\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\r\n\r\n        if (!IFD1OffsetPointer) {\r\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\r\n            return {};\r\n        }\r\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\r\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\r\n            return {};\r\n        }\r\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\r\n\r\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\r\n\r\n        // EXIF 2.3 specification for JPEG format thumbnail\r\n\r\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\r\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\r\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\r\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\r\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\r\n\r\n        if (thumbTags['Compression']) {\r\n            // console.log('Thumbnail image found!');\r\n\r\n            switch (thumbTags['Compression']) {\r\n                case 6:\r\n                    // console.log('Thumbnail image format is JPEG');\r\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\r\n                    // extract the thumbnail\r\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\r\n                        var tLength = thumbTags.JpegIFByteCount;\r\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\r\n                            type: 'image/jpeg'\r\n                        });\r\n                    }\r\n                break;\r\n\r\n            case 1:\r\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\r\n                break;\r\n            default:\r\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\r\n            }\r\n        }\r\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\r\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\r\n        }\r\n        return thumbTags;\r\n    }\r\n\r\n    function getStringFromDB(buffer, start, length) {\r\n        var outstr = \"\";\r\n        for (n = start; n < start+length; n++) {\r\n            outstr += String.fromCharCode(buffer.getUint8(n));\r\n        }\r\n        return outstr;\r\n    }\r\n\r\n    function readEXIFData(file, start) {\r\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\r\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\r\n            return false;\r\n        }\r\n\r\n        var bigEnd,\r\n            tags, tag,\r\n            exifData, gpsData,\r\n            tiffOffset = start + 6;\r\n\r\n        // test for TIFF validity and endianness\r\n        if (file.getUint16(tiffOffset) == 0x4949) {\r\n            bigEnd = false;\r\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\r\n            bigEnd = true;\r\n        } else {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\r\n            return false;\r\n        }\r\n\r\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\r\n            return false;\r\n        }\r\n\r\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\r\n\r\n        if (firstIFDOffset < 0x00000008) {\r\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\r\n            return false;\r\n        }\r\n\r\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\r\n\r\n        if (tags.ExifIFDPointer) {\r\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\r\n            for (tag in exifData) {\r\n                switch (tag) {\r\n                    case \"LightSource\" :\r\n                    case \"Flash\" :\r\n                    case \"MeteringMode\" :\r\n                    case \"ExposureProgram\" :\r\n                    case \"SensingMethod\" :\r\n                    case \"SceneCaptureType\" :\r\n                    case \"SceneType\" :\r\n                    case \"CustomRendered\" :\r\n                    case \"WhiteBalance\" :\r\n                    case \"GainControl\" :\r\n                    case \"Contrast\" :\r\n                    case \"Saturation\" :\r\n                    case \"Sharpness\" :\r\n                    case \"SubjectDistanceRange\" :\r\n                    case \"FileSource\" :\r\n                        exifData[tag] = StringValues[tag][exifData[tag]];\r\n                        break;\r\n\r\n                    case \"ExifVersion\" :\r\n                    case \"FlashpixVersion\" :\r\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\r\n                        break;\r\n\r\n                    case \"ComponentsConfiguration\" :\r\n                        exifData[tag] =\r\n                            StringValues.Components[exifData[tag][0]] +\r\n                            StringValues.Components[exifData[tag][1]] +\r\n                            StringValues.Components[exifData[tag][2]] +\r\n                            StringValues.Components[exifData[tag][3]];\r\n                        break;\r\n                }\r\n                tags[tag] = exifData[tag];\r\n            }\r\n        }\r\n\r\n        if (tags.GPSInfoIFDPointer) {\r\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\r\n            for (tag in gpsData) {\r\n                switch (tag) {\r\n                    case \"GPSVersionID\" :\r\n                        gpsData[tag] = gpsData[tag][0] +\r\n                            \".\" + gpsData[tag][1] +\r\n                            \".\" + gpsData[tag][2] +\r\n                            \".\" + gpsData[tag][3];\r\n                        break;\r\n                }\r\n                tags[tag] = gpsData[tag];\r\n            }\r\n        }\r\n\r\n        // extract thumbnail\r\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\r\n\r\n        return tags;\r\n    }\r\n\r\n   function findXMPinJPEG(file) {\r\n\r\n        if (!('DOMParser' in self)) {\r\n            // console.warn('XML parsing not supported without DOMParser');\r\n            return;\r\n        }\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n           if (debug) console.log(\"Not a valid JPEG\");\r\n           return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            dom = new DOMParser();\r\n\r\n        while (offset < (length-4)) {\r\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\r\n                var startOffset = offset - 1;\r\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\r\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\r\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\r\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\r\n\r\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\r\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\r\n                //Without these namespaces, XML is thought to be invalid by parsers\r\n                xmpString = xmpString.slice(0, indexOfXmp)\r\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\r\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\r\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\r\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\r\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\r\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\r\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\r\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\r\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\r\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\r\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\r\n                            + xmpString.slice(indexOfXmp)\r\n\r\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\r\n                return xml2Object(domDocument);\r\n            } else{\r\n             offset++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function xml2json(xml) {\r\n        var json = {};\r\n      \r\n        if (xml.nodeType == 1) { // element node\r\n          if (xml.attributes.length > 0) {\r\n            json['@attributes'] = {};\r\n            for (var j = 0; j < xml.attributes.length; j++) {\r\n              var attribute = xml.attributes.item(j);\r\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\r\n            }\r\n          }\r\n        } else if (xml.nodeType == 3) { // text node\r\n          return xml.nodeValue;\r\n        }\r\n      \r\n        // deal with children\r\n        if (xml.hasChildNodes()) {\r\n          for(var i = 0; i < xml.childNodes.length; i++) {\r\n            var child = xml.childNodes.item(i);\r\n            var nodeName = child.nodeName;\r\n            if (json[nodeName] == null) {\r\n              json[nodeName] = xml2json(child);\r\n            } else {\r\n              if (json[nodeName].push == null) {\r\n                var old = json[nodeName];\r\n                json[nodeName] = [];\r\n                json[nodeName].push(old);\r\n              }\r\n              json[nodeName].push(xml2json(child));\r\n            }\r\n          }\r\n        }\r\n        \r\n        return json;\r\n    }\r\n\r\n    function xml2Object(xml) {\r\n        try {\r\n            var obj = {};\r\n            if (xml.children.length > 0) {\r\n              for (var i = 0; i < xml.children.length; i++) {\r\n                var item = xml.children.item(i);\r\n                var attributes = item.attributes;\r\n                for(var idx in attributes) {\r\n                    var itemAtt = attributes[idx];\r\n                    var dataKey = itemAtt.nodeName;\r\n                    var dataValue = itemAtt.nodeValue;\r\n\r\n                    if(dataKey !== undefined) {\r\n                        obj[dataKey] = dataValue;\r\n                    }\r\n                }\r\n                var nodeName = item.nodeName;\r\n\r\n                if (typeof (obj[nodeName]) == \"undefined\") {\r\n                  obj[nodeName] = xml2json(item);\r\n                } else {\r\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\r\n                    var old = obj[nodeName];\r\n\r\n                    obj[nodeName] = [];\r\n                    obj[nodeName].push(old);\r\n                  }\r\n                  obj[nodeName].push(xml2json(item));\r\n                }\r\n              }\r\n            } else {\r\n              obj = xml.textContent;\r\n            }\r\n            return obj;\r\n          } catch (e) {\r\n              console.log(e.message);\r\n          }\r\n    }\r\n\r\n    EXIF.enableXmp = function() {\r\n        EXIF.isXmpEnabled = true;\r\n    }\r\n\r\n    EXIF.disableXmp = function() {\r\n        EXIF.isXmpEnabled = false;\r\n    }\r\n\r\n    EXIF.getData = function(img, callback) {\r\n        if (((self.Image && img instanceof self.Image)\r\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\r\n            && !img.complete)\r\n            return false;\r\n\r\n        if (!imageHasData(img)) {\r\n            getImageData(img, callback);\r\n        } else {\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    EXIF.getTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.exifdata[tag];\r\n    }\r\n    \r\n    EXIF.getIptcTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.iptcdata[tag];\r\n    }\r\n\r\n    EXIF.getAllTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.exifdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n    \r\n    EXIF.getAllIptcTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.iptcdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    EXIF.pretty = function(img) {\r\n        if (!imageHasData(img)) return \"\";\r\n        var a,\r\n            data = img.exifdata,\r\n            strPretty = \"\";\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                if (typeof data[a] == \"object\") {\r\n                    if (data[a] instanceof Number) {\r\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\r\n                    } else {\r\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\r\n                    }\r\n                } else {\r\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n        return strPretty;\r\n    }\r\n\r\n    EXIF.readFromBinaryFile = function(file) {\r\n        return findEXIFinJPEG(file);\r\n    }\r\n\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n            return EXIF;\r\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    }\r\n}.call(this));\r\n\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// vue/js/5.b8ca75b462c1146c519b.js","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/_css-loader@0.28.7@css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-9e4d1e1c\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./CourseInfo.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/_vue-style-loader@3.0.3@vue-style-loader/lib/addStylesClient.js\")(\"4caeb91b\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/_vue-style-loader@3.0.3@vue-style-loader!./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-9e4d1e1c\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/CourseInfo.vue\n// module id = +N4l\n// module chunks = 5","exports = module.exports = require(\"../../_css-loader@0.28.7@css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"@font-face{font-family:summernote;font-style:normal;font-weight:400;src:url(\" + require(\"./font/summernote.eot?0d0d5fac99cc8774d89eb08b1a8323c4\") + \");src:url(\" + require(\"./font/summernote.eot\") + \"?#iefix) format(\\\"embedded-opentype\\\"),url(\" + require(\"./font/summernote.woff?0d0d5fac99cc8774d89eb08b1a8323c4\") + \") format(\\\"woff\\\"),url(\" + require(\"./font/summernote.ttf?0d0d5fac99cc8774d89eb08b1a8323c4\") + \") format(\\\"truetype\\\")}[class*=\\\" note-icon-\\\"]:before,[class^=note-icon-]:before{display:inline-block;font:normal normal normal 14px summernote;font-size:inherit;-webkit-font-smoothing:antialiased;text-decoration:inherit;text-rendering:auto;text-transform:none;vertical-align:middle;speak:none;-moz-osx-font-smoothing:grayscale}.note-icon-align-center:before,.note-icon-align-indent:before,.note-icon-align-justify:before,.note-icon-align-left:before,.note-icon-align-outdent:before,.note-icon-align-right:before,.note-icon-align:before,.note-icon-arrow-circle-down:before,.note-icon-arrow-circle-left:before,.note-icon-arrow-circle-right:before,.note-icon-arrow-circle-up:before,.note-icon-arrows-alt:before,.note-icon-arrows-h:before,.note-icon-arrows-v:before,.note-icon-bold:before,.note-icon-caret:before,.note-icon-chain-broken:before,.note-icon-circle:before,.note-icon-close:before,.note-icon-code:before,.note-icon-col-after:before,.note-icon-col-before:before,.note-icon-col-remove:before,.note-icon-eraser:before,.note-icon-font:before,.note-icon-frame:before,.note-icon-italic:before,.note-icon-link:before,.note-icon-magic:before,.note-icon-menu-check:before,.note-icon-minus:before,.note-icon-orderedlist:before,.note-icon-pencil:before,.note-icon-picture:before,.note-icon-question:before,.note-icon-redo:before,.note-icon-row-above:before,.note-icon-row-below:before,.note-icon-row-remove:before,.note-icon-special-character:before,.note-icon-square:before,.note-icon-strikethrough:before,.note-icon-subscript:before,.note-icon-summernote:before,.note-icon-superscript:before,.note-icon-table:before,.note-icon-text-height:before,.note-icon-trash:before,.note-icon-underline:before,.note-icon-undo:before,.note-icon-unorderedlist:before,.note-icon-video:before{display:inline-block;font-family:summernote;font-style:normal;font-weight:400;text-decoration:inherit}.note-icon-align-center:before{content:\\\"\\\\F101\\\"}.note-icon-align-indent:before{content:\\\"\\\\F102\\\"}.note-icon-align-justify:before{content:\\\"\\\\F103\\\"}.note-icon-align-left:before{content:\\\"\\\\F104\\\"}.note-icon-align-outdent:before{content:\\\"\\\\F105\\\"}.note-icon-align-right:before{content:\\\"\\\\F106\\\"}.note-icon-align:before{content:\\\"\\\\F107\\\"}.note-icon-arrow-circle-down:before{content:\\\"\\\\F108\\\"}.note-icon-arrow-circle-left:before{content:\\\"\\\\F109\\\"}.note-icon-arrow-circle-right:before{content:\\\"\\\\F10A\\\"}.note-icon-arrow-circle-up:before{content:\\\"\\\\F10B\\\"}.note-icon-arrows-alt:before{content:\\\"\\\\F10C\\\"}.note-icon-arrows-h:before{content:\\\"\\\\F10D\\\"}.note-icon-arrows-v:before{content:\\\"\\\\F10E\\\"}.note-icon-bold:before{content:\\\"\\\\F10F\\\"}.note-icon-caret:before{content:\\\"\\\\F110\\\"}.note-icon-chain-broken:before{content:\\\"\\\\F111\\\"}.note-icon-circle:before{content:\\\"\\\\F112\\\"}.note-icon-close:before{content:\\\"\\\\F113\\\"}.note-icon-code:before{content:\\\"\\\\F114\\\"}.note-icon-col-after:before{content:\\\"\\\\F115\\\"}.note-icon-col-before:before{content:\\\"\\\\F116\\\"}.note-icon-col-remove:before{content:\\\"\\\\F117\\\"}.note-icon-eraser:before{content:\\\"\\\\F118\\\"}.note-icon-font:before{content:\\\"\\\\F119\\\"}.note-icon-frame:before{content:\\\"\\\\F11A\\\"}.note-icon-italic:before{content:\\\"\\\\F11B\\\"}.note-icon-link:before{content:\\\"\\\\F11C\\\"}.note-icon-magic:before{content:\\\"\\\\F11D\\\"}.note-icon-menu-check:before{content:\\\"\\\\F11E\\\"}.note-icon-minus:before{content:\\\"\\\\F11F\\\"}.note-icon-orderedlist:before{content:\\\"\\\\F120\\\"}.note-icon-pencil:before{content:\\\"\\\\F121\\\"}.note-icon-picture:before{content:\\\"\\\\F122\\\"}.note-icon-question:before{content:\\\"\\\\F123\\\"}.note-icon-redo:before{content:\\\"\\\\F124\\\"}.note-icon-row-above:before{content:\\\"\\\\F125\\\"}.note-icon-row-below:before{content:\\\"\\\\F126\\\"}.note-icon-row-remove:before{content:\\\"\\\\F127\\\"}.note-icon-special-character:before{content:\\\"\\\\F128\\\"}.note-icon-square:before{content:\\\"\\\\F129\\\"}.note-icon-strikethrough:before{content:\\\"\\\\F12A\\\"}.note-icon-subscript:before{content:\\\"\\\\F12B\\\"}.note-icon-summernote:before{content:\\\"\\\\F12C\\\"}.note-icon-superscript:before{content:\\\"\\\\F12D\\\"}.note-icon-table:before{content:\\\"\\\\F12E\\\"}.note-icon-text-height:before{content:\\\"\\\\F12F\\\"}.note-icon-trash:before{content:\\\"\\\\F130\\\"}.note-icon-underline:before{content:\\\"\\\\F131\\\"}.note-icon-undo:before{content:\\\"\\\\F132\\\"}.note-icon-unorderedlist:before{content:\\\"\\\\F133\\\"}.note-icon-video:before{content:\\\"\\\\F134\\\"}.note-editor{position:relative}.note-editor .note-dropzone{position:absolute;z-index:100;display:none;color:#87cefa;background-color:#fff;opacity:.95}.note-editor .note-dropzone .note-dropzone-message{display:table-cell;font-size:28px;font-weight:700;text-align:center;vertical-align:middle}.note-editor .note-dropzone.hover{color:#098ddf}.note-editor.dragover .note-dropzone{display:table}.note-editor .note-editing-area{position:relative}.note-editor .note-editing-area .note-editable{outline:0}.note-editor .note-editing-area .note-editable sup{vertical-align:super}.note-editor .note-editing-area .note-editable sub{vertical-align:sub}.note-editor .note-editing-area img.note-float-left{margin-right:10px}.note-editor .note-editing-area img.note-float-right{margin-left:10px}.note-editor.note-frame{border:1px solid #a9a9a9}.note-editor.note-frame.codeview .note-editing-area .note-editable{display:none}.note-editor.note-frame.codeview .note-editing-area .note-codable{display:block}.note-editor.note-frame .note-editing-area{overflow:hidden}.note-editor.note-frame .note-editing-area .note-editable{padding:10px;overflow:auto;color:#000;background-color:#fff}.note-editor.note-frame .note-editing-area .note-editable[contenteditable=false]{background-color:#e5e5e5}.note-editor.note-frame .note-editing-area .note-codable{display:none;width:100%;padding:10px;margin-bottom:0;font-family:Menlo,Monaco,monospace,sans-serif;font-size:14px;color:#ccc;background-color:#222;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;box-shadow:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;resize:none}.note-editor.note-frame.fullscreen{position:fixed;top:0;left:0;z-index:1050;width:100%!important}.note-editor.note-frame.fullscreen .note-editable{background-color:#fff}.note-editor.note-frame.fullscreen .note-resizebar{display:none}.note-editor.note-frame .note-statusbar{background-color:#f5f5f5;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.note-editor.note-frame .note-statusbar .note-resizebar{width:100%;height:8px;padding-top:1px;cursor:ns-resize}.note-editor.note-frame .note-statusbar .note-resizebar .note-icon-bar{width:20px;margin:1px auto;border-top:1px solid #a9a9a9}.note-editor.note-frame .note-placeholder{padding:10px}.note-popover.popover{max-width:none}.note-popover.popover .popover-content a{display:inline-block;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle}.note-popover.popover .arrow{left:20px!important}.note-popover .popover-content,.panel-heading.note-toolbar{padding:0 0 5px 5px;margin:0}.note-popover .popover-content>.btn-group,.panel-heading.note-toolbar>.btn-group{margin-top:5px;margin-right:5px;margin-left:0}.note-popover .popover-content .btn-group .note-table,.panel-heading.note-toolbar .btn-group .note-table{min-width:0;padding:5px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker{font-size:18px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher{position:absolute!important;z-index:3;width:10em;height:10em;cursor:pointer}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted{position:relative!important;z-index:1;width:5em;height:5em;background:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC\\\") repeat}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted{position:absolute!important;z-index:2;width:1em;height:1em;background:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIjd6vvD2f9LKLW+AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKwNDEVT0AAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC\\\") repeat}.note-popover .popover-content .note-style blockquote,.note-popover .popover-content .note-style h1,.note-popover .popover-content .note-style h2,.note-popover .popover-content .note-style h3,.note-popover .popover-content .note-style h4,.note-popover .popover-content .note-style h5,.note-popover .popover-content .note-style h6,.panel-heading.note-toolbar .note-style blockquote,.panel-heading.note-toolbar .note-style h1,.panel-heading.note-toolbar .note-style h2,.panel-heading.note-toolbar .note-style h3,.panel-heading.note-toolbar .note-style h4,.panel-heading.note-toolbar .note-style h5,.panel-heading.note-toolbar .note-style h6{margin:0}.note-popover .popover-content .note-color .dropdown-toggle,.panel-heading.note-toolbar .note-color .dropdown-toggle{width:20px;padding-left:5px}.note-popover .popover-content .note-color .dropdown-menu,.panel-heading.note-toolbar .note-color .dropdown-menu{min-width:337px}.note-popover .popover-content .note-color .dropdown-menu .note-palette,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette{display:inline-block;width:160px;margin:0}.note-popover .popover-content .note-color .dropdown-menu .note-palette:first-child,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette:first-child{margin:0 5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-palette-title,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-palette-title{margin:2px 7px;font-size:12px;text-align:center;border-bottom:1px solid #eee}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset{width:100%;padding:0 3px;margin:3px;font-size:11px;cursor:pointer;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-row,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-row{height:20px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset:hover,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset:hover{background:#eee}.note-popover .popover-content .note-para .dropdown-menu,.panel-heading.note-toolbar .note-para .dropdown-menu{min-width:216px;padding:5px}.note-popover .popover-content .note-para .dropdown-menu>div:first-child,.panel-heading.note-toolbar .note-para .dropdown-menu>div:first-child{margin-right:5px}.note-popover .popover-content .dropdown-menu,.panel-heading.note-toolbar .dropdown-menu{min-width:90px}.note-popover .popover-content .dropdown-menu.right,.panel-heading.note-toolbar .dropdown-menu.right{right:0;left:auto}.note-popover .popover-content .dropdown-menu.right:before,.panel-heading.note-toolbar .dropdown-menu.right:before{right:9px;left:auto!important}.note-popover .popover-content .dropdown-menu.right:after,.panel-heading.note-toolbar .dropdown-menu.right:after{right:10px;left:auto!important}.note-popover .popover-content .dropdown-menu.note-check li a i,.panel-heading.note-toolbar .dropdown-menu.note-check li a i{color:#00bfff;visibility:hidden}.note-popover .popover-content .dropdown-menu.note-check li a.checked i,.panel-heading.note-toolbar .dropdown-menu.note-check li a.checked i{visibility:visible}.note-popover .popover-content .note-fontsize-10,.panel-heading.note-toolbar .note-fontsize-10{font-size:10px}.note-popover .popover-content .note-color-palette,.panel-heading.note-toolbar .note-color-palette{line-height:1}.note-popover .popover-content .note-color-palette div .note-color-btn,.panel-heading.note-toolbar .note-color-palette div .note-color-btn{width:20px;height:20px;padding:0;margin:0;border:1px solid #fff}.note-popover .popover-content .note-color-palette div .note-color-btn:hover,.panel-heading.note-toolbar .note-color-palette div .note-color-btn:hover{border:1px solid #000}.note-dialog>div{display:none}.note-dialog .form-group{margin-right:0;margin-left:0}.note-dialog .note-modal-form{margin:0}.note-dialog .note-image-dialog .note-dropzone{min-height:100px;margin-bottom:10px;font-size:30px;line-height:4;color:#d3d3d3;text-align:center;border:4px dashed #d3d3d3}@-moz-document url-prefix(){.note-image-input{height:auto}}.note-placeholder{position:absolute;display:none;color:gray}.note-handle .note-control-selection{position:absolute;display:none;border:1px solid #000}.note-handle .note-control-selection>div{position:absolute}.note-handle .note-control-selection .note-control-selection-bg{width:100%;height:100%;background-color:#000;-webkit-opacity:.3;-khtml-opacity:.3;-moz-opacity:.3;opacity:.3;-ms-filter:alpha(opacity=30);filter:alpha(opacity=30)}.note-handle .note-control-selection .note-control-handle,.note-handle .note-control-selection .note-control-holder{width:7px;height:7px;border:1px solid #000}.note-handle .note-control-selection .note-control-sizing{width:7px;height:7px;background-color:#fff;border:1px solid #000}.note-handle .note-control-selection .note-control-nw{top:-5px;left:-5px;border-right:0;border-bottom:0}.note-handle .note-control-selection .note-control-ne{top:-5px;right:-5px;border-bottom:0;border-left:none}.note-handle .note-control-selection .note-control-sw{bottom:-5px;left:-5px;border-top:0;border-right:0}.note-handle .note-control-selection .note-control-se{right:-5px;bottom:-5px;cursor:se-resize}.note-handle .note-control-selection .note-control-se.note-control-holder{cursor:default;border-top:0;border-left:none}.note-handle .note-control-selection .note-control-selection-info{right:0;bottom:0;padding:5px;margin:5px;font-size:12px;color:#fff;background-color:#000;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-opacity:.7;-khtml-opacity:.7;-moz-opacity:.7;opacity:.7;-ms-filter:alpha(opacity=70);filter:alpha(opacity=70)}.note-hint-popover{min-width:100px;padding:2px}.note-hint-popover .popover-content{max-height:150px;padding:3px;overflow:auto}.note-hint-popover .popover-content .note-hint-group .note-hint-item{display:block!important;padding:3px}.note-hint-popover .popover-content .note-hint-group .note-hint-item.active,.note-hint-popover .popover-content .note-hint-group .note-hint-item:hover{display:block;clear:both;font-weight:400;line-height:1.4;color:#fff;text-decoration:none;white-space:nowrap;cursor:pointer;background-color:#428bca;outline:0}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/node_modules/_summernote@0.8.8@summernote/dist/summernote.css\"],\"names\":[],\"mappings\":\"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\",\"file\":\"summernote.css\",\"sourcesContent\":[\"@font-face{font-family:\\\"summernote\\\";font-style:normal;font-weight:normal;src:url(\\\"./font/summernote.eot?0d0d5fac99cc8774d89eb08b1a8323c4\\\");src:url(\\\"./font/summernote.eot?#iefix\\\") format(\\\"embedded-opentype\\\"),url(\\\"./font/summernote.woff?0d0d5fac99cc8774d89eb08b1a8323c4\\\") format(\\\"woff\\\"),url(\\\"./font/summernote.ttf?0d0d5fac99cc8774d89eb08b1a8323c4\\\") format(\\\"truetype\\\")}[class^=\\\"note-icon-\\\"]:before,[class*=\\\" note-icon-\\\"]:before{display:inline-block;font:normal normal normal 14px summernote;font-size:inherit;-webkit-font-smoothing:antialiased;text-decoration:inherit;text-rendering:auto;text-transform:none;vertical-align:middle;speak:none;-moz-osx-font-smoothing:grayscale}.note-icon-align-center:before,.note-icon-align-indent:before,.note-icon-align-justify:before,.note-icon-align-left:before,.note-icon-align-outdent:before,.note-icon-align-right:before,.note-icon-align:before,.note-icon-arrow-circle-down:before,.note-icon-arrow-circle-left:before,.note-icon-arrow-circle-right:before,.note-icon-arrow-circle-up:before,.note-icon-arrows-alt:before,.note-icon-arrows-h:before,.note-icon-arrows-v:before,.note-icon-bold:before,.note-icon-caret:before,.note-icon-chain-broken:before,.note-icon-circle:before,.note-icon-close:before,.note-icon-code:before,.note-icon-col-after:before,.note-icon-col-before:before,.note-icon-col-remove:before,.note-icon-eraser:before,.note-icon-font:before,.note-icon-frame:before,.note-icon-italic:before,.note-icon-link:before,.note-icon-magic:before,.note-icon-menu-check:before,.note-icon-minus:before,.note-icon-orderedlist:before,.note-icon-pencil:before,.note-icon-picture:before,.note-icon-question:before,.note-icon-redo:before,.note-icon-row-above:before,.note-icon-row-below:before,.note-icon-row-remove:before,.note-icon-special-character:before,.note-icon-square:before,.note-icon-strikethrough:before,.note-icon-subscript:before,.note-icon-summernote:before,.note-icon-superscript:before,.note-icon-table:before,.note-icon-text-height:before,.note-icon-trash:before,.note-icon-underline:before,.note-icon-undo:before,.note-icon-unorderedlist:before,.note-icon-video:before{display:inline-block;font-family:\\\"summernote\\\";font-style:normal;font-weight:normal;text-decoration:inherit}.note-icon-align-center:before{content:\\\"\\\\f101\\\"}.note-icon-align-indent:before{content:\\\"\\\\f102\\\"}.note-icon-align-justify:before{content:\\\"\\\\f103\\\"}.note-icon-align-left:before{content:\\\"\\\\f104\\\"}.note-icon-align-outdent:before{content:\\\"\\\\f105\\\"}.note-icon-align-right:before{content:\\\"\\\\f106\\\"}.note-icon-align:before{content:\\\"\\\\f107\\\"}.note-icon-arrow-circle-down:before{content:\\\"\\\\f108\\\"}.note-icon-arrow-circle-left:before{content:\\\"\\\\f109\\\"}.note-icon-arrow-circle-right:before{content:\\\"\\\\f10a\\\"}.note-icon-arrow-circle-up:before{content:\\\"\\\\f10b\\\"}.note-icon-arrows-alt:before{content:\\\"\\\\f10c\\\"}.note-icon-arrows-h:before{content:\\\"\\\\f10d\\\"}.note-icon-arrows-v:before{content:\\\"\\\\f10e\\\"}.note-icon-bold:before{content:\\\"\\\\f10f\\\"}.note-icon-caret:before{content:\\\"\\\\f110\\\"}.note-icon-chain-broken:before{content:\\\"\\\\f111\\\"}.note-icon-circle:before{content:\\\"\\\\f112\\\"}.note-icon-close:before{content:\\\"\\\\f113\\\"}.note-icon-code:before{content:\\\"\\\\f114\\\"}.note-icon-col-after:before{content:\\\"\\\\f115\\\"}.note-icon-col-before:before{content:\\\"\\\\f116\\\"}.note-icon-col-remove:before{content:\\\"\\\\f117\\\"}.note-icon-eraser:before{content:\\\"\\\\f118\\\"}.note-icon-font:before{content:\\\"\\\\f119\\\"}.note-icon-frame:before{content:\\\"\\\\f11a\\\"}.note-icon-italic:before{content:\\\"\\\\f11b\\\"}.note-icon-link:before{content:\\\"\\\\f11c\\\"}.note-icon-magic:before{content:\\\"\\\\f11d\\\"}.note-icon-menu-check:before{content:\\\"\\\\f11e\\\"}.note-icon-minus:before{content:\\\"\\\\f11f\\\"}.note-icon-orderedlist:before{content:\\\"\\\\f120\\\"}.note-icon-pencil:before{content:\\\"\\\\f121\\\"}.note-icon-picture:before{content:\\\"\\\\f122\\\"}.note-icon-question:before{content:\\\"\\\\f123\\\"}.note-icon-redo:before{content:\\\"\\\\f124\\\"}.note-icon-row-above:before{content:\\\"\\\\f125\\\"}.note-icon-row-below:before{content:\\\"\\\\f126\\\"}.note-icon-row-remove:before{content:\\\"\\\\f127\\\"}.note-icon-special-character:before{content:\\\"\\\\f128\\\"}.note-icon-square:before{content:\\\"\\\\f129\\\"}.note-icon-strikethrough:before{content:\\\"\\\\f12a\\\"}.note-icon-subscript:before{content:\\\"\\\\f12b\\\"}.note-icon-summernote:before{content:\\\"\\\\f12c\\\"}.note-icon-superscript:before{content:\\\"\\\\f12d\\\"}.note-icon-table:before{content:\\\"\\\\f12e\\\"}.note-icon-text-height:before{content:\\\"\\\\f12f\\\"}.note-icon-trash:before{content:\\\"\\\\f130\\\"}.note-icon-underline:before{content:\\\"\\\\f131\\\"}.note-icon-undo:before{content:\\\"\\\\f132\\\"}.note-icon-unorderedlist:before{content:\\\"\\\\f133\\\"}.note-icon-video:before{content:\\\"\\\\f134\\\"}.note-editor{position:relative}.note-editor .note-dropzone{position:absolute;z-index:100;display:none;color:#87cefa;background-color:white;opacity:.95}.note-editor .note-dropzone .note-dropzone-message{display:table-cell;font-size:28px;font-weight:bold;text-align:center;vertical-align:middle}.note-editor .note-dropzone.hover{color:#098ddf}.note-editor.dragover .note-dropzone{display:table}.note-editor .note-editing-area{position:relative}.note-editor .note-editing-area .note-editable{outline:0}.note-editor .note-editing-area .note-editable sup{vertical-align:super}.note-editor .note-editing-area .note-editable sub{vertical-align:sub}.note-editor .note-editing-area img.note-float-left{margin-right:10px}.note-editor .note-editing-area img.note-float-right{margin-left:10px}.note-editor.note-frame{border:1px solid #a9a9a9}.note-editor.note-frame.codeview .note-editing-area .note-editable{display:none}.note-editor.note-frame.codeview .note-editing-area .note-codable{display:block}.note-editor.note-frame .note-editing-area{overflow:hidden}.note-editor.note-frame .note-editing-area .note-editable{padding:10px;overflow:auto;color:#000;background-color:#fff}.note-editor.note-frame .note-editing-area .note-editable[contenteditable=\\\"false\\\"]{background-color:#e5e5e5}.note-editor.note-frame .note-editing-area .note-codable{display:none;width:100%;padding:10px;margin-bottom:0;font-family:Menlo,Monaco,monospace,sans-serif;font-size:14px;color:#ccc;background-color:#222;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;box-shadow:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;resize:none}.note-editor.note-frame.fullscreen{position:fixed;top:0;left:0;z-index:1050;width:100%!important}.note-editor.note-frame.fullscreen .note-editable{background-color:white}.note-editor.note-frame.fullscreen .note-resizebar{display:none}.note-editor.note-frame .note-statusbar{background-color:#f5f5f5;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.note-editor.note-frame .note-statusbar .note-resizebar{width:100%;height:8px;padding-top:1px;cursor:ns-resize}.note-editor.note-frame .note-statusbar .note-resizebar .note-icon-bar{width:20px;margin:1px auto;border-top:1px solid #a9a9a9}.note-editor.note-frame .note-placeholder{padding:10px}.note-popover.popover{max-width:none}.note-popover.popover .popover-content a{display:inline-block;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle}.note-popover.popover .arrow{left:20px!important}.note-popover .popover-content,.panel-heading.note-toolbar{padding:0 0 5px 5px;margin:0}.note-popover .popover-content>.btn-group,.panel-heading.note-toolbar>.btn-group{margin-top:5px;margin-right:5px;margin-left:0}.note-popover .popover-content .btn-group .note-table,.panel-heading.note-toolbar .btn-group .note-table{min-width:0;padding:5px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker{font-size:18px}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-mousecatcher{position:absolute!important;z-index:3;width:10em;height:10em;cursor:pointer}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-unhighlighted{position:relative!important;z-index:1;width:5em;height:5em;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat}.note-popover .popover-content .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted,.panel-heading.note-toolbar .btn-group .note-table .note-dimension-picker .note-dimension-picker-highlighted{position:absolute!important;z-index:2;width:1em;height:1em;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIjd6vvD2f9LKLW+AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKwNDEVT0AAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat}.note-popover .popover-content .note-style h1,.panel-heading.note-toolbar .note-style h1,.note-popover .popover-content .note-style h2,.panel-heading.note-toolbar .note-style h2,.note-popover .popover-content .note-style h3,.panel-heading.note-toolbar .note-style h3,.note-popover .popover-content .note-style h4,.panel-heading.note-toolbar .note-style h4,.note-popover .popover-content .note-style h5,.panel-heading.note-toolbar .note-style h5,.note-popover .popover-content .note-style h6,.panel-heading.note-toolbar .note-style h6,.note-popover .popover-content .note-style blockquote,.panel-heading.note-toolbar .note-style blockquote{margin:0}.note-popover .popover-content .note-color .dropdown-toggle,.panel-heading.note-toolbar .note-color .dropdown-toggle{width:20px;padding-left:5px}.note-popover .popover-content .note-color .dropdown-menu,.panel-heading.note-toolbar .note-color .dropdown-menu{min-width:337px}.note-popover .popover-content .note-color .dropdown-menu .note-palette,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette{display:inline-block;width:160px;margin:0}.note-popover .popover-content .note-color .dropdown-menu .note-palette:first-child,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette:first-child{margin:0 5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-palette-title,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-palette-title{margin:2px 7px;font-size:12px;text-align:center;border-bottom:1px solid #eee}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset{width:100%;padding:0 3px;margin:3px;font-size:11px;cursor:pointer;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-row,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-row{height:20px}.note-popover .popover-content .note-color .dropdown-menu .note-palette .note-color-reset:hover,.panel-heading.note-toolbar .note-color .dropdown-menu .note-palette .note-color-reset:hover{background:#eee}.note-popover .popover-content .note-para .dropdown-menu,.panel-heading.note-toolbar .note-para .dropdown-menu{min-width:216px;padding:5px}.note-popover .popover-content .note-para .dropdown-menu>div:first-child,.panel-heading.note-toolbar .note-para .dropdown-menu>div:first-child{margin-right:5px}.note-popover .popover-content .dropdown-menu,.panel-heading.note-toolbar .dropdown-menu{min-width:90px}.note-popover .popover-content .dropdown-menu.right,.panel-heading.note-toolbar .dropdown-menu.right{right:0;left:auto}.note-popover .popover-content .dropdown-menu.right::before,.panel-heading.note-toolbar .dropdown-menu.right::before{right:9px;left:auto!important}.note-popover .popover-content .dropdown-menu.right::after,.panel-heading.note-toolbar .dropdown-menu.right::after{right:10px;left:auto!important}.note-popover .popover-content .dropdown-menu.note-check li a i,.panel-heading.note-toolbar .dropdown-menu.note-check li a i{color:deepskyblue;visibility:hidden}.note-popover .popover-content .dropdown-menu.note-check li a.checked i,.panel-heading.note-toolbar .dropdown-menu.note-check li a.checked i{visibility:visible}.note-popover .popover-content .note-fontsize-10,.panel-heading.note-toolbar .note-fontsize-10{font-size:10px}.note-popover .popover-content .note-color-palette,.panel-heading.note-toolbar .note-color-palette{line-height:1}.note-popover .popover-content .note-color-palette div .note-color-btn,.panel-heading.note-toolbar .note-color-palette div .note-color-btn{width:20px;height:20px;padding:0;margin:0;border:1px solid #fff}.note-popover .popover-content .note-color-palette div .note-color-btn:hover,.panel-heading.note-toolbar .note-color-palette div .note-color-btn:hover{border:1px solid #000}.note-dialog>div{display:none}.note-dialog .form-group{margin-right:0;margin-left:0}.note-dialog .note-modal-form{margin:0}.note-dialog .note-image-dialog .note-dropzone{min-height:100px;margin-bottom:10px;font-size:30px;line-height:4;color:lightgray;text-align:center;border:4px dashed lightgray}@-moz-document url-prefix(){.note-image-input{height:auto}}.note-placeholder{position:absolute;display:none;color:gray}.note-handle .note-control-selection{position:absolute;display:none;border:1px solid black}.note-handle .note-control-selection>div{position:absolute}.note-handle .note-control-selection .note-control-selection-bg{width:100%;height:100%;background-color:black;-webkit-opacity:.3;-khtml-opacity:.3;-moz-opacity:.3;opacity:.3;-ms-filter:alpha(opacity=30);filter:alpha(opacity=30)}.note-handle .note-control-selection .note-control-handle{width:7px;height:7px;border:1px solid black}.note-handle .note-control-selection .note-control-holder{width:7px;height:7px;border:1px solid black}.note-handle .note-control-selection .note-control-sizing{width:7px;height:7px;background-color:white;border:1px solid black}.note-handle .note-control-selection .note-control-nw{top:-5px;left:-5px;border-right:0;border-bottom:0}.note-handle .note-control-selection .note-control-ne{top:-5px;right:-5px;border-bottom:0;border-left:none}.note-handle .note-control-selection .note-control-sw{bottom:-5px;left:-5px;border-top:0;border-right:0}.note-handle .note-control-selection .note-control-se{right:-5px;bottom:-5px;cursor:se-resize}.note-handle .note-control-selection .note-control-se.note-control-holder{cursor:default;border-top:0;border-left:none}.note-handle .note-control-selection .note-control-selection-info{right:0;bottom:0;padding:5px;margin:5px;font-size:12px;color:white;background-color:black;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;-webkit-opacity:.7;-khtml-opacity:.7;-moz-opacity:.7;opacity:.7;-ms-filter:alpha(opacity=70);filter:alpha(opacity=70)}.note-hint-popover{min-width:100px;padding:2px}.note-hint-popover .popover-content{max-height:150px;padding:3px;overflow:auto}.note-hint-popover .popover-content .note-hint-group .note-hint-item{display:block!important;padding:3px}.note-hint-popover .popover-content .note-hint-group .note-hint-item.active,.note-hint-popover .popover-content .note-hint-group .note-hint-item:hover{display:block;clear:both;font-weight:400;line-height:1.4;color:white;text-decoration:none;white-space:nowrap;cursor:pointer;background-color:#428bca;outline:0}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_summernote@0.8.8@summernote/dist/summernote.css\n// module id = /AwD\n// module chunks = 5","(function ($) {\r\n  $.extend($.summernote.lang, {\r\n    'zh-CN': {\r\n      font: {\r\n        bold: '粗体',\r\n        italic: '斜体',\r\n        underline: '下划线',\r\n        clear: '清除格式',\r\n        height: '行高',\r\n        name: '字体',\r\n        strikethrough: '删除线',\r\n        subscript: '下标',\r\n        superscript: '上标',\r\n        size: '字号'\r\n      },\r\n      image: {\r\n        image: '图片',\r\n        insert: '插入图片',\r\n        resizeFull: '缩放至 100%',\r\n        resizeHalf: '缩放至 50%',\r\n        resizeQuarter: '缩放至 25%',\r\n        floatLeft: '靠左浮动',\r\n        floatRight: '靠右浮动',\r\n        floatNone: '取消浮动',\r\n        shapeRounded: '形状: 圆角',\r\n        shapeCircle: '形状: 圆',\r\n        shapeThumbnail: '形状: 缩略图',\r\n        shapeNone: '形状: 无',\r\n        dragImageHere: '将图片拖拽至此处',\r\n        selectFromFiles: '本地图片上传',\r\n        maximumFileSize: '文件大小最大值',\r\n        maximumFileSizeError: '文件大小超出最大值。',\r\n        url: '在线图片引用(地址)',\r\n        remove: '移除图片'\r\n      },\r\n      video: {\r\n        video: '视频',\r\n        videoLink: '视频链接',\r\n        insert: '插入视频',\r\n        url: '视频地址',\r\n        providers: '(优酷, 腾讯, Instagram, DailyMotion, Youtube等)'\r\n      },\r\n      link: {\r\n        link: '链接',\r\n        insert: '插入链接',\r\n        unlink: '去除链接',\r\n        edit: '编辑链接',\r\n        textToDisplay: '显示文本',\r\n        url: '链接地址',\r\n        openInNewWindow: '在新窗口打开'\r\n      },\r\n      table: {\r\n        table: '表格'\r\n      },\r\n      hr: {\r\n        insert: '水平线'\r\n      },\r\n      style: {\r\n        style: '样式',\r\n        p: '普通',\r\n        blockquote: '引用',\r\n        pre: '代码',\r\n        h1: '标题 1',\r\n        h2: '标题 2',\r\n        h3: '标题 3',\r\n        h4: '标题 4',\r\n        h5: '标题 5',\r\n        h6: '标题 6'\r\n      },\r\n      lists: {\r\n        unordered: '无序列表',\r\n        ordered: '有序列表'\r\n      },\r\n      options: {\r\n        help: '帮助',\r\n        fullscreen: '全屏',\r\n        codeview: '源代码'\r\n      },\r\n      paragraph: {\r\n        paragraph: '段落',\r\n        outdent: '减少缩进',\r\n        indent: '增加缩进',\r\n        left: '左对齐',\r\n        center: '居中对齐',\r\n        right: '右对齐',\r\n        justify: '两端对齐'\r\n      },\r\n      color: {\r\n        recent: '最近使用',\r\n        more: '更多',\r\n        background: '背景',\r\n        foreground: '前景',\r\n        transparent: '透明',\r\n        setTransparent: '透明',\r\n        reset: '重置',\r\n        resetToDefault: '默认'\r\n      },\r\n      shortcut: {\r\n        shortcuts: '快捷键',\r\n        close: '关闭',\r\n        textFormatting: '文本格式',\r\n        action: '动作',\r\n        paragraphFormatting: '段落格式',\r\n        documentStyle: '文档样式',\r\n        extraKeys: '额外按键'\r\n      },\r\n      history: {\r\n        undo: '撤销',\r\n        redo: '重做'\r\n      },\r\n      help: {\r\n        insertParagraph: '插入段落',\r\n        undo: '撤销',\r\n        redo: '重做',\r\n        tab: '增加缩进',\r\n        untab: '减少缩进',\r\n        bold: '粗体',\r\n        italic: '斜体',\r\n        underline: '下划线',\r\n        strikethrough: '删除线',\r\n        removeFormat: '清除格式',\r\n        justifyLeft: '左对齐',\r\n        justifyCenter: '居中对齐',\r\n        justifyRight: '右对齐',\r\n        justifyFull: '两端对齐',\r\n        insertUnorderedList: '无序列表',\r\n        insertOrderedList: '有序列表',\r\n        outdent: '减少缩进',\r\n        indent: '增加缩进',\r\n        formatPara: '设置选中内容样式为 普通',\r\n        formatH1: '设置选中内容样式为 标题1',\r\n        formatH2: '设置选中内容样式为 标题2',\r\n        formatH3: '设置选中内容样式为 标题3',\r\n        formatH4: '设置选中内容样式为 标题4',\r\n        formatH5: '设置选中内容样式为 标题5',\r\n        formatH6: '设置选中内容样式为 标题6',\r\n        insertHorizontalRule: '插入水平线',\r\n        'linkDialog.show': '显示链接对话框'\r\n      }\r\n    }\r\n  });\r\n})(jQuery);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/summernote/lang/summernote-zh-CN.js\n// module id = /QYM\n// module chunks = 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/_css-loader@0.28.7@css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3bb4743c\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./cropper.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/_vue-style-loader@3.0.3@vue-style-loader/lib/addStylesClient.js\")(\"fe083462\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/_vue-style-loader@3.0.3@vue-style-loader!./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-3bb4743c\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/cropper.vue\n// module id = /SmK\n// module chunks = 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-5daee910\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=styles&index=0!./vue-cropper.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=script&index=0!./vue-cropper.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-5daee910\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=template&index=0!./vue-cropper.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-5daee910\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Course/vue-cropper.vue\n// module id = 1JdY\n// module chunks = 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/_css-loader@0.28.7@css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-5daee910\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./vue-cropper.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/_vue-style-loader@3.0.3@vue-style-loader/lib/addStylesClient.js\")(\"075b8c6e\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/_vue-style-loader@3.0.3@vue-style-loader!./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-5daee910\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/vue-cropper.vue\n// module id = A5hA\n// module chunks = 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:\"cropper\",staticClass:\"vue-cropper\"},[_c('div',{staticClass:\"cropper-box\"},[_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.loading),expression:\"!loading\"}],staticClass:\"cropper-box-canvas\",style:({\n\t\t\t\t\t'width': _vm.trueWidth + 'px',\n\t\t\t\t\t'height': _vm.trueHeight + 'px',\n\t\t\t\t\t'transform': 'scale(' + _vm.scale + ',' + _vm.scale + ') ' + 'translate3d('+ _vm.x / _vm.scale + 'px,' + _vm.y / _vm.scale + 'px,' + '0)'\n\t\t\t\t\t+ 'rotateZ('+ _vm.rotate * 90 +'deg)'\n\t\t\t\t\t})},[_c('img',{ref:\"cropperImg\",attrs:{\"src\":_vm.imgs,\"alt\":\"cropper-img\"}})])]),_vm._v(\" \"),_c('div',{staticClass:\"cropper-drag-box\",class:{'cropper-move': _vm.move && !_vm.crop, 'cropper-crop': _vm.crop, 'cropper-modal': _vm.cropping},on:{\"mousedown\":_vm.startMove,\"touchstart\":_vm.startMove,\"mouseover\":_vm.scaleImg,\"mouseout\":_vm.cancleScale}}),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.cropping),expression:\"cropping\"}],staticClass:\"cropper-crop-box\",style:({\n\t\t\t\t\t'width': _vm.cropW + 'px',\n\t\t\t\t\t'height': _vm.cropH + 'px',\n\t\t\t\t\t'transform': 'translate3d('+ _vm.cropOffsertX + 'px,' + _vm.cropOffsertY + 'px,' + '0)'\n\t\t\t\t})},[_c('span',{staticClass:\"cropper-view-box\"},[_c('img',{style:({\n\t\t\t\t\t\t'width': _vm.trueWidth + 'px',\n\t\t\t\t\t\t'height': _vm.trueHeight + 'px',\n\t\t\t\t\t\t'transform': 'scale(' + _vm.scale + ',' + _vm.scale + ') ' + 'translate3d('+ (_vm.x - _vm.cropOffsertX) / _vm.scale  + 'px,' + (_vm.y - _vm.cropOffsertY) / _vm.scale + 'px,' + '0)'\n\t\t\t\t\t\t+ 'rotateZ('+ _vm.rotate * 90 +'deg)'\n\t\t\t\t\t\t}),attrs:{\"src\":_vm.imgs,\"alt\":\"cropper-img\"}})]),_vm._v(\" \"),_c('span',{staticClass:\"cropper-face cropper-move\",on:{\"mousedown\":_vm.cropMove,\"touchstart\":_vm.cropMove}}),_vm._v(\" \"),(_vm.info)?_c('span',{staticClass:\"crop-info\",style:({'top': _vm.cropInfo})},[_vm._v(_vm._s(this.cropW)+\" × \"+_vm._s(this.cropH))]):_vm._e(),_vm._v(\" \"),(!_vm.fixedBox)?_c('span',[_c('span',{staticClass:\"crop-line line-w\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-a\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 1, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 1, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-s\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-line line-d\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 2, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 2, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point1\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 1, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 1, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point2\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point3\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 2, 1)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 2, 1)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point4\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 1, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 1, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point5\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, false, 2, 0)},\"touchstart\":function($event){_vm.changeCropSize($event, true, false, 2, 0)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point6\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 1, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 1, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point7\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, false, true, 0, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, false, true, 0, 2)}}}),_vm._v(\" \"),_c('span',{staticClass:\"crop-point point8\",on:{\"mousedown\":function($event){_vm.changeCropSize($event, true, true, 2, 2)},\"touchstart\":function($event){_vm.changeCropSize($event, true, true, 2, 2)}}})]):_vm._e()])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler?{\"id\":\"data-v-5daee910\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=template&index=0!./src/components/Course/vue-cropper.vue\n// module id = DvhC\n// module chunks = 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticStyle:{\"margin-left\":\"1%\"},attrs:{\"id\":\"CourseInfo\"}},[_c('div',{staticClass:\"col-md-12 \"},[_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"12\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程信息\")])],1),_c('p'),_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程名称：  \"+_vm._s(_vm.course))])],1),_vm._v(\" \"),_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"授课教师：  \"+_vm._s(_vm.teacher))])],1),_vm._v(\" \"),_c('div',[_c('p',{staticClass:\"text-left\",staticStyle:{\"float\":\"left\",\"text-align\":\"center\"}},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程图片： \")])],1),_vm._v(\" \"),_c('form',{attrs:{\"id\":\"uploadForm\",\"enctype\":\"multipart/form-data\"}},[_c('p',{staticClass:\"text-left\"},[_c('img',{staticStyle:{\"float\":\"left\",\"text-align\":\"center\"},attrs:{\"src\":_vm.coverImgUrl,\"id\":\"show\"}}),_c('br'),_vm._v(\" \"),_c('button',{staticClass:\"btn input-file\",attrs:{\"id\":\"cropper-vue\",\"type\":\"button\",\"data-toggle\":\"modal\",\"data-target\":\"#myModal\"}},[_vm._v(\"∧选择课程方面\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"modal fade\",attrs:{\"id\":\"myModal\",\"tabindex\":\"-1\",\"role\":\"dialog\",\"aria-labelledby\":\"myModalLabel\",\"aria-hidden\":\"true\"}},[_c('div',{staticClass:\"modal-dialog\",staticStyle:{\"width\":\"85%\"}},[_c('div',{staticClass:\"modal-content\",staticStyle:{\"height\":\"650px\"}},[_c('cropper',{staticStyle:{\"margin\":\"1% auto auto auto\"},on:{\"transfer\":_vm.transfer,\"isModelShow\":_vm.isModelShow}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-default btn-close\",staticStyle:{\"display\":\"none\"},attrs:{\"id\":\"model-close\",\"type\":\"button\",\"data-dismiss\":\"modal\"}},[_vm._v(\"关闭\")])],1)])]),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"10%\",\"height\":\"200px\"}},[_c('p',{staticClass:\"text-left\"},[_c('font',{attrs:{\"size\":\"4\",\"color\":\"#000000\",\"face\":\"微软雅黑\"}},[_vm._v(\"课程简介：\")])],1),_vm._v(\" \"),_c('div',{staticClass:\"summernote\",attrs:{\"id\":\"summernote\"}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"45%\"},attrs:{\"id\":\"save\"},on:{\"click\":_vm.save}},[_vm._v(\"保存\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-info\",attrs:{\"id\":\"edit\"},on:{\"click\":_vm.edit}},[_vm._v(\"编辑\")])])])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler?{\"id\":\"data-v-9e4d1e1c\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=template&index=0!./src/components/Course/CourseInfo.vue\n// module id = Ln7P\n// module chunks = 5","<template>\r\n\r\n  <div id=\"CourseInfo\" style=\"margin-left:1%\">\r\n\r\n      <div class=\"col-md-12 \">\r\n            <p class=\"text-left\"><font size=\"12\" color=\"#000000\" face=\"微软雅黑\">课程信息</font><p>\r\n            <p class=\"text-left\"><font size=\"4\" color=\"#000000\" face=\"微软雅黑\">课程名称：  {{ course }}</font></p>\r\n            <p class=\"text-left\"><font size=\"4\" color=\"#000000\" face=\"微软雅黑\">授课教师：  {{ teacher }}</font></p>\r\n\r\n            <div>\r\n              <p class=\"text-left\" style=\"float:left;text-align:center;\" ><font size=\"4\" color=\"#000000\" face=\"微软雅黑\">课程图片： </font></p>\r\n                <form id=\"uploadForm\" enctype=\"multipart/form-data\">\r\n                  <p class=\"text-left\">\r\n                  <img v-bind:src=\"coverImgUrl\" id='show'  style=\"float:left;text-align:center;\"><br>\r\n                  <button id=\"cropper-vue\" type=\"button\" class=\"btn input-file\" data-toggle=\"modal\" data-target=\"#myModal\">∧选择课程方面</button></p>\r\n                </form>\r\n                \r\n            </div>\r\n\r\n            <div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n                <div class=\"modal-dialog\" style=\"width:85%\">\r\n                    <div class=\"modal-content\" style=\"height:650px\">\r\n                        <cropper @transfer=\"transfer\" @isModelShow=\"isModelShow\" style=\"margin: 1% auto auto auto\"></cropper>\r\n                        <button id=\"model-close\" type=\"button\" class=\"btn btn-default btn-close\" data-dismiss=\"modal\" style=\"display:none\">关闭</button>\r\n\r\n                    </div><!-- /.modal-content -->\r\n                </div><!-- /.modal -->\r\n            </div>\r\n            <div style=\"margin-top:10%;height:200px\">\r\n              <p class=\"text-left\"><font size=\"4\" color=\"#000000\" face=\"微软雅黑\">课程简介：</font></p>\r\n              <div id=\"summernote\"  class=\"summernote\">\r\n\r\n              </div>\r\n              <button id=\"save\" class=\"btn btn-success\" style='margin-left:45%' @click=\"save\">保存</button>\r\n              <button id=\"edit\" class=\"btn btn-info\" @click=\"edit\">编辑</button>\r\n            </div>\r\n\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n\r\n<script>\r\n\r\n  // import CustomModel from './model'\r\n\r\n  //summernote富文本\r\n  import 'summernote/dist/summernote.css'\r\n  import 'summernote/dist/summernote.js'\r\n  import '../../../static/summernote/lang/summernote-zh-CN.js'\r\n  import 'jquery'\r\n  import cropper from './cropper'\r\n\r\n  export default {\r\n    name: 'classname',\r\n    components:{\r\n      //  'CustomModel': CustomModel,\r\n      cropper\r\n    },\r\n    data () {\r\n      return {\r\n        name: 'classname',\r\n        course: '',\r\n        teacher: '老师',\r\n        coverImgUrl:'',\r\n        uploadcoverImgUrl:'',\r\n        markupStr: '',\r\n        courseId:0,\r\n        modelSrc:'',\r\n        isShow: false,\r\n        urlUs: '',\r\n      }\r\n    },\r\n    watch:{\r\n\r\n    },\r\n  methods:{\r\n    null(){\r\n      $('#summernote').summernote('destroy');\r\n    },\r\n    isModelShow (...data) {\r\n      this.isShow = data[0]\r\n      if(!data[0]){\r\n        $('#model-close').click()\r\n        this.updateCourseInfo();\r\n      }\r\n      console.log(data[0])\r\n    },\r\n    transfer (...data) {\r\n      this.coverImgUrl = data[0]\r\n    },\r\n    updateCourseInfo(){\r\n      axios({\r\n        method: 'post',\r\n        url: '/api/updateCourseInfo',\r\n        data: {\r\n          courseId: this.courseId,\r\n          description: this.markupStr,\r\n          coverImgUrl:this.coverImgUrl\r\n        },\r\n        }).then((response) => {\r\n           coverBus.$emit('coverImgUrlChange',this.coverImgUrl);\r\n        }).catch(function(error) {\r\n          alert(error);\r\n        });\r\n     \r\n\r\n    },\r\n    getCourseInfo(){\r\n      axios({\r\n        method: 'post',\r\n        url: '/api/getInitCourseInfo',\r\n        data: {\r\n          courseId: this.courseId,\r\n        },\r\n        }).then((response) => {\r\n          this.course = response.data.result.name\r\n          this.teacher = response.data.result.teacher.nickname\r\n          this.coverImgUrl = response.data.result.coverImgUrl\r\n          this.markupStr = response.data.result.description\r\n          $('#summernote').summernote('code', this.markupStr);\r\n          console.log(response.data.result.description)\r\n          console.log(response.data.result)\r\n          this.null()\r\n          \r\n        }).catch(function(error) {\r\n            bus.$emit(\"dialog\", {\r\n            type: \"error\",//success default error warn\r\n            body: \" 课程信息获取失败！\",\r\n            auto: false,//是否自动隐藏\r\n            time: 5000//毫秒\r\n          })\r\n        });\r\n    },\r\n    save(){\r\n      this.markupStr = $('#summernote').summernote('code');\r\n      $('#summernote').summernote('destroy')\r\n      this.updateCourseInfo()\r\n      console.log(this.markupStr)\r\n      coverBus.$emit('coverImageUrlChange',this.coverImgUrl);\r\n      bus.$emit(\"dialog\", {\r\n        type: \"success\",//success default error warn\r\n        body: \" 课程信息已保存！\",\r\n        auto: true,//是否自动隐藏\r\n        time: 5000//毫秒\r\n      })\r\n    },\r\n    edit(){\r\n      $('#summernote').summernote({focus:true})\r\n\r\n\r\n    },\r\n   \r\n    upload(){\r\n      var formData = new FormData();\r\n      formData.append('file', $('#file')[0].files[0]);\r\n      let config = {\r\n        headers: {'Content-Type': 'multipart/form-data'}\r\n      }\r\n      axios.post(\"/api/courseInfo/upload\",formData,config).then(response => {\r\n        this.coverImgUrl = response.data.result\r\n        console.log(this.coverImgUrl)\r\n      }).catch(function (error) {\r\n    　　alert(error);\r\n      });\r\n\r\n      alert(\"操作成功！\");\r\n    },\r\n\r\n    C(){\r\n      var  r= new FileReader();\r\n      var f=document.getElementById('file').files[0];\r\n      r.readAsDataURL(f);\r\n      r.onload=function  (e) {\r\n      document.getElementById('show').src=this.result;\r\n      };\r\n    },\r\n  },\r\n  beforeCreate(){},\r\n  created(){\r\n    \r\n    var a = window.sessionStorage.getItem(\"courseId\");\r\n    console.log(a);\r\n    if(a != undefined){\r\n      this.courseId = 0;\r\n      this.courseId = a;\r\n    }else{\r\n      this.$router.push({ name: 'Index'})\r\n    }\r\n  },\r\n  beforeMount(){},\r\n  mounted(){\r\n   \r\n    this.getCourseInfo();\r\n   \r\n    $(document).ready(function () {\r\n       \r\n        $('#summernote').summernote({\r\n            height: 250,\r\n            tabsize: 2,\r\n            lang: 'zh-CN',\r\n            htmlMode: true,\r\n            disableDragAndDrop: false,\r\n            focus: true, \r\n            toolbar: [\r\n                // [groupName, [list of button]]\r\n                ['style', ['bold', 'italic', 'underline', 'clear']],\r\n                ['font', ['strikethrough', 'superscript', 'subscript']],\r\n                ['fontsize', ['fontsize']],\r\n                ['color', ['color']],\r\n                ['para', ['ul', 'ol', 'paragraph']],\r\n                ['height', ['height']],\r\n                ['insert', ['picture']]\r\n              ],\r\n            callbacks: {\r\n              onImageUpload: function(files) {\r\n                console.log(\"1111\")\r\n                sendFile(files[0])\r\n                }\r\n            }\r\n        });\r\n         \r\n    });\r\n    \r\n   function sendFile(file) {\r\n    console.log(\"222\")\r\n    var data = new FormData();\r\n    data.append(\"file\", file);\r\n    let config = {\r\n      headers: {'Content-Type': 'multipart/form-data'}\r\n    }\r\n    axios.post(\"/api/courseInfo/upload\",data,config).then(response => {\r\n      $(\"#summernote\").summernote('insertImage',response.data.result, 'image name'); // the insertImage API\r\n    }).catch(function (error) {\r\n　　 alert(error);\r\n    });\r\n\r\n}\r\n\r\n  },\r\n    beforeUpdate(){},\r\n    updated(){},\r\n    beforeDestroy(){},\r\n    destroyed(){}\r\n  }\r\n</script>\r\n\r\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\r\n<style scoped>\r\n\r\n  img{\r\n    height: 150px;\r\n    width: 180px;\r\n    margin: 1% 1% 0% 1%;\r\n  }\r\n  .m{ width: 800px; margin-left: auto; margin-right: auto; }\r\n  .input-file{\r\n    display: inline-block;\r\n    position: relative;\r\n    overflow: hidden;\r\n    text-align: center;\r\n    width: auto;\r\n    background-color: #2c7;\r\n    border: solid 1px #ddd;\r\n    border-radius: 4px;\r\n    padding: 5px 10px;\r\n    font-size: 12px;\r\n    font-weight: normal;\r\n    line-height: 18px;\r\n    color:#fff;\r\n    text-decoration: none;\r\n  }\r\n  .input-file input[type=\"file\"] {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    font-size: 14px;\r\n    background-color: #fff;\r\n    transform: translate(-300px, 0px) scale(4);\r\n    height: 40px;\r\n    opacity: 0;\r\n    filter: alpha(opacity=0);\r\n  }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/components/Course/CourseInfo.vue","module.exports = __webpack_public_path__ + \"vue/fonts/summernote.372a283.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.eot\n// module id = MbIj\n// module chunks = 5","module.exports = __webpack_public_path__ + \"vue/fonts/summernote.372a283.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.eot?0d0d5fac99cc8774d89eb08b1a8323c4\n// module id = OYI4\n// module chunks = 5","exports = module.exports = require(\"../../../node_modules/_css-loader@0.28.7@css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".content[data-v-3bb4743c]{margin:auto;max-width:80%;margin-bottom:100px}.des[data-v-3bb4743c]{line-height:30px}code.language-html[data-v-3bb4743c]{padding:10px 20px;margin:10px 0;display:block;background-color:#333;color:#fff;overflow-x:auto;font-family:Consolas,Monaco,Droid,Sans,Mono,Source,Code,Pro,Menlo,Lucida,Type,Writer,Ubuntu;border-radius:5px;white-space:pre}.show-info[data-v-3bb4743c]{margin-bottom:50px}.show-info h2[data-v-3bb4743c]{line-height:50px}.title[data-v-3bb4743c]{display:block;text-decoration:none;text-align:center;line-height:1.5;margin:20px 0;background-image:-webkit-linear-gradient(left,#3498db,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db);color:transparent;-webkit-background-clip:text;background-size:200% 100%;-webkit-animation:slide-data-v-3bb4743c 5s infinite linear;animation:slide-data-v-3bb4743c 5s infinite linear;font-size:40px}.test[data-v-3bb4743c]{height:500px}.model[data-v-3bb4743c]{position:fixed;z-index:10;width:100%;height:100%;overflow:auto;top:0;left:0;background:rgba(0,0,0,.8)}.model-show[data-v-3bb4743c]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:100%}.model img[data-v-3bb4743c]{background-position:0 0,10px 10px;background-size:20px 20px;background-image:linear-gradient(45deg,#eee 25%,transparent 0,transparent 75%,#eee 0,#eee),linear-gradient(45deg,#eee 25%,#fff 0,#fff 75%,#eee 0,#eee)}.c-item[data-v-3bb4743c],.model img[data-v-3bb4743c]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.c-item[data-v-3bb4743c]{display:block;padding:10px 0}@-webkit-keyframes slide-data-v-3bb4743c{0%{background-position:0 0}to{background-position:-100% 0}}@keyframes slide-data-v-3bb4743c{0%{background-position:0 0}to{background-position:-100% 0}}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/cropper.vue\"],\"names\":[],\"mappings\":\"AACA,0BACE,YAAa,AACb,cAAe,AACf,mBAAqB,CACtB,AACD,sBACE,gBAAkB,CACnB,AACD,oCACE,kBAAmB,AACnB,cAAiB,AACjB,cAAe,AACf,sBAAuB,AACvB,WAAY,AACZ,gBAAiB,AACjB,4FAAqH,AACrH,kBAAmB,AACnB,eAAiB,CAClB,AACD,4BACE,kBAAoB,CACrB,AACD,+BACE,gBAAkB,CACnB,AAKD,wBACE,cAAe,AACf,qBAAsB,AACtB,kBAAmB,AACnB,gBAAiB,AACjB,cAAiB,AACjB,2KAA4K,AAC5K,kBAAmB,AACnB,6BAA8B,AAC9B,0BAA2B,AAC3B,2DAA4D,AACpD,mDAAoD,AAC5D,cAAgB,CACjB,AACD,uBACG,YAAc,CAChB,AACD,wBACE,eAAgB,AAChB,WAAY,AACZ,WAAY,AACZ,YAAa,AACb,cAAe,AACf,MAAO,AACP,OAAQ,AACR,yBAA+B,CAChC,AACD,6BACE,oBAAqB,AACrB,oBAAqB,AACrB,aAAc,AACZ,wBAAyB,AACrB,qBAAsB,AAClB,uBAAwB,AAChC,yBAA0B,AACtB,sBAAuB,AACnB,mBAAoB,AAC9B,WAAY,AACZ,WAAa,CACd,AACD,4BAKE,kCAAwC,AACxC,0BAA2B,AACzB,sJAAsL,CACzL,AACD,qDARE,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAY3B,AAPD,yBACE,cAAe,AACf,cAAgB,CAKjB,AACD,yCACA,GACM,uBAAyB,CAC9B,AACD,GACM,2BAA6B,CAClC,CACA,AACD,iCACA,GACM,uBAAyB,CAC9B,AACD,GACM,2BAA6B,CAClC,CACA\",\"file\":\"cropper.vue\",\"sourcesContent\":[\"\\n.content[data-v-3bb4743c] {\\n\\t\\tmargin: auto;\\n\\t\\tmax-width: 80%;\\n\\t\\tmargin-bottom: 100px;\\n}\\n.des[data-v-3bb4743c] {\\n\\t\\tline-height: 30px;\\n}\\ncode.language-html[data-v-3bb4743c] {\\n\\t\\tpadding: 10px 20px;\\n\\t\\tmargin: 10px 0px;\\n\\t\\tdisplay: block;\\n\\t\\tbackground-color: #333;\\n\\t\\tcolor: #fff;\\n\\t\\toverflow-x: auto;\\n\\t\\tfont-family: Consolas, Monaco, Droid, Sans, Mono, Source, Code, Pro, Menlo, Lucida, Sans, Type, Writer, Ubuntu, Mono;\\n\\t\\tborder-radius: 5px;\\n\\t\\twhite-space: pre;\\n}\\n.show-info[data-v-3bb4743c] {\\n\\t\\tmargin-bottom: 50px;\\n}\\n.show-info h2[data-v-3bb4743c] {\\n\\t\\tline-height: 50px;\\n}\\n\\n\\t/*.title, .title:hover, .title-focus, .title:visited {\\n\\t\\tcolor: black;\\n\\t}*/\\n.title[data-v-3bb4743c] {\\n\\t\\tdisplay: block;\\n\\t\\ttext-decoration: none;\\n\\t\\ttext-align: center;\\n\\t\\tline-height: 1.5;\\n\\t\\tmargin: 20px 0px;\\n\\t\\tbackground-image: -webkit-linear-gradient(left,#3498db,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db);\\n\\t\\tcolor: transparent;\\n\\t\\t-webkit-background-clip: text;\\n\\t\\tbackground-size: 200% 100%;\\n\\t\\t-webkit-animation: slide-data-v-3bb4743c 5s infinite linear;\\n\\t\\t        animation: slide-data-v-3bb4743c 5s infinite linear;\\n\\t\\tfont-size: 40px;\\n}\\n.test[data-v-3bb4743c] {\\n\\t  height: 500px;\\n}\\n.model[data-v-3bb4743c] {\\n\\t\\tposition: fixed;\\n\\t\\tz-index: 10;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\toverflow: auto;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\tbackground: rgba(0, 0, 0, 0.8);\\n}\\n.model-show[data-v-3bb4743c] {\\n\\t\\tdisplay: -webkit-box;\\n\\t\\tdisplay: -ms-flexbox;\\n\\t\\tdisplay: flex;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n    -webkit-box-align: center;\\n        -ms-flex-align: center;\\n            align-items: center;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n}\\n.model img[data-v-3bb4743c] {\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n\\t\\tbackground-position: 0px 0px, 10px 10px;\\n\\t\\tbackground-size: 20px 20px;\\n    background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100%),linear-gradient(45deg, #eee 25%, white 25%, white 75%, #eee 75%, #eee 100%);\\n}\\n.c-item[data-v-3bb4743c] {\\n\\t\\tdisplay: block;\\n\\t\\tpadding: 10px 0;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n@-webkit-keyframes slide-data-v-3bb4743c {\\n0%  {\\n      background-position: 0 0;\\n}\\n100% {\\n      background-position: -100% 0;\\n}\\n}\\n@keyframes slide-data-v-3bb4743c {\\n0%  {\\n      background-position: 0 0;\\n}\\n100% {\\n      background-position: -100% 0;\\n}\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-3bb4743c\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/cropper.vue\n// module id = Qnm5\n// module chunks = 5","module.exports = __webpack_public_path__ + \"vue/fonts/summernote.ce9ce49.ttf\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.ttf?0d0d5fac99cc8774d89eb08b1a8323c4\n// module id = RUcL\n// module chunks = 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-9e4d1e1c\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=styles&index=0!./CourseInfo.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=script&index=0!./CourseInfo.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-9e4d1e1c\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=template&index=0!./CourseInfo.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-9e4d1e1c\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Course/CourseInfo.vue\n// module id = Upgw\n// module chunks = 5","/**\n * Super simple wysiwyg editor v0.8.8\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013- Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2017-09-09T11:03Z\n */\n(function (factory) {\n  /* global define */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  var isSupportAmd = typeof define === 'function' && define.amd;\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    // Webpack\n    if (typeof __webpack_require__ === 'function') { // jshint ignore:line\n      try {\n        // If CodeMirror can't be resolved, `require.resolve` will throw an\n        // exception and `hasCodeMirror` won't be set to `true`.\n        require.resolve('codemirror');\n        hasCodeMirror = true;\n      } catch (e) {\n        // do nothing\n      }\n    } else if (typeof require !== 'undefined') {\n      // Browserify\n      if (typeof require.resolve !== 'undefined') {\n        try {\n          // If CodeMirror can't be resolved, `require.resolve` will throw an\n          // exception and `hasCodeMirror` won't be set to `true`.\n          require.resolve('codemirror');\n          hasCodeMirror = true;\n        } catch (e) {\n          // do nothing\n        }\n      // Almond/Require\n      } else if (typeof require.specified !== 'undefined') {\n        hasCodeMirror = require.specified('codemirror');\n      }\n    }\n  }\n\n  var isSupportTouch =\n    (('ontouchstart' in window) ||\n     (navigator.MaxTouchPoints > 0) ||\n     (navigator.msMaxTouchPoints > 0));\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    isSupportTouch: isSupportTouch,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     * @param {Function} func\n     * @param {Number} wait\n     * @param {Boolean} immediate\n     * @return {Function}\n     */\n    var debounce = function (func, wait, immediate) {\n      var timeout;\n      return function () {\n        var context = this, args = arguments;\n        var later = function () {\n          timeout = null;\n          if (!immediate) {\n            func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n          func.apply(context, args);\n        }\n      };\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel,\n      debounce: debounce\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all false values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isData = makePredByNodeName('DATA');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node) &&\n             !isData(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n      \n      if (node) {\n        return node.childNodes.length;\n      }\n      \n      return 0;\n      \n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      if (!ancestor) {\n        return false;\n      }\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    /**\n     * @method isCustomStyleTag\n     *\n     * assert if a node contains a \"note-styletag\" class,\n     * which implies that's a custom-made style tag node\n     *\n     * @param {Node} an HTML DOM node\n     */\n    var isCustomStyleTag = function (node) {\n      return node && !dom.isText(node) && list.contains(node.classList, 'note-styletag');\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isData: isData,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents,\n      isCustomStyleTag: isCustomStyleTag\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n      // trigger custom onDestroy callback\n      this.triggerEvent('destroy', this);\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n      this.triggerEvent('disable', false);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n\n      this.triggerEvent('disable', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    /**\n     *Some buttons need to change their visual style immediately once they get pressed\n     */\n    this.createInvokeHandlerAndUpdateState = function (namespace, value) {\n      return function (event) {\n        self.createInvokeHandler(namespace, value)(event);\n        self.invoke('buttons.updateCurrentStyle');\n      };\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        var $target = $(event.target);\n        self.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n\n      // Update options\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n      options.tooltip = options.tooltip === 'auto' ? !agent.isSupportTouch : options.tooltip;\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      var option = (typeof item === 'object') ? item.option : undefined;\n\n      var dataValue = 'data-value=\"' + value + '\"';\n      var dataOption = (option !== undefined) ? ' data-option=\"' + option + '\"' : '';\n      return '<li><a href=\"#\" ' + (dataValue + dataOption) + '>' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownButtonContents = function (contents, options) {\n    return contents + ' ' + icon(options.icons.caret, 'span');\n  };\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    if (options.tooltip) {\n      $node.find('.note-color-btn').tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var checkbox = renderer.create('<div class=\"checkbox\"></div>', function ($node, options) {\n      $node.html([\n          ' <label' + (options.id ? ' for=\"' + options.id + '\"' : '') + '>',\n          ' <input type=\"checkbox\"' + (options.id ? ' id=\"' + options.id + '\"' : ''),\n          (options.checked ? ' checked' : '') + '/>',\n          (options.text ? options.text : ''),\n          '</label>'\n      ].join(''));\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    dropdown: dropdown,\n    dropdownButtonContents: dropdownButtonContents,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    checkbox: checkbox,\n    icon: icon,\n    options: {},\n\n    button: function ($node, options) {\n      return renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n        if (options && options.tooltip && self.options.tooltip) {\n          $node.attr({\n            title: options.tooltip\n          }).tooltip({\n            container: 'body',\n            trigger: 'hover',\n            placement: 'bottom'\n          });\n        }\n      })($node, options);\n    },\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      self.options = options;\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table',\n        addRowAbove: 'Add row above',\n        addRowBelow: 'Add row below',\n        addColLeft: 'Add column left',\n        addColRight: 'Add column right',\n        delRow: 'Delete row',\n        delCol: 'Delete column',\n        delTable: 'Delete table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        p: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n      'DELETE': 46,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE,\n          keyMap.DELETE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnCell: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n      // isOnData: judge whether range is on data node or not\n      this.isOnData = makeIsOn(dom.isData);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',\n          'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading, pre or custom-made styleTag with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n\n  /**\n   * @class Create a virtual table to create what actions to do in change.\n   * @param {object} startPoint Cell selected to apply change.\n   * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where\n   * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction\n   * @param {object} domTable Dom element of table to make changes.\n   */\n  var TableResultAction = function (startPoint, where, action, domTable) {\n    var _startPoint = { 'colPos': 0, 'rowPos': 0 };\n    var _virtualTable = [];\n    var _actionCellList = [];\n\n    //////////////////////////////////////////////\n    // Private functions\n    //////////////////////////////////////////////\n\n    /**\n     * Set the startPoint of action.\n     */\n    function setStartPoint() {\n      if (!startPoint || !startPoint.tagName || (startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th')) {\n        console.error('Impossible to identify start Cell point.', startPoint);\n        return;\n      }\n      _startPoint.colPos = startPoint.cellIndex;\n      if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {\n        console.error('Impossible to identify start Row point.', startPoint);\n        return;\n      }\n      _startPoint.rowPos = startPoint.parentElement.rowIndex;\n    }\n\n    /**\n     * Define virtual table position info object.\n     * \n     * @param {int} rowIndex Index position in line of virtual table.\n     * @param {int} cellIndex Index position in column of virtual table.\n     * @param {object} baseRow Row affected by this position.\n     * @param {object} baseCell Cell affected by this position.\n     * @param {bool} isSpan Inform if it is an span cell/row.\n     */\n    function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {\n      var objPosition = {\n        'baseRow': baseRow,\n        'baseCell': baseCell,\n        'isRowSpan': isRowSpan,\n        'isColSpan': isColSpan,\n        'isVirtual': isVirtualCell\n      };\n      if (!_virtualTable[rowIndex]) {\n        _virtualTable[rowIndex] = [];\n      }\n      _virtualTable[rowIndex][cellIndex] = objPosition;\n    }\n\n    /**\n     * Create action cell object.\n     * \n     * @param {object} virtualTableCellObj Object of specific position on virtual table.\n     * @param {enum} resultAction Action to be applied in that item.\n     */\n    function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {\n      return {\n        'baseCell': virtualTableCellObj.baseCell,\n        'action': resultAction,\n        'virtualTable': {\n          'rowIndex': virtualRowPosition,\n          'cellIndex': virtualColPosition\n        }\n      };\n    }\n\n    /**\n     * Recover free index of row to append Cell.\n     * \n     * @param {int} rowIndex Index of row to find free space.\n     * @param {int} cellIndex Index of cell to find free space in table.\n     */\n    function recoverCellIndex(rowIndex, cellIndex) {\n      if (!_virtualTable[rowIndex]) {\n        return cellIndex;\n      }\n      if (!_virtualTable[rowIndex][cellIndex]) {\n        return cellIndex;\n      }\n\n      var newCellIndex = cellIndex;\n      while (_virtualTable[rowIndex][newCellIndex]) {\n        newCellIndex++;\n        if (!_virtualTable[rowIndex][newCellIndex]) {\n          return newCellIndex;\n        }\n      }\n    }\n\n    /**\n     * Recover info about row and cell and add information to virtual table.\n     * \n     * @param {object} row Row to recover information.\n     * @param {object} cell Cell to recover information.\n     */\n    function addCellInfoToVirtual(row, cell) {\n      var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);\n      var cellHasColspan = (cell.colSpan > 1);\n      var cellHasRowspan = (cell.rowSpan > 1);\n      var isThisSelectedCell = (row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos);\n      setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);\n\n      // Add span rows to virtual Table.\n      var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;\n      if (rowspanNumber > 1) {\n        for (var rp = 1; rp < rowspanNumber; rp++) {\n          var rowspanIndex = row.rowIndex + rp;\n          adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);\n          setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);\n        }\n      }\n\n      // Add span cols to virtual table.\n      var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;\n      if (colspanNumber > 1) {\n        for (var cp = 1; cp < colspanNumber; cp++) {\n          var cellspanIndex = recoverCellIndex(row.rowIndex, (cellIndex + cp));\n          adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);\n          setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);\n        }\n      }\n    }\n\n    /**\n     * Process validation and adjust of start point if needed\n     * \n     * @param {int} rowIndex \n     * @param {int} cellIndex \n     * @param {object} cell \n     * @param {bool} isSelectedCell \n     */\n    function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {\n      if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {\n        _startPoint.colPos++;\n      }\n    }\n\n    /**\n     * Create virtual table of cells with all cells, including span cells.\n     */\n    function createVirtualTable() {\n      var rows = domTable.rows;\n      for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n        var cells = rows[rowIndex].cells;\n        for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n          addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);\n        }\n      }\n    }\n\n    /**\n     * Get action to be applied on the cell.\n     * \n     * @param {object} cell virtual table cell to apply action\n     */\n    function getDeleteResultActionToCell(cell) {\n      switch (where) {\n        case TableResultAction.where.Column:\n          if (cell.isColSpan) {\n            return TableResultAction.resultAction.SubtractSpanCount;\n          }\n          break;\n        case TableResultAction.where.Row:\n          if (!cell.isVirtual && cell.isRowSpan) {\n            return TableResultAction.resultAction.AddCell;\n          }\n          else if (cell.isRowSpan) {\n            return TableResultAction.resultAction.SubtractSpanCount;\n          }\n          break;\n      }\n      return TableResultAction.resultAction.RemoveCell;\n    }\n\n    /**\n     * Get action to be applied on the cell.\n     * \n     * @param {object} cell virtual table cell to apply action\n     */\n    function getAddResultActionToCell(cell) {\n      switch (where) {\n        case TableResultAction.where.Column:\n          if (cell.isColSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n          } else if (cell.isRowSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n          }\n          break;\n        case TableResultAction.where.Row:\n          if (cell.isRowSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n          } else if (cell.isColSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n          }\n          break;\n      }\n      return TableResultAction.resultAction.AddCell;\n    }\n\n    function init() {\n      setStartPoint();\n      createVirtualTable();\n    }\n\n    //////////////////////////////////////////////\n    // Public functions\n    //////////////////////////////////////////////\n\n    /**\n     * Recover array os what to do in table.\n     */\n    this.getActionList = function () {\n      var fixedRow = (where === TableResultAction.where.Row) ? _startPoint.rowPos : -1;\n      var fixedCol = (where === TableResultAction.where.Column) ? _startPoint.colPos : -1;\n\n      var actualPosition = 0;\n      var canContinue = true;\n      while (canContinue) {\n        var rowPosition = (fixedRow >= 0) ? fixedRow : actualPosition;\n        var colPosition = (fixedCol >= 0) ? fixedCol : actualPosition;\n        var row = _virtualTable[rowPosition];\n        if (!row) {\n          canContinue = false;\n          return _actionCellList;\n        }\n        var cell = row[colPosition];\n        if (!cell) {\n          canContinue = false;\n          return _actionCellList;\n        }\n\n        // Define action to be applied in this cell\n        var resultAction = TableResultAction.resultAction.Ignore;\n        switch (action) {\n          case TableResultAction.requestAction.Add:\n            resultAction = getAddResultActionToCell(cell);\n            break;\n          case TableResultAction.requestAction.Delete:\n            resultAction = getDeleteResultActionToCell(cell);\n            break;\n        }\n        _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));\n        actualPosition++;\n      }\n\n      return _actionCellList;\n    };\n\n    init();\n  };\n  /**\n  * \n  * Where action occours enum.\n  */\n  TableResultAction.where = { 'Row': 0, 'Column': 1 };\n  /**\n  * \n  * Requested action to apply enum.\n  */\n  TableResultAction.requestAction = { 'Add': 0, 'Delete': 1 };\n  /**\n  * \n  * Result action to be executed enum.\n  */\n  TableResultAction.resultAction = { 'Ignore': 0, 'SubtractSpanCount': 1, 'RemoveCell': 2, 'AddCell': 3, 'SumSpanCount': 4 };\n\n  /**\n   * \n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * Add a new row\n     *\n     * @param {WrappedRange} rng\n     * @param {String} position (top/bottom)\n     * @return {Node}\n     */\n    this.addRow = function (rng, position) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n\n      var currentTr = $(cell).closest('tr');\n      var trAttributes = this.recoverAttributes(currentTr);\n      var html = $('<tr' + trAttributes + '></tr>');\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Row,\n        TableResultAction.requestAction.Add, $(currentTr).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var idCell = 0; idCell < actions.length; idCell++) {\n        var currentCell = actions[idCell];\n        var tdAttributes = this.recoverAttributes(currentCell.baseCell);\n        switch (currentCell.action) {\n          case TableResultAction.resultAction.AddCell:\n            html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            break;\n          case TableResultAction.resultAction.SumSpanCount:\n            if (position === 'top') {\n              var baseCellTr = currentCell.baseCell.parent;\n              var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;\n              if (isTopFromRowSpan) {\n                var newTd = $('<div></div>').append($('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();\n                html.append(newTd);\n                break;\n              }\n            }\n            var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);\n            rowspanNumber++;\n            currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);\n            break;\n        }\n      }\n\n      if (position === 'top') {\n        currentTr.before(html);\n      }\n      else {\n        var cellHasRowspan = (cell.rowSpan > 1);\n        if (cellHasRowspan) {\n          var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);\n          $($(currentTr).parent().find('tr')[lastTrIndex]).after($(html));\n          return;\n        }\n        currentTr.after(html);\n      }\n    };\n\n    /**\n     * Add a new col\n     *\n     * @param {WrappedRange} rng\n     * @param {String} position (left/right)\n     * @return {Node}\n     */\n    this.addCol = function (rng, position) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var rowsGroup = $(row).siblings();\n      rowsGroup.push(row);\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Column,\n        TableResultAction.requestAction.Add, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        var currentCell = actions[actionIndex];\n        var tdAttributes = this.recoverAttributes(currentCell.baseCell);\n        switch (currentCell.action) {\n          case TableResultAction.resultAction.AddCell:\n            if (position === 'right') {\n              $(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            } else {\n              $(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            }\n            break;\n          case TableResultAction.resultAction.SumSpanCount:\n            if (position === 'right') {\n              var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);\n              colspanNumber++;\n              currentCell.baseCell.setAttribute('colSpan', colspanNumber);\n            } else {\n              $(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');\n            }\n            break;\n        }\n      }\n    };\n\n    /*\n    * Copy attributes from element.\n    *\n    * @param {object} Element to recover attributes.\n    * @return {string} Copied string elements.\n    */\n    this.recoverAttributes = function (el) {\n      var resultStr = '';\n\n      if (!el) {\n        return resultStr;\n      }\n\n      var attrList = el.attributes || [];\n\n      for (var i = 0; i < attrList.length; i++) {\n        if (attrList[i].name.toLowerCase() === 'id') {\n          continue;\n        }\n\n        if (attrList[i].specified) {\n          resultStr += ' ' + attrList[i].name + '=\\'' + attrList[i].value + '\\'';\n        }\n      }\n\n      return resultStr;\n    };\n\n    /**\n     * Delete current row\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteRow = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var cellPos = row.children('td, th').index($(cell));\n      var rowPos = row[0].rowIndex;\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Row,\n        TableResultAction.requestAction.Delete, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        if (!actions[actionIndex]) {\n          continue;\n        }\n\n        var baseCell = actions[actionIndex].baseCell;\n        var virtualPosition = actions[actionIndex].virtualTable;\n        var hasRowspan = (baseCell.rowSpan && baseCell.rowSpan > 1);\n        var rowspanNumber = (hasRowspan) ? parseInt(baseCell.rowSpan, 10) : 0;\n        switch (actions[actionIndex].action) {\n          case TableResultAction.resultAction.Ignore:\n            continue;\n          case TableResultAction.resultAction.AddCell:\n            var nextRow = row.next('tr')[0];\n            if (!nextRow) { continue; }\n            var cloneRow = row[0].cells[cellPos];\n            if (hasRowspan) {\n              if (rowspanNumber > 2) {\n                rowspanNumber--;\n                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);\n                nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);\n                nextRow.cells[cellPos].innerHTML = '';\n              } else if (rowspanNumber === 2) {\n                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);\n                nextRow.cells[cellPos].removeAttribute('rowSpan');\n                nextRow.cells[cellPos].innerHTML = '';\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.SubtractSpanCount:\n            if (hasRowspan) {\n              if (rowspanNumber > 2) {\n                rowspanNumber--;\n                baseCell.setAttribute('rowSpan', rowspanNumber);\n                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              } else if (rowspanNumber === 2) {\n                baseCell.removeAttribute('rowSpan');\n                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.RemoveCell:\n            // Do not need remove cell because row will be deleted.\n            continue;\n        }\n      }\n      row.remove();\n    };\n\n    /**\n     * Delete current col\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteCol = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var row = $(cell).closest('tr');\n      var cellPos = row.children('td, th').index($(cell));\n\n      var vTable = new TableResultAction(cell, TableResultAction.where.Column,\n        TableResultAction.requestAction.Delete, $(row).closest('table')[0]);\n      var actions = vTable.getActionList();\n\n      for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {\n        if (!actions[actionIndex]) {\n          continue;\n        }\n        switch (actions[actionIndex].action) {\n          case TableResultAction.resultAction.Ignore:\n            continue;\n          case TableResultAction.resultAction.SubtractSpanCount:\n            var baseCell = actions[actionIndex].baseCell;\n            var hasColspan = (baseCell.colSpan && baseCell.colSpan > 1);\n            if (hasColspan) {\n              var colspanNumber = (baseCell.colSpan) ? parseInt(baseCell.colSpan, 10) : 0;\n              if (colspanNumber > 2) {\n                colspanNumber--;\n                baseCell.setAttribute('colSpan', colspanNumber);\n                if (baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              } else if (colspanNumber === 2) {\n                baseCell.removeAttribute('colSpan');\n                if (baseCell.cellIndex === cellPos) { baseCell.innerHTML = ''; }\n              }\n            }\n            continue;\n          case TableResultAction.resultAction.RemoveCell:\n            dom.remove(actions[actionIndex].baseCell, true);\n            continue;\n        }\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n\n    /**\n     * Delete current table\n     *\n     * @param {WrappedRange} rng\n     * @return {Node}\n     */\n    this.deleteTable = function (rng) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      $(cell).closest('table').remove();\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (!event.isDefaultPrevented()) {\n          if (options.shortcuts) {\n            self.handleKeyMap(event);\n          } else {\n            self.preventDefaultEditableShortCuts(event);\n          }\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, func.debounce(function () {\n        context.triggerEvent('change', $editable.html());\n      }, 100));\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode) {\n        if (options.width) {\n          $editor.outerWidth(options.width);\n        }\n        if (options.height) {\n          $editable.outerHeight(options.height);\n        }\n        if (options.maxHeight) {\n          $editable.css('max-height', options.maxHeight);\n        }\n        if (options.minHeight) {\n          $editable.css('min-height', options.minHeight);\n        }\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    this.preventDefaultEditableShortCuts = function (event) {\n      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n      if ((event.ctrlKey || event.metaKey) &&\n        list.contains([66, 73, 85], event.keyCode)) {\n        event.preventDefault();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName, $target) {\n      var onApplyCustomStyle = context.options.callbacks.onApplyCustomStyle;\n      if (onApplyCustomStyle) {\n        onApplyCustomStyle.call(this, $target, context, this.onFormatBlock);\n      } else {\n        this.onFormatBlock(tagName);\n      }\n    });\n\n    this.onFormatBlock = function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    };\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      // handle spaced urls from input\n      if (typeof linkUrl === 'string') {\n        linkUrl = linkUrl.trim();\n      }\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      } else {\n        // if url doesn't match an URL schema, set http:// as default\n        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n          linkUrl : 'http://' + linkUrl;\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n      var linkInfo = {\n        range: rng,\n        text: rng.toString(),\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n\n      // Define isNewWindow when anchor exists.\n      if ($anchor.length) {\n        linkInfo.isNewWindow = $anchor.attr('target') === '_blank';\n      }\n\n      return linkInfo;\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * Set foreground color\n     *\n     * @param {String} colorCode foreground color code\n     */\n    this.foreColor = this.wrapCommand(function (colorInfo) {\n      document.execCommand('styleWithCSS', false, true);\n      document.execCommand('foreColor', false, colorInfo);\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n     /**\n     * @method addRow\n     *\n     *\n     */\n    this.addRow = function (position) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.addRow(rng, position);\n        afterCommand();\n      }\n    };\n\n     /**\n     * @method addCol\n     *\n     *\n     */\n    this.addCol = function (position) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.addCol(rng, position);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteRow\n     *\n     *\n     */\n    this.deleteRow = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteRow(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteCol\n     *\n     *\n     */\n    this.deleteCol = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteCol(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * @method deleteTable\n     *\n     *\n     */\n    this.deleteTable = function () {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        beforeCommand();\n        table.deleteTable(rng);\n        afterCommand();\n      }\n    };\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.toggleClass('note-float-left', value === 'left');\n      $target.toggleClass('note-float-right', value === 'right');\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      var src = node && node.src;\n      if (dom.isImg(node) && src.indexOf('data:') === 0) {\n        var decodedData = atob(node.src.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n    var documentEventHandlers = {};\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    var detachDocumentEvent = function () {\n      Object.keys(documentEventHandlers).forEach(function (key) {\n        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n      });\n      documentEventHandlers = {};\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        documentEventHandlers.onDrop = function (e) {\n          e.preventDefault();\n        };\n        $document.on('drop', documentEventHandlers.onDrop);\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      documentEventHandlers.onDragenter = function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      };\n\n      documentEventHandlers.onDragleave = function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      };\n\n      documentEventHandlers.onDrop = function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      };\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', documentEventHandlers.onDragenter)\n        .on('dragleave', documentEventHandlers.onDragleave)\n        .on('drop', documentEventHandlers.onDrop);\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n\n    this.destroy = function () {\n      detachDocumentEvent();\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      require(['codemirror'], function (cm) {\n        CodeMirror = cm;\n      });\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        this.destroy();\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n        var onMouseMove = function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        };\n\n        $document\n          .on('mousemove', onMouseMove)\n          .one('mouseup', function () {\n            $document.off('mousemove', onMouseMove);\n          });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n      $statusbar.remove();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var self = this;\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    this.resizeTo = function (size) {\n      $editable.css('height', size.h);\n      $codable.css('height', size.h);\n      if ($codable.data('cmeditor')) {\n        $codable.data('cmeditor').setsize(null, size.h);\n      }\n    };\n\n    this.onResize = function () {\n      self.resizeTo({\n        h: $window.height() - $toolbar.outerHeight()\n      });\n    };\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n        $window.on('resize', this.onResize).trigger('resize');\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize', this.onResize);\n        this.resizeTo({ h: $editable.data('orgHeight') });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      },\n      'summernote.disable': function () {\n        self.hide();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          var onMouseMove = function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          };\n\n          $document\n            .on('mousemove', onMouseMove)\n            .one('mouseup', function (e) {\n              e.preventDefault();\n              $document.off('mousemove', onMouseMove);\n              context.invoke('editor.afterCommand');\n            });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n\n      // Listen for scrolling on the handle overlay.\n      this.$handle.on('wheel', function (e) {\n        e.preventDefault();\n        self.update();\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      if (context.isDisabled()) {\n        return false;\n      }\n\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var position = $image.position();\n        var pos = {\n          left: position.left + parseInt($image.css('marginLeft'), 10),\n          top: position.top + parseInt($image.css('marginTop'), 10)\n        };\n\n        // exclude margin\n        var imageSize = {\n          w: $image.outerWidth(false),\n          h: $image.outerHeight(false)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n\n      this.update();\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (!options.shortcuts || !shortcut) {\n        return '';\n      }\n\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.addTablePopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.magic), options),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandlerAndUpdateState('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandlerAndUpdateState('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandlerAndUpdateState('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandlerAndUpdateState('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandlerAndUpdateState('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandlerAndUpdateState('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents('<span class=\"note-current-fontname\"/>', options),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandlerAndUpdateState('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents('<span class=\"note-current-fontsize\"/>', options),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandlerAndUpdateState('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.dropdownButtonContents('', options),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<div class=\"note-palette\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-light\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"note-palette\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-light\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event'),\n                    tooltip: options.tooltip\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.alignLeft), options),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.textHeight), options),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.dropdownButtonContents(ui.icon(options.icons.table), options),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    /**\n     * table : [\n     *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],\n     *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]\n     * ],\n     */\n    this.addTablePopoverButtons = function () {\n      context.memo('button.addRowUp', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowAbove),\n          tooltip: lang.table.addRowAbove,\n          click: context.createInvokeHandler('editor.addRow', 'top')\n        }).render();\n      });\n      context.memo('button.addRowDown', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowBelow),\n          tooltip: lang.table.addRowBelow,\n          click: context.createInvokeHandler('editor.addRow', 'bottom')\n        }).render();\n      });\n      context.memo('button.addColLeft', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colBefore),\n          tooltip: lang.table.addColLeft,\n          click: context.createInvokeHandler('editor.addCol', 'left')\n        }).render();\n      });\n      context.memo('button.addColRight', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colAfter),\n          tooltip: lang.table.addColRight,\n          click: context.createInvokeHandler('editor.addCol', 'right')\n        }).render();\n      });\n      context.memo('button.deleteRow', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.rowRemove),\n          tooltip: lang.table.delRow,\n          click: context.createInvokeHandler('editor.deleteRow')\n        }).render();\n      });\n      context.memo('button.deleteCol', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.colRemove),\n          tooltip: lang.table.delCol,\n          click: context.createInvokeHandler('editor.deleteCol')\n        }).render();\n      });\n      context.memo('button.deleteTable', function () {\n        return ui.button({\n          className: 'btn-md',\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.table.delTable,\n          click: context.createInvokeHandler('editor.deleteTable')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    /**\n     * @param {jQuery} [$container]\n     */\n    this.updateCurrentStyle = function ($container) {\n      var $cont = $container || $toolbar;\n      \n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates($cont, {\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $cont.find('.dropdown-fontname a').each(function () {\n          var $item = $(this);\n          // always compare string to avoid creating another func.\n          var isChecked = ($item.data('value') + '') === (fontName + '');\n          $item.toggleClass('checked', isChecked);\n        });\n        $cont.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $cont.find('.dropdown-fontsize a').each(function () {\n          var $item = $(this);\n          // always compare with string to avoid creating another func.\n          var isChecked = ($item.data('value') + '') === (fontSize + '');\n          $item.toggleClass('checked', isChecked);\n        });\n        $cont.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $cont.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function ($container, infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($container.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      this.changeContainer(false);\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.changeContainer = function (isFullscreen) {\n      if (isFullscreen) {\n        $toolbar.prependTo($editor);\n      } else {\n        if (options.toolbarContainer) {\n          $toolbar.appendTo(options.toolbarContainer);\n        }\n      }\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n\n      this.changeContainer(isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group note-form-group\">' +\n                   '<label class=\"note-form-label\">' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control '+\n                   ' note-form-control  note-input\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group note-form-group\">' +\n                   '<label class=\"note-form-label\">' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control note-form-control ' +\n                   'note-input\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n      (!options.disableLinkTarget ?\n          $('<div/>').append(ui.checkbox({ id: 'sn-checkbox-open-in-new-window', text: lang.link.openInNewWindow, checked: true }).render())\n              .html()\n          : '');\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' +\n      'note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * toggle update button\n     */\n    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text;\n          }\n\n          $linkText.val(linkInfo.text);\n\n          var handleLinkTextUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          };\n\n          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n            setTimeout(handleLinkTextUpdate, 0);\n          });\n\n          var handleLinkUrlUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          };\n\n          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n            setTimeout(handleLinkUrlUpdate, 0);\n          }).val(linkInfo.url).trigger('focus');\n\n          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          var isChecked = linkInfo.isNewWindow !== undefined ?\n            linkInfo.isNewWindow : context.options.linkTargetBlank;\n\n          $openInNewWindow.prop('checked', isChecked);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            ui.hideDialog(self.$dialog);\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input paste keypress');\n          $linkUrl.off('input paste keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.disable summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content,.note-popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-form-group note-group-select-from-files\">' +\n                   '<label class=\"note-form-label\">' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control note-form-control note-input\" '+\n                   ' type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' + \n                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n                   '<label class=\"note-form-label\">' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control note-form-control note-input ' +\n                   ' col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' +\n      'note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n\n  /**\n   * Image popover module\n   *  mouse events that show/hide popover will be handled by Handle.js.\n   *  Handle.js will receive the events and invoke 'imagePopover.update'.\n   */\n  var ImagePopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editable = context.layoutInfo.editable;\n    var editable = $editable[0];\n    var options = context.options;\n\n    this.events = {\n      'summernote.disable': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        var posEditor = dom.posFromPlaceholder(editable);\n\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: Math.min(pos.top, posEditor.top)\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var TablePopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        self.update(e.target);\n      },\n      'summernote.keyup summernote.scroll summernote.change': function () {\n        self.update();\n      },\n      'summernote.disable': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.table);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-table-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content,.note-popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.table);\n\n      // [workaround] Disable Firefox's default table editor\n      if (agent.isFF) {\n        document.execCommand('enableInlineTableEditing', false, false);\n      }\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (context.isDisabled()) {\n        return false;\n      }\n\n      var isCell = dom.isCell(target);\n\n      if (isCell) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n\n      return isCell;\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group note-form-group row-fluid\">' +\n          '<label class=\"note-form-label\">' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control  note-form-control note-input span12\" ' + \n          ' type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-btn note-btn-primary ' + \n      ' note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*(\\d+)[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var qqRegExp = /\\/\\/v\\.qq\\.com.*?vid=(.+)/;\n      var qqMatch = url.match(qqRegExp);\n\n      var qqRegExp2 = /\\/\\/v\\.qq\\.com\\/x?\\/?(page|cover).*?\\/([^\\/]+)\\.html\\??.*/;\n      var qqMatch2 = url.match(qqRegExp2);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if ((qqMatch && qqMatch[1].length) || (qqMatch2 && qqMatch2[2].length)) {\n        var vid = ((qqMatch && qqMatch[1].length) ? qqMatch[1]:qqMatch2[2]);\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '310')\n            .attr('width', '500')\n            .attr('src', 'http://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.8</a> · ',\n        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body,.note-modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.disable summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n          context.invoke('buttons.updateCurrentStyle', this.$popover);\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.disable summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content,.note-popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        // XXX: consider to move codes to editor for recording redo/undo.\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.triggerEvent('change', context.layoutInfo.editable.html(), context.layoutInfo.editable);\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.8',\n    ui: ui,\n    dom: dom,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'tablePopover': TablePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n\n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        table: [\n          ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],\n          ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n      linkTargetBlank: true,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n      tooltip: 'auto',\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'rowBelow': 'note-icon-row-below',\n        'colBefore': 'note-icon-col-before',\n        'colAfter': 'note-icon-col-after',\n        'rowAbove': 'note-icon-row-above',\n        'rowRemove': 'note-icon-row-remove',\n        'colRemove': 'note-icon-col-remove',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-menu-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/summernote.js\n// module id = Wj0Y\n// module chunks = 5","module.exports = __webpack_public_path__ + \"vue/fonts/summernote.608fd10.woff\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/font/summernote.woff?0d0d5fac99cc8774d89eb08b1a8323c4\n// module id = cvcb\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\nfunction findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  var dir = from > to ? -1 : 1;\n  for (;;) {\n    if (from == to) { return from }\n    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n    if (mid == from) { return pred(mid) ? from : to }\n    if (pred(mid)) { to = mid; }\n    else { from = mid + dir; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\", 0) }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (direction == \"ltr\") {\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\nStringStream.prototype.baseToken = function () {\n  var oracle = this.lineOracle;\n  return oracle && oracle.baseToken(this.pos)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n  this.baseTokens = null;\n  this.baseTokenPos = 1;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.baseToken = function (n) {\n    var this$1 = this;\n\n  if (!this.baseTokens) { return null }\n  while (this.baseTokens[this.baseTokenPos] <= n)\n    { this$1.baseTokenPos += 2; }\n  var type = this.baseTokens[this.baseTokenPos + 1];\n  return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n          size: this.baseTokens[this.baseTokenPos] - n}\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    context.baseTokens = st;\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n    context.state = state;\n    context.baseTokens = null;\n    context.baseTokenPos = 1;\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\nfunction widgetTopHeight(lineObj) {\n  var height = 0;\n  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n    { height += widgetHeight(lineObj.widgets[i]); } } }\n  return height\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets) {\n    var height = widgetTopHeight(lineObj);\n    rect.top += height; rect.bottom += height;\n  }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = part.level == 1;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  y -= widgetTopHeight(lineObj);\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\n// Returns true if the given side of a box is after the given\n// coordinates, in top-to-bottom, left-to-right order.\nfunction boxIsAfter(box, x, y, left) {\n  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  // Move y into line-local coordinate space\n  y -= heightAtLine(lineObj);\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  // When directly calling `measureCharPrepared`, we have to adjust\n  // for the widgets at this line.\n  var widgetHeight$$1 = widgetTopHeight(lineObj);\n  var begin = 0, end = lineObj.text.length, ltr = true;\n\n  var order = getOrder(lineObj, cm.doc.direction);\n  // If the line isn't plain left-to-right text, first figure out\n  // which bidi section the coordinates fall into.\n  if (order) {\n    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n    ltr = part.level != 1;\n    // The awkward -1 offsets are needed because findFirst (called\n    // on these below) will treat its first bound as inclusive,\n    // second as exclusive, but we want to actually address the\n    // characters in the part's range\n    begin = ltr ? part.from : part.to - 1;\n    end = ltr ? part.to : part.from - 1;\n  }\n\n  // A binary search to find the first character whose bounding box\n  // starts after the coordinates. If we run across any whose box wrap\n  // the coordinates, store that.\n  var chAround = null, boxAround = null;\n  var ch = findFirst(function (ch) {\n    var box = measureCharPrepared(cm, preparedMeasure, ch);\n    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n    if (!boxIsAfter(box, x, y, false)) { return false }\n    if (box.top <= y && box.left <= x) {\n      chAround = ch;\n      boxAround = box;\n    }\n    return true\n  }, begin, end);\n\n  var baseX, sticky, outside = false;\n  // If a box around the coordinates was found, use that\n  if (boxAround) {\n    // Distinguish coordinates nearer to the left or right side of the box\n    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n    ch = chAround + (atStart ? 0 : 1);\n    sticky = atStart ? \"after\" : \"before\";\n    baseX = atLeft ? boxAround.left : boxAround.right;\n  } else {\n    // (Adjust for extended bound, if necessary.)\n    if (!ltr && (ch == end || ch == begin)) { ch++; }\n    // To determine which side to associate with, get the box to the\n    // left of the character and compare it's vertical position to the\n    // coordinates\n    sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n      \"after\" : \"before\";\n    // Now get accurate coordinates for this place, in order to get a\n    // base X position\n    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n    baseX = coords.left;\n    outside = y < coords.top || y >= coords.bottom;\n  }\n\n  ch = skipExtendingChars(lineObj.text, ch, 1);\n  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n}\n\nfunction coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n  // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n  // situation, we can take this ordering to correspond to the visual\n  // ordering. This finds the first part whose end is after the given\n  // coordinates.\n  var index = findFirst(function (i) {\n    var part = order[i], ltr = part.level != 1;\n    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                   \"line\", lineObj, preparedMeasure), x, y, true)\n  }, 0, order.length - 1);\n  var part = order[index];\n  // If this isn't the first part, the part's start is also after\n  // the coordinates, and the coordinates aren't on the same line as\n  // that start, move one part back.\n  if (index > 0) {\n    var ltr = part.level != 1;\n    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                             \"line\", lineObj, preparedMeasure);\n    if (boxIsAfter(start, x, y, true) && start.top > y)\n      { part = order[index - 1]; }\n  }\n  return part\n}\n\nfunction coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n  // In a wrapped line, rtl text on wrapping boundaries can do things\n  // that don't correspond to the ordering in our `order` array at\n  // all, so a binary search doesn't work, and we want to return a\n  // part that only spans one line so that the binary search in\n  // coordsCharInner is safe. As such, we first find the extent of the\n  // wrapped line, and then do a flat search in which we discard any\n  // spans that aren't on the line.\n  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n  var begin = ref.begin;\n  var end = ref.end;\n  if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n  var part = null, closestDist = null;\n  for (var i = 0; i < order.length; i++) {\n    var p = order[i];\n    if (p.from >= end || p.to <= begin) { continue }\n    var ltr = p.level != 1;\n    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n    // Weigh against spans ending before this, so that they are only\n    // picked if nothing ends after\n    var dist = endX < x ? x - endX + 1e9 : endX - x;\n    if (!part || closestDist > dist) {\n      part = p;\n      closestDist = dist;\n    }\n  }\n  if (!part) { part = order[order.length - 1]; }\n  // Clip the part to the wrapped line.\n  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n  return part\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  if ( primary === void 0 ) primary = true;\n\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (!primary && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\nfunction cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n  var docLTR = doc.direction == \"ltr\";\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    function wrapX(pos, dir, side) {\n      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n      var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n      var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n      return coords(ch, prop)[prop]\n    }\n\n    var order = getOrder(lineObj, doc.direction);\n    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n      var ltr = dir == \"ltr\";\n      var fromPos = coords(from, ltr ? \"left\" : \"right\");\n      var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n      var first = i == 0, last = !order || i == order.length - 1;\n      if (toPos.top - fromPos.top <= 3) { // Single line\n        var openLeft = (docLTR ? openStart : openEnd) && first;\n        var openRight = (docLTR ? openEnd : openStart) && last;\n        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n        add(left, fromPos.top, right - left, fromPos.bottom);\n      } else { // Multiple lines\n        var topLeft, topRight, botLeft, botRight;\n        if (ltr) {\n          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n          topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n          botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n          botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n        } else {\n          topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n          botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n        }\n        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n      }\n\n      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n      if (cmpCoords(toPos, start) < 0) { start = toPos; }\n      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n      if (cmpCoords(toPos, end) < 0) { end = toPos; }\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n    var w = line.widgets[i], parent = w.node.parentNode;\n    if (parent) { w.height = parent.offsetHeight; }\n  } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt();\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var assign;\n    (assign = [to, from], from = assign[0], to = assign[1], assign); }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0 || cm.doc.direction == \"rtl\") {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\n\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    if (/\\'$/.test(name))\n      { cm.state.keySeq = null; }\n    else\n      { stopSeq.set(50, function () {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      }); }\n    if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n  }\n  return dispatchKeyInner(cm, name, e, handle)\n}\n\nfunction dispatchKeyInner(cm, name, e, handle) {\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n// Used when mouse-selecting to adjust the anchor to the proper side\n// of a bidi jump depending on the visual position of the head.\nfunction bidiSimplify(cm, range$$1) {\n  var anchor = range$$1.anchor;\n  var head = range$$1.head;\n  var anchorLine = getLine(cm.doc, anchor.line);\n  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n  var order = getOrder(anchorLine);\n  if (!order) { return range$$1 }\n  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n  if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n  // Compute the relative visual position of the head compared to the\n  // anchor (<0 is to the left, >0 to the right)\n  var leftSide;\n  if (head.line != anchor.line) {\n    leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n  } else {\n    var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n    if (headIndex == boundary - 1 || headIndex == boundary)\n      { leftSide = dir < 0; }\n    else\n      { leftSide = dir > 0; }\n  }\n\n  var usePart = order[boundary + (leftSide ? -1 : 0)];\n  var from = leftSide == (usePart.level == 1);\n  var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  if (e.touches) {\n    mX = e.touches[0].clientX;\n    mY = e.touches[0].clientY;\n  } else {\n    try { mX = e.clientX; mY = e.clientY; }\n    catch(e) { return false }\n  }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find(0)))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.32.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_codemirror@5.32.0@codemirror/lib/codemirror.js\n// module id = dRO2\n// module chunks = 5","exports = module.exports = require(\"../../../node_modules/_css-loader@0.28.7@css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"img[data-v-9e4d1e1c]{height:150px;width:180px;margin:1% 1% 0}.m[data-v-9e4d1e1c]{width:800px;margin-left:auto;margin-right:auto}.input-file[data-v-9e4d1e1c]{display:inline-block;position:relative;overflow:hidden;text-align:center;width:auto;background-color:#2c7;border:1px solid #ddd;border-radius:4px;padding:5px 10px;font-size:12px;font-weight:400;line-height:18px;color:#fff;text-decoration:none}.input-file input[type=file][data-v-9e4d1e1c]{position:absolute;top:0;right:0;font-size:14px;background-color:#fff;-webkit-transform:translate(-300px) scale(4);transform:translate(-300px) scale(4);height:40px;opacity:0;filter:alpha(opacity=0)}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/CourseInfo.vue\"],\"names\":[],\"mappings\":\"AACA,qBACE,aAAc,AACd,YAAa,AACb,cAAoB,CACrB,AACD,oBAAqB,YAAa,AAAC,iBAAkB,AAAC,iBAAmB,CACxE,AACD,6BACE,qBAAsB,AACtB,kBAAmB,AACnB,gBAAiB,AACjB,kBAAmB,AACnB,WAAY,AACZ,sBAAuB,AACvB,sBAAuB,AACvB,kBAAmB,AACnB,iBAAkB,AAClB,eAAgB,AAChB,gBAAoB,AACpB,iBAAkB,AAClB,WAAW,AACX,oBAAsB,CACvB,AACD,8CACE,kBAAmB,AACnB,MAAO,AACP,QAAS,AACT,eAAgB,AAChB,sBAAuB,AACvB,6CAAmD,AAC3C,qCAA2C,AACnD,YAAa,AACb,UAAW,AACX,uBAAyB,CAC1B\",\"file\":\"CourseInfo.vue\",\"sourcesContent\":[\"\\nimg[data-v-9e4d1e1c]{\\n  height: 150px;\\n  width: 180px;\\n  margin: 1% 1% 0% 1%;\\n}\\n.m[data-v-9e4d1e1c]{ width: 800px; margin-left: auto; margin-right: auto;\\n}\\n.input-file[data-v-9e4d1e1c]{\\n  display: inline-block;\\n  position: relative;\\n  overflow: hidden;\\n  text-align: center;\\n  width: auto;\\n  background-color: #2c7;\\n  border: solid 1px #ddd;\\n  border-radius: 4px;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  font-weight: normal;\\n  line-height: 18px;\\n  color:#fff;\\n  text-decoration: none;\\n}\\n.input-file input[type=\\\"file\\\"][data-v-9e4d1e1c] {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  font-size: 14px;\\n  background-color: #fff;\\n  -webkit-transform: translate(-300px, 0px) scale(4);\\n          transform: translate(-300px, 0px) scale(4);\\n  height: 40px;\\n  opacity: 0;\\n  filter: alpha(opacity=0);\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-9e4d1e1c\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/CourseInfo.vue\n// module id = k5vd\n// module chunks = 5","<template>\r\n\t<div class=\"wrapper\">\r\n\t\t<div class=\"model\" v-show=\"model\" @click=\"model = false\">\r\n\t\t\t<div class=\"model-show\">\r\n\t\t\t\t<img :src=\"modelSrc\" alt=\"\">\r\n\t\t\t</div>\r\n\t\t\t<div class=\"container\" style=\"width:20%;margin-top:-10%;margin-left:44%\" v-show=\"modelBtn\" @click=\"modelBtn = false\" >\r\n\t\t\t\t<div style=\"margin-left:-25%;margin-top:-2%\" ><font size=\"2\" color=\"#ffffff\" face=\"微软雅黑\">✱ 【确定】后将会上传图片为【课程封面】</font><br></div>\r\n\t\t\t\t<div style=\"margin-top:4%\" >\r\n\t\t\t\t\t<button class=\"btn btn-info\" @click=\"addDB\" >确定</button>\r\n\t\t\t\t\t<button class=\"btn btn-success\" style=\"margin-left:5%\" >取消</button>\r\n\t\t\t\t</div>\r\n\t\t\t\t\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"content\">\r\n\t\r\n\t\t\t<div class=\"show-info\">\r\n\t\t\t\t<h2 class=\"title\">选择课程封面图片</h2>\r\n\t\t\t\t<div class=\"test\">\r\n\t\t\t\t\t<vueCropper\r\n\t\t\t\t\t\tref=\"cropper2\"\r\n\t\t\t\t\t\t:img=\"example2.img\"\r\n\t\t\t\t\t\t:outputSize=\"example2.size\"\r\n\t\t\t\t\t\t:outputType=\"example2.outputType\"\r\n\t\t\t\t\t\t:info=\"example2.info\"\r\n\t\t\t\t\t\t:canScale=\"example2.canScale\"\r\n\t\t\t\t\t\t:autoCrop=\"example2.autoCrop\"\r\n\t\t\t\t\t\t:autoCropWidth=\"example2.width\"\r\n\t\t\t\t\t\t:autoCropHeight=\"example2.height\"\r\n\t\t\t\t\t\t:fixed=\"example2.fixed\"\r\n\t\t\t\t\t\t:fixedNumber=\"example2.fixedNumber\"\r\n\t\t\t\t\t></vueCropper>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div style=\"margin-top:1%\">\r\n\t\t\t\t\t<label class=\"btn btn-warning\" for=\"upload2\">选择图片</label>\r\n\t\t\t\t\t<input type=\"file\" id=\"upload2\" style=\"position:absolute; clip:rect(0 0 0 0);\" accept=\"image/png, image/jpeg, image/gif, image/jpg\" @change=\"uploadImg($event, 2)\">\r\n\t\t\t\t\t<button style=\"margin-left:1%\" @click=\"finish2('base64')\" class=\"btn btn-info\">预览</button>\r\n\t\t\t\t\t<button style=\"margin-left:1%\" @click=\"upload\" class=\"btn btn-success\">完成</button>\r\n\t\t\t\t</div>\r\n\t\t\t\t\r\n\t\t\t</div>\r\n\t\t\t\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\nimport vueCropper from './vue-cropper'\r\n\r\nexport default {\r\n  data: function () {\r\n    return {\r\n\t\t\tmodel: false,\r\n\t\t\tmodelBtn: false,\r\n\t\t\tmodelSrc: '',\r\n\t\t  \tcrap: false,\r\n\t\t\timageU:'',\r\n\t\t\tcoverImgUrl:'',\r\n\t\t\texample2: {\r\n\t\t\t\timg: '',\r\n\t\t\t\tinfo: true,\r\n\t\t\t\tsize: 1,\r\n\t\t\t\toutputType: 'jpeg',\r\n\t\t\t\tcanScale: true,\r\n\t\t\t\tautoCrop: true,\r\n\t\t\t\t// 只有自动截图开启 宽度高度才生效\r\n\t\t\t\twidth: 400,\r\n\t\t\t\theight: 300,\r\n\t\t\t\tfixed: true,\r\n\t\t\t\tfixedNumber: [4, 3]\r\n\t\t\t},\r\n\t\t\tdownImg: '#',\r\n\t\t\tisShow: false\r\n    }\r\n  },\r\n\tmethods: {\r\n\t\tsumitImageFile(base64Codes){\r\n\t\t\tvar form=document.forms[0];\r\n\t\t\t\r\n\t\t\tvar formData = new FormData();   //这里连带form里的其他参数也一起提交了,如果不需要提交其他参数可以直接FormData无参数的构造函数\r\n\t\t\t\r\n\t\t\t//convertBase64UrlToBlob函数是将base64编码转换为Blob\r\n\t\t\tformData.append(\"file\",this.convertBase64UrlToBlob(base64Codes));  //append函数的第一个参数是后台获取数据的参数名,和html标签的input的name属性功能相同\r\n\t\t\t\r\n\t\t\t\r\n\t\t\taxios.post(\"/api/courseInfo/upload\",formData).then(response => {\t\t\t\t\r\n\t\t\t\tthis.coverImgUrl = response.data.result\r\n\t\t\t\tthis.$refs.cropper2.clearCrop()\r\n\t\t\t\tthis.$emit('transfer',this.coverImgUrl)\r\n\t\t\t\tthis.$emit(\"isModelShow\",this.isShow)\r\n\t\t\t\tthis.$refs.cropper2.clearCrop()\r\n\t\t\t\tbus.$emit(\"dialog\", {\r\n                  type: \"success\",//success default error warn\r\n                  body: \" 课程封面上传成功！\",\r\n                  auto: true,//是否自动隐藏\r\n                  time: 5000//毫秒\r\n                })\r\n\r\n\t\t\t}).catch(function (error) {\r\n\t\t\t　　bus.$emit(\"dialog\", {\r\n                  type: \"error\",//success default error warn\r\n                  body: \" 课程封面上传失败！\",\r\n                  auto: false,//是否自动隐藏\r\n                  time: 5000//毫秒\r\n                })\r\n\t\t\t});\r\n     \r\n\t\t},\r\n\r\n\t\t convertBase64UrlToBlob(urlData){\r\n    \r\n\t\t\tvar bytes=atob(urlData.split(',')[1]);           //去掉url的头，并转换为byte\r\n\t\t\t\r\n\t\t\t//处理异常,将ascii码小于0的转换为大于0\r\n\t\t\tvar ab = new ArrayBuffer(bytes.length);\r\n\t\t\tvar ia = new Uint8Array(ab);\r\n\t\t\tfor (var i = 0; i < bytes.length; i++) {\r\n\t\t\t\tia[i] = bytes.charCodeAt(i);\r\n\t\t\t}\r\n\r\n\t\t\treturn new Blob( [ab] , {type : 'image/png'});\r\n\t\t},\r\n\t\tfinish2 (type) {\r\n\t\t\tthis.$refs.cropper2.getCropData((data) => {\r\n\t\t\t\tthis.model = true\r\n\t\t\t\tthis.modelBtn = false\r\n\t\t\t\tthis.modelSrc = data\r\n\t\t\t})\r\n\t\t},\r\n\t\tupload(type){\r\n\t\t\tthis.$refs.cropper2.getCropData((data) => {\r\n\t\t\t\tthis.model = true\r\n\t\t\t\tthis.modelBtn = true\r\n\t\t\t\tthis.modelSrc = data\r\n\t\t\t\t// this.imageU = this.modelSrc\t\r\n\t\t\t})\t\r\n\t\t},\r\n\t\taddDB(type){\r\n\t\t\tthis.$refs.cropper2.getCropData((data) => {\r\n\t\t\t\tthis.sumitImageFile(data)\r\n\t\t\t})\t\r\n\t\t},\r\n\t\tuploadImg (e, num) {\r\n\t\t\tthis.modelSrc = ''\r\n\t\t\t//上传图片\r\n\t\t\t// this.option.img\r\n\t\t\tvar file = e.target.files[0]\r\n\t\t\tif (!/\\.(gif|jpg|jpeg|png|bmp|GIF|JPG|PNG)$/.test(e.target.value)) {\r\n\t\t\t\t alert('图片类型必须是.gif,jpeg,jpg,png,bmp中的一种')\r\n\t\t\t\t return false\r\n\t\t\t }\r\n\t\t\tvar reader = new FileReader()\r\n\t\t\treader.onload = (e) => {\r\n\t\t\t\tlet data\r\n\t\t\t\tif (typeof e.target.result === 'object') {\r\n\t\t\t\t\t// 把Array Buffer转化为blob 如果是base64不需要\r\n\t\t\t\t\tdata = window.URL.createObjectURL(new Blob([e.target.result]))\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdata = e.target.result\r\n\t\t\t\t}\r\n\t\t\t\tif (num === 1) {\r\n\t\t\t\t\tthis.option.img = data\r\n\t\t\t\t} else if (num === 2) {\r\n\t\t\t\t\tthis.example2.img = data\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 转化为base64\r\n\t\t\treader.readAsDataURL(file)\r\n\t\t\t// 转化为blob\r\n\t\t\t// reader.readAsArrayBuffer(file)\r\n\t\t\tthis.$refs.cropper2.startCrop()\r\n\t\t},\r\n\t\t down (type) {\r\n\t\t\tvar aLink = document.createElement('a')\r\n\t\t\taLink.download = 'demo'\r\n\t\t\t// 输出\r\n\t\t\tif (type === 'blob') {\r\n\t\t\t\tthis.$refs.cropper2.getCropBlob((data) => {\r\n\t\t\t\t\tthis.downImg = window.URL.createObjectURL(data)\r\n\t\t\t\t\taLink.href = window.URL.createObjectURL(data)\r\n\t\t\t\t\taLink.click()\r\n\t\t\t\t\t\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tthis.$refs.cropper2.getCropData((data) => {\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.downImg = data\r\n\t\t\t\t\taLink.href = data\r\n\t\t\t\t\taLink.click()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t},\r\n\tcomponents: {\r\n\t\tvueCropper,\r\n\t\t\r\n\t},\r\n\tmounted () {\r\n\t\t\r\n\t}\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n \r\n\r\n\t.content {\r\n\t\tmargin: auto;\r\n\t\tmax-width: 80%;\r\n\t\tmargin-bottom: 100px;\r\n\t}\r\n\r\n\t.des {\r\n\t\tline-height: 30px;\r\n\t}\r\n\r\n\tcode.language-html {\r\n\t\tpadding: 10px 20px;\r\n\t\tmargin: 10px 0px;\r\n\t\tdisplay: block;\r\n\t\tbackground-color: #333;\r\n\t\tcolor: #fff;\r\n\t\toverflow-x: auto;\r\n\t\tfont-family: Consolas, Monaco, Droid, Sans, Mono, Source, Code, Pro, Menlo, Lucida, Sans, Type, Writer, Ubuntu, Mono;\r\n\t\tborder-radius: 5px;\r\n\t\twhite-space: pre;\r\n\t}\r\n\r\n\t.show-info {\r\n\t\tmargin-bottom: 50px;\r\n\t}\r\n\r\n\t.show-info h2 {\r\n\t\tline-height: 50px;\r\n\t}\r\n\r\n\t/*.title, .title:hover, .title-focus, .title:visited {\r\n\t\tcolor: black;\r\n\t}*/\r\n\r\n\t.title {\r\n\t\tdisplay: block;\r\n\t\ttext-decoration: none;\r\n\t\ttext-align: center;\r\n\t\tline-height: 1.5;\r\n\t\tmargin: 20px 0px;\r\n\t\tbackground-image: -webkit-linear-gradient(left,#3498db,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db);\r\n\t\tcolor: transparent;\r\n\t\t-webkit-background-clip: text;\r\n\t\tbackground-size: 200% 100%;\r\n\t\tanimation: slide 5s infinite linear;\r\n\t\tfont-size: 40px;\r\n\t}\r\n\r\n\t.test {\r\n\t  height: 500px;\r\n\t}\r\n\r\n\t.model {\r\n\t\tposition: fixed;\r\n\t\tz-index: 10;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\toverflow: auto;\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\tbackground: rgba(0, 0, 0, 0.8);\r\n\t}\r\n\r\n\t.model-show {\r\n\t\tdisplay: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t}\r\n\r\n\t.model img {\r\n\t\tuser-select: none;\r\n\t\tbackground-position: 0px 0px, 10px 10px;\r\n\t\tbackground-size: 20px 20px;\r\n    background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100%),linear-gradient(45deg, #eee 25%, white 25%, white 75%, #eee 75%, #eee 100%);\r\n\t}\r\n\r\n\t.c-item {\r\n\t\tdisplay: block;\r\n\t\tpadding: 10px 0;\r\n\t\tuser-select: none;\r\n\t}\r\n\r\n\t@keyframes slide {\r\n    0%  {\r\n      background-position: 0 0;\r\n    }\r\n    100% {\r\n      background-position: -100% 0;\r\n    }\r\n  }\r\n\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/components/Course/cropper.vue","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../_css-loader@0.28.7@css-loader/index.js??ref--5-2!./summernote.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../_vue-style-loader@3.0.3@vue-style-loader/lib/addStylesClient.js\")(\"7db8ffc5\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_summernote@0.8.8@summernote/dist/summernote.css\n// module id = nCkV\n// module chunks = 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3bb4743c\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=styles&index=0!./cropper.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=script&index=0!./cropper.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-3bb4743c\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/_vue-loader@13.5.0@vue-loader/lib/selector?type=template&index=0!./cropper.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-3bb4743c\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Course/cropper.vue\n// module id = o5+c\n// module chunks = 5","exports = module.exports = require(\"../../../node_modules/_css-loader@0.28.7@css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".vue-cropper[data-v-5daee910]{position:relative;width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;direction:ltr;-ms-touch-action:none;touch-action:none;background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC\\\")}.cropper-box-canvas[data-v-5daee910],.cropper-box[data-v-5daee910],.cropper-crop-box[data-v-5daee910],.cropper-drag-box[data-v-5daee910],.cropper-face[data-v-5daee910]{position:absolute;top:0;right:0;bottom:0;left:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.cropper-box-canvas img[data-v-5daee910]{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-transform:none;transform:none}.cropper-box[data-v-5daee910]{overflow:hidden}.cropper-move[data-v-5daee910]{cursor:move}.cropper-crop[data-v-5daee910]{cursor:crosshair}.cropper-modal[data-v-5daee910]{background:rgba(0,0,0,.5)}.cropper-view-box[data-v-5daee910]{display:block;overflow:hidden;width:100%;height:100%;outline:1px solid #39f;outline-color:rgba(51,153,255,.75)}.cropper-view-box[data-v-5daee910],.cropper-view-box img[data-v-5daee910]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.cropper-face[data-v-5daee910]{top:0;left:0;background-color:#fff;opacity:.1}.crop-info[data-v-5daee910]{position:absolute;left:0;min-width:65px;text-align:center;color:#fff;line-height:20px;background-color:rgba(0,0,0,.8);font-size:12px}.crop-line[data-v-5daee910]{position:absolute;display:block;width:100%;height:100%;opacity:.1}.line-w[data-v-5daee910]{top:-3px;left:0;height:5px;cursor:n-resize}.line-a[data-v-5daee910]{top:0;left:-3px;width:5px;cursor:w-resize}.line-s[data-v-5daee910]{bottom:-3px;left:0;height:5px;cursor:s-resize}.line-d[data-v-5daee910]{top:0;right:-3px;width:5px;cursor:e-resize}.crop-point[data-v-5daee910]{position:absolute;width:8px;height:8px;opacity:.75;background-color:#39f;border-radius:100%}.point1[data-v-5daee910]{top:-4px;left:-4px;cursor:nw-resize}.point2[data-v-5daee910]{top:-5px;left:50%;margin-left:-3px;cursor:n-resize}.point3[data-v-5daee910]{top:-4px;right:-4px;cursor:ne-resize}.point4[data-v-5daee910]{top:50%;left:-4px;margin-top:-3px;cursor:w-resize}.point5[data-v-5daee910]{top:50%;right:-4px;margin-top:-3px;cursor:w-resize}.point6[data-v-5daee910]{bottom:-5px;left:-4px;cursor:sw-resize}.point7[data-v-5daee910]{bottom:-5px;left:50%;margin-left:-3px;cursor:s-resize}.point8[data-v-5daee910]{bottom:-5px;right:-4px;cursor:nw-resize}@media screen and (max-width:500px){.crop-point[data-v-5daee910]{position:absolute;width:20px;height:20px;opacity:.45;background-color:#39f;border-radius:100%}.point1[data-v-5daee910]{top:-10px;left:-10px}.point2[data-v-5daee910],.point4[data-v-5daee910],.point5[data-v-5daee910],.point7[data-v-5daee910]{display:none}.point3[data-v-5daee910]{top:-10px;right:-10px}.point4[data-v-5daee910]{top:0;left:0}.point6[data-v-5daee910]{bottom:-10px;left:-10px}.point8[data-v-5daee910]{bottom:-10px;right:-10px}}\", \"\", {\"version\":3,\"sources\":[\"D:/MyWorks/wcr/wcr-vue/src/components/Course/vue-cropper.vue\"],\"names\":[],\"mappings\":\"AACA,8BACE,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,8BAA+B,AACvB,sBAAuB,AAC/B,iBAAkB,AAClB,yBAA0B,AAC1B,sBAAuB,AACvB,qBAAsB,AACtB,cAAe,AACf,sBAAuB,AACnB,kBAAmB,AACtB,8QAAgR,CAClR,AACD,wKACE,kBAAmB,AACnB,MAAO,AACP,QAAS,AACT,SAAU,AACV,OAAQ,AACR,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAC3B,AACD,yCACE,kBAAmB,AACnB,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,iBAAkB,AAC1B,uBAAwB,AAChB,cAAgB,CACzB,AACD,8BACE,eAAiB,CAClB,AACD,+BACE,WAAa,CACd,AACD,+BACI,gBAAkB,CACrB,AACD,gCACE,yBAA+B,CAChC,AAID,mCACE,cAAe,AACf,gBAAiB,AACjB,WAAY,AACZ,YAAa,AACb,uBAAwB,AACtB,kCAAwC,CAK3C,AACD,0EALE,yBAA0B,AACvB,sBAAuB,AACtB,qBAAsB,AAClB,gBAAkB,CAO3B,AACD,+BACE,MAAO,AACP,OAAQ,AACR,sBAAuB,AACvB,UAAa,CACd,AACD,4BACE,kBAAmB,AACnB,OAAU,AACV,eAAgB,AAChB,kBAAmB,AACnB,WAAa,AACb,iBAAkB,AAClB,gCAAqC,AACrC,cAAgB,CACjB,AACD,4BACE,kBAAmB,AACnB,cAAe,AACf,WAAY,AACZ,YAAa,AACb,UAAY,CACb,AACD,yBACE,SAAU,AACR,OAAQ,AACR,WAAY,AACZ,eAAiB,CACpB,AACD,yBACE,MAAO,AACL,UAAW,AACX,UAAW,AACX,eAAiB,CACpB,AACD,yBACE,YAAa,AACb,OAAQ,AACR,WAAY,AACZ,eAAiB,CAClB,AACD,yBACE,MAAO,AACL,WAAY,AACZ,UAAW,AACX,eAAiB,CACpB,AACD,6BACE,kBAAmB,AACnB,UAAW,AACT,WAAY,AACZ,YAAa,AACb,sBAAuB,AACzB,kBAAoB,CACrB,AACD,yBACE,SAAU,AACR,UAAW,AACX,gBAAkB,CACrB,AACD,yBACE,SAAU,AACR,SAAU,AACV,iBAAkB,AAClB,eAAiB,CACpB,AACD,yBACE,SAAU,AACR,WAAY,AACZ,gBAAkB,CACrB,AACD,yBACE,QAAS,AACP,UAAW,AACX,gBAAiB,AACjB,eAAiB,CACpB,AACD,yBACE,QAAS,AACP,WAAY,AACZ,gBAAiB,AACjB,eAAiB,CACpB,AACD,yBACE,YAAa,AACb,UAAW,AACX,gBAAkB,CACnB,AACD,yBACE,YAAa,AACb,SAAU,AACV,iBAAkB,AAClB,eAAiB,CAClB,AACD,yBACE,YAAa,AACb,WAAY,AACZ,gBAAkB,CACnB,AACD,oCACA,6BACG,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,YAAa,AACb,sBAAuB,AACvB,kBAAoB,CACtB,AACD,yBACG,UAAW,AACT,UAAY,CAChB,AACD,oGACG,YAAc,CAChB,AACD,yBACG,UAAW,AACX,WAAa,CACf,AACD,yBACG,MAAO,AACP,MAAQ,CACV,AACD,yBACG,aAAc,AACd,UAAY,CACd,AACD,yBACG,aAAc,AACd,WAAa,CACf,CACA\",\"file\":\"vue-cropper.vue\",\"sourcesContent\":[\"\\n.vue-cropper[data-v-5daee910] {\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\t-webkit-box-sizing: border-box;\\n\\t\\t        box-sizing: border-box;\\n\\t\\tuser-select: none;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t-moz-user-select: none;\\n\\t\\t-ms-user-select: none;\\n\\t\\tdirection: ltr;\\n\\t\\t-ms-touch-action: none;\\n\\t\\t    touch-action: none;\\n  \\tbackground-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC');\\n}\\n.cropper-box[data-v-5daee910], .cropper-box-canvas[data-v-5daee910], .cropper-drag-box[data-v-5daee910], .cropper-crop-box[data-v-5daee910], .cropper-face[data-v-5daee910]{\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tright: 0;\\n\\t\\tbottom: 0;\\n\\t\\tleft: 0;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-box-canvas img[data-v-5daee910] {\\n\\t\\tposition: relative;\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n\\t\\t-webkit-transform: none;\\n\\t\\t        transform: none;\\n}\\n.cropper-box[data-v-5daee910] {\\n\\t\\toverflow: hidden;\\n}\\n.cropper-move[data-v-5daee910] {\\n\\t\\tcursor: move;\\n}\\n.cropper-crop[data-v-5daee910] {\\n    cursor: crosshair;\\n}\\n.cropper-modal[data-v-5daee910] {\\n\\t\\tbackground: rgba(0, 0, 0, 0.5);\\n}\\n.cropper-crop-box[data-v-5daee910] {\\n\\t\\t/*border: 2px solid #39f;*/\\n}\\n.cropper-view-box[data-v-5daee910] {\\n\\t\\tdisplay: block;\\n\\t\\toverflow: hidden;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\toutline: 1px solid #39f;\\n    outline-color: rgba(51, 153, 255, 0.75);\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-view-box img[data-v-5daee910] {\\n\\t\\t-webkit-user-select: none;\\n\\t\\t   -moz-user-select: none;\\n\\t\\t    -ms-user-select: none;\\n\\t\\t        user-select: none;\\n}\\n.cropper-face[data-v-5daee910] {\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\tbackground-color: #fff;\\n\\t\\topacity: 0.1;\\n}\\n.crop-info[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0px;\\n\\t\\tmin-width: 65px;\\n\\t\\ttext-align: center;\\n\\t\\tcolor: white;\\n\\t\\tline-height: 20px;\\n\\t\\tbackground-color: rgba(0, 0, 0, 0.8);\\n\\t\\tfont-size: 12px;\\n}\\n.crop-line[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\tdisplay: block;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\topacity: .1;\\n}\\n.line-w[data-v-5daee910] {\\n\\t\\ttop: -3px;\\n    left: 0;\\n    height: 5px;\\n    cursor: n-resize;\\n}\\n.line-a[data-v-5daee910] {\\n\\t\\ttop: 0;\\n    left: -3px;\\n    width: 5px;\\n    cursor: w-resize;\\n}\\n.line-s[data-v-5daee910] {\\n\\t\\tbottom: -3px;\\n\\t\\tleft: 0;\\n\\t\\theight: 5px;\\n\\t\\tcursor: s-resize;\\n}\\n.line-d[data-v-5daee910] {\\n\\t\\ttop: 0;\\n    right: -3px;\\n    width: 5px;\\n    cursor: e-resize;\\n}\\n.crop-point[data-v-5daee910] {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 8px;\\n    height: 8px;\\n    opacity: .75;\\n    background-color: #39f;\\n\\t\\tborder-radius: 100%;\\n}\\n.point1[data-v-5daee910] {\\n\\t\\ttop: -4px;\\n    left: -4px;\\n    cursor: nw-resize;\\n}\\n.point2[data-v-5daee910] {\\n\\t\\ttop: -5px;\\n    left: 50%;\\n    margin-left: -3px;\\n    cursor: n-resize;\\n}\\n.point3[data-v-5daee910] {\\n\\t\\ttop: -4px;\\n    right: -4px;\\n    cursor: ne-resize;\\n}\\n.point4[data-v-5daee910] {\\n\\t\\ttop: 50%;\\n    left: -4px;\\n    margin-top: -3px;\\n    cursor: w-resize;\\n}\\n.point5[data-v-5daee910] {\\n\\t\\ttop: 50%;\\n    right: -4px;\\n    margin-top: -3px;\\n    cursor: w-resize;\\n}\\n.point6[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tleft: -4px;\\n\\t\\tcursor: sw-resize;\\n}\\n.point7[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tleft: 50%;\\n\\t\\tmargin-left: -3px;\\n\\t\\tcursor: s-resize;\\n}\\n.point8[data-v-5daee910] {\\n\\t\\tbottom: -5px;\\n\\t\\tright: -4px;\\n\\t\\tcursor: nw-resize;\\n}\\n@media screen and (max-width: 500px) {\\n.crop-point[data-v-5daee910] {\\n\\t\\t\\tposition: absolute;\\n\\t\\t\\twidth: 20px;\\n\\t\\t\\theight: 20px;\\n\\t\\t\\topacity: .45;\\n\\t\\t\\tbackground-color: #39f;\\n\\t\\t\\tborder-radius: 100%;\\n}\\n.point1[data-v-5daee910] {\\n\\t\\t\\ttop: -10px;\\n\\t    left: -10px;\\n}\\n.point2[data-v-5daee910], .point4[data-v-5daee910], .point5[data-v-5daee910], .point7[data-v-5daee910] {\\n\\t\\t\\tdisplay: none;\\n}\\n.point3[data-v-5daee910] {\\n\\t\\t\\ttop: -10px;\\n\\t\\t\\tright: -10px;\\n}\\n.point4[data-v-5daee910] {\\n\\t\\t\\ttop: 0;\\n\\t\\t\\tleft: 0;\\n}\\n.point6[data-v-5daee910] {\\n\\t\\t\\tbottom: -10px;\\n\\t\\t\\tleft: -10px;\\n}\\n.point8[data-v-5daee910] {\\n\\t\\t\\tbottom: -10px;\\n\\t\\t\\tright: -10px;\\n}\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_css-loader@0.28.7@css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-5daee910\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=styles&index=0!./src/components/Course/vue-cropper.vue\n// module id = oIVi\n// module chunks = 5","<template>\r\n\t<div class=\"vue-cropper\" ref=\"cropper\">\r\n\t\t<div class=\"cropper-box\">\r\n\t\t\t<div class=\"cropper-box-canvas\"\r\n\t\t\t \tv-show=\"!loading\"\r\n\t\t\t\t:style=\"{\r\n\t\t\t\t\t'width': trueWidth + 'px',\r\n\t\t\t\t\t'height': trueHeight + 'px',\r\n\t\t\t\t\t'transform': 'scale(' + scale + ',' + scale + ') ' + 'translate3d('+ x / scale + 'px,' + y / scale + 'px,' + '0)'\r\n\t\t\t\t\t+ 'rotateZ('+ rotate * 90 +'deg)'\r\n\t\t\t\t\t}\">\r\n\t\t\t\t<img\r\n\t\t\t\t\t:src=\"imgs\"\r\n\t\t\t\t\talt=\"cropper-img\"\r\n\t\t\t\t\tref=\"cropperImg\"\r\n\t\t\t\t\t/>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div\r\n\t\t\tclass=\"cropper-drag-box\"\r\n\t\t  :class=\"{'cropper-move': move && !crop, 'cropper-crop': crop, 'cropper-modal': cropping}\"\r\n\t\t\t@mousedown=\"startMove\"\r\n      @touchstart=\"startMove\"\r\n\t\t\t@mouseover=\"scaleImg\"\r\n\t\t\t@mouseout=\"cancleScale\"\r\n\t\t\t>\r\n\t\t\t</div>\r\n\t\t\t<div\r\n\t\t\t\tv-show=\"cropping\"\r\n\t\t\t\tclass=\"cropper-crop-box\"\r\n\t\t\t\t:style=\"{\r\n\t\t\t\t\t'width': cropW + 'px',\r\n\t\t\t\t\t'height': cropH + 'px',\r\n\t\t\t\t\t'transform': 'translate3d('+ cropOffsertX + 'px,' + cropOffsertY + 'px,' + '0)'\r\n\t\t\t\t}\">\r\n\t\t\t\t<span class=\"cropper-view-box\">\r\n\t\t\t\t\t<img\r\n\t\t\t\t\t:style=\"{\r\n\t\t\t\t\t\t'width': trueWidth + 'px',\r\n\t\t\t\t\t\t'height': trueHeight + 'px',\r\n\t\t\t\t\t\t'transform': 'scale(' + scale + ',' + scale + ') ' + 'translate3d('+ (x - cropOffsertX) / scale  + 'px,' + (y - cropOffsertY) / scale + 'px,' + '0)'\r\n\t\t\t\t\t\t+ 'rotateZ('+ rotate * 90 +'deg)'\r\n\t\t\t\t\t\t}\"\r\n\t\t\t\t\t\t:src=\"imgs\"\r\n\t\t\t\t\t\talt=\"cropper-img\"\r\n\t\t\t\t\t\t/>\r\n\t\t\t\t</span>\r\n\t\t\t\t<span\r\n\t\t\t\t  class=\"cropper-face cropper-move\"\r\n\t\t\t\t\t@mousedown=\"cropMove\"\r\n\t\t      @touchstart=\"cropMove\"\r\n\t\t\t\t></span>\r\n\t\t\t\t<span class=\"crop-info\" v-if=\"info\" :style=\"{'top': cropInfo}\">{{  this.cropW }} × {{ this.cropH }}</span>\r\n\t\t\t\t<span v-if=\"!fixedBox\">\r\n\t\t\t\t\t<span class=\"crop-line line-w\" @mousedown=\"changeCropSize($event, false, true, 0, 1)\" @touchstart=\"changeCropSize($event, false, true, 0, 1)\"></span>\r\n\t\t\t\t\t<span class=\"crop-line line-a\" @mousedown=\"changeCropSize($event, true, false, 1, 0)\" @touchstart=\"changeCropSize($event, true, false, 1, 0)\"></span>\r\n\t\t\t\t\t<span class=\"crop-line line-s\" @mousedown=\"changeCropSize($event, false, true, 0, 2)\" @touchstart=\"changeCropSize($event, false, true, 0, 2)\"></span>\r\n\t\t\t\t\t<span class=\"crop-line line-d\" @mousedown=\"changeCropSize($event, true, false, 2, 0)\" @touchstart=\"changeCropSize($event, true, false, 2, 0)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point1\" @mousedown=\"changeCropSize($event, true, true, 1, 1)\" @touchstart=\"changeCropSize($event, true, true, 1, 1)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point2\" @mousedown=\"changeCropSize($event, false, true, 0, 1)\" @touchstart=\"changeCropSize($event, false, true, 0, 1)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point3\" @mousedown=\"changeCropSize($event, true, true, 2, 1)\" @touchstart=\"changeCropSize($event, true, true, 2, 1)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point4\" @mousedown=\"changeCropSize($event, true, false, 1, 0)\" @touchstart=\"changeCropSize($event, true, false, 1, 0)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point5\" @mousedown=\"changeCropSize($event, true, false, 2, 0)\" @touchstart=\"changeCropSize($event, true, false, 2, 0)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point6\" @mousedown=\"changeCropSize($event, true, true, 1, 2)\" @touchstart=\"changeCropSize($event, true, true, 1, 2)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point7\" @mousedown=\"changeCropSize($event, false, true, 0, 2)\" @touchstart=\"changeCropSize($event, false, true, 0, 2)\"></span>\r\n\t\t\t\t\t<span class=\"crop-point point8\" @mousedown=\"changeCropSize($event, true, true, 2, 2)\" @touchstart=\"changeCropSize($event, true, true, 2, 2)\"></span>\r\n\t\t\t\t</span>\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\nimport exif from '../../../static/exif.js'\r\nexport default {\r\n  data: function () {\r\n    return {\r\n\t\t\t// 容器高宽\r\n\t\t\tw: 0,\r\n\t\t\th: 0,\r\n\t\t\t// 图片缩放比例\r\n\t\t\tscale: 1,\r\n\t\t\t// 图片偏移x轴\r\n\t\t\tx: 0,\r\n\t\t\t// 图片偏移y轴\r\n\t\t\ty: 0,\r\n\t\t\t// 图片加载\r\n\t\t\tloading: true,\r\n\t\t\t// 图片真实宽度\r\n\t\t\ttrueWidth: 0,\r\n\t\t\t// 图片真实高度\r\n\t\t\ttrueHeight: 0,\r\n\t\t\t// 是否可以拖动图片\r\n\t\t\tmove: true,\r\n\t\t\t// 移动的x\r\n\t\t\tmoveX: 0,\r\n\t\t\t// 移动的y\r\n\t\t\tmoveY: 0,\r\n\t\t\t// 开启截图\r\n\t\t\tcrop: false,\r\n\t\t\t// 正在截图\r\n\t\t\tcropping: false,\r\n\t\t\t// 裁剪框大小\r\n\t\t\tcropW: 0,\r\n\t\t\tcropH: 0,\r\n\t\t\tcropOldW: 0,\r\n\t\t\tcropOldH: 0,\r\n\t\t\t// 判断是否能够改变\r\n\t\t\tcanChangeX: false,\r\n\t\t\tcanChangeY: false,\r\n\t\t\t// 改变的基准点\r\n\t\t\tchangeCropTypeX: 1,\r\n\t\t\tchangeCropTypeY: 1,\r\n\t\t\t// 裁剪框的坐标轴\r\n\t\t\tcropX: 0,\r\n\t\t\tcropY: 0,\r\n\t\t\tcropChangeX: 0,\r\n\t\t\tcropChangeY: 0,\r\n\t\t\tcropOffsertX: 0,\r\n\t\t\tcropOffsertY: 0,\r\n\t\t\t// 支持的滚动事件\r\n\t\t\tsupport: '',\r\n\t\t\t// 移动端手指缩放\r\n\t\t\ttouches: [],\r\n\t\t\ttouchNow: false,\r\n\t\t\t// 图片旋转\r\n\t\t\trotate: 0,\r\n\t\t\tisIos: false,\r\n\t\t\torientation: 0,\r\n\t\t\timgs: ''\r\n    }\r\n  },\r\n\tprops: {\r\n\t\timg: {\r\n\t\t\ttype: String,\r\n\t\t\tdefault: ''\r\n\t\t},\r\n\t\t// 输出图片压缩比\r\n\t\toutputSize: {\r\n\t\t\ttype: Number,\r\n\t\t\tdefault: 1\r\n\t\t},\r\n\t\toutputType: {\r\n\t\t\ttype: String,\r\n\t\t\tdefault: 'jpeg'\r\n\t\t},\r\n\t\tinfo: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: true\r\n\t\t},\r\n\t\t// 是否开启滚轮放大缩小\r\n\t\tcanScale: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: true\r\n\t\t},\r\n\t\t// 是否自成截图框\r\n\t\tautoCrop: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false\r\n\t\t},\r\n\t\tautoCropWidth: {\r\n\t\t\ttype: Number,\r\n\t\t\tdefault: 0\r\n\t\t},\r\n\t\tautoCropHeight: {\r\n\t\t\ttype: Number,\r\n\t\t\tdefault: 0\r\n\t\t},\r\n\t\t// 是否开启固定宽高比\r\n\t\tfixed: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false\r\n\t\t},\r\n\t\t// 宽高比 w/h\r\n\t\tfixedNumber: {\r\n\t\t\ttype: Array,\r\n\t\t\tdefault: () => {\r\n\t\t\t\treturn [1, 1]\r\n\t\t\t}\r\n\t\t},\r\n\t\t// 固定大小 禁止改变截图框大小\r\n\t\tfixedBox: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false\r\n\t\t},\r\n\t\t// 输出截图是否缩放\r\n\t\tfull: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false\r\n\t\t}\r\n\t},\r\n\tcomputed: {\r\n\t\tcropInfo () {\r\n\t\t\treturn this.cropOffsertY > 20 ? '-20px' : '0px'\r\n\t\t}\r\n\t},\r\n\twatch: {\r\n\t\t// 如果图片改变， 重新布局\r\n\t\timg () {\r\n\t\t\t// 当传入图片时, 读取图片信息同时展示\r\n\t\t\tthis.checkedImg()\r\n\t\t},\r\n\t\timgs () {\r\n\t\t\tthis.reload()\r\n\t\t},\r\n\t\tcropW () {\r\n\t\t\tthis.cropW = ~~(this.cropW)\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\tcropH () {\r\n\t\t\tthis.cropH = ~~(this.cropH)\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\tcropOffsertX () {\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\tcropOffsertY () {\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\tscale () {\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\tx () {\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\ty () {\r\n\t\t\tthis.showPreview()\r\n\t\t},\r\n\t\trotate () {\r\n\t\t\tthis.showPreview()\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\t// 校验图片\r\n\t\tcheckedImg () {\r\n\t\t\tthis.loading = true\r\n\t\t\tthis.scale = 1\r\n\t\t\tthis.clearCrop()\r\n\t\t\tlet canvas = document.createElement('canvas')\r\n\t\t\tlet img = new Image\r\n\t\t\tlet rotate = 0\r\n\t\t\timg.onload = () => {\r\n\t\t\t\tlet width = img.width\r\n\t\t\t\tlet height = img.height\r\n\t\t\t\tlet ctx = canvas.getContext('2d')\r\n\t\t\t\tctx.save()\r\n\t\t\t\texif.getData(img, () => {\r\n\t\t\t\t\texif.getAllTags(img)\r\n\t\t\t\t\tthis.orientation = exif.getTag(img, 'Orientation')\r\n\t\t\t\t\tswitch (this.orientation) {\r\n\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\trotate = 1\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\t\trotate = -1\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\trotate = 3\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\trotate = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (rotate === 0) {\r\n\t\t\t\t\t\tthis.imgs = this.img\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tswitch (rotate) {\r\n\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase -3:\r\n\t\t\t\t\t\t\t// 旋转90度 或者-270度 宽度和高度对调\r\n\t\t\t\t\t\t\tcanvas.width = height\r\n\t\t\t\t\t\t\tcanvas.height = width\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, -height, width, height)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase -2:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, -width, -height, width, height)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tcase -1:\r\n\t\t\t\t\t\t\tcanvas.width = height\r\n\t\t\t\t\t\t\tcanvas.height = width\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, -width, 0, width, height)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.restore()\r\n\t\t\t\t\tcanvas.toBlob((blob) => {\r\n\t\t\t\t\t\tlet data = URL.createObjectURL(blob)\r\n\t\t\t\t\t\tthis.imgs = data\r\n\t\t\t\t\t}, 'image/' + this.outputType, 1)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\timg.crossOrigin = '*'\r\n\t\t\timg.src = this.img\r\n\t\t},\r\n\t\t// 当按下鼠标键\r\n\t\tstartMove (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\t// 如果move 为true 表示当前可以拖动\r\n\t\t\tif (this.move && !this.crop) {\r\n\t\t\t\t// 开始移动\r\n\t\t\t\tthis.moveX = (e.clientX ? e.clientX : e.touches[0].clientX) - this.x\r\n\t      this.moveY = (e.clientY ? e.clientY : e.touches[0].clientY) - this.y\r\n\t\t\t\tif (e.touches) {\r\n\t\t\t\t\twindow.addEventListener('touchmove', this.moveImg)\r\n\t      \twindow.addEventListener('touchend', this.leaveImg)\r\n\t\t\t\t\tif (e.touches.length == 2) {\r\n\t\t\t\t\t  // 记录手指刚刚放上去\r\n\t\t\t\t\t\tthis.touches = e.touches\r\n\t\t\t\t\t\twindow.addEventListener('touchmove', this.touchScale)\r\n\t\t      \twindow.addEventListener('touchend', this.cancleTouchScale)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\twindow.addEventListener('mousemove', this.moveImg)\r\n\t      \twindow.addEventListener('mouseup', this.leaveImg)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// 截图ing\r\n\t\t\t\tthis.cropping = true\r\n\t\t\t\t// 绑定截图事件\r\n\t\t\t\twindow.addEventListener('mousemove', this.createCrop)\r\n\t\t\t\twindow.addEventListener('mouseup', this.endCrop)\r\n\t\t\t\twindow.addEventListener('touchmove', this.createCrop)\r\n\t\t\t\twindow.addEventListener('touchend', this.endCrop)\r\n\t\t\t\tthis.cropOffsertX = e.offsetX ? e.offsetX : (e.touches[0].pageX - this.$refs.cropper.offsetLeft)\r\n\t\t\t\tthis.cropOffsertY = e.offsetY ? e.offsetY : (e.touches[0].pageY - this.$refs.cropper.offsetTop)\r\n\t\t\t\tthis.cropX = e.clientX ? e.clientX : e.touches[0].clientX\r\n\t\t\t\tthis.cropY = e.clientY ? e.clientY : e.touches[0].clientY\r\n\t\t\t\tthis.cropChangeX = this.cropOffsertX\r\n\t\t\t\tthis.cropChangeY = this.cropOffsertY\r\n\t\t\t\tthis.cropW = 0\r\n\t\t\t\tthis.cropH = 0\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// 移动端缩放\r\n\t\ttouchScale (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\t// 记录变化量\r\n\t\t\t// 第一根手指\r\n\t\t\tvar oldTouch1 = {\r\n\t\t\t\tx: this.touches[0].clientX,\r\n\t\t\t\ty: this.touches[0].clientY\r\n\t\t\t}\r\n\t\t\tvar newTouch1 = {\r\n\t\t\t\tx: e.touches[0].clientX,\r\n\t\t\t\ty: e.touches[0].clientY\r\n\t\t\t}\r\n\t\t\t// 第二根手指\r\n\t\t\tvar oldTouch2 = {\r\n\t\t\t\tx: this.touches[1].clientX,\r\n\t\t\t\ty: this.touches[1].clientY\r\n\t\t\t}\r\n\t\t\tvar newTouch2 = {\r\n\t\t\t\tx: e.touches[1].clientX,\r\n\t\t\t\ty: e.touches[1].clientY\r\n\t\t\t}\r\n\t\t\tvar oldL = Math.sqrt(Math.pow(oldTouch1.x - oldTouch2.x, 2) + Math.pow(oldTouch1.y - oldTouch2.y, 2))\r\n\t\t\tvar newL = Math.sqrt(Math.pow(newTouch1.x - newTouch2.x, 2) + Math.pow(newTouch1.y - newTouch2.y, 2))\r\n\t\t\tvar cha = ~~(newL - oldL)\r\n\t\t\t// 根据图片本身大小 决定每次改变大小的系数, 图片越大系数越小\r\n\t\t\t// 1px - 0.2\r\n\t\t\tvar coe = 1\r\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth\r\n\t\t\tcoe = coe > 0.1 ? 0.1 : coe\r\n\t\t\tvar num = coe * cha\r\n\t\t\tif (!this.touchNow) {\r\n\t\t\t\tthis.touchNow = true\r\n\t\t\t\tif (cha > 0) {\r\n\t\t\t\t\tthis.scale += Math.abs(num)\r\n\t\t\t\t} else if (cha < 0) {\r\n\t\t\t\t\tthis.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale\r\n\t\t\t\t}\r\n\t\t\t\tthis.touches = e.touches\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tthis.touchNow = false\r\n\t\t\t\t}, 8)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcancleTouchScale (e) {\r\n\t\t  window.removeEventListener('touchmove', this.touchScale)\r\n\t\t},\r\n\r\n\t\t// 移动图片\r\n\t\tmoveImg (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\tif (e.touches && e.touches.length === 2) {\r\n\t\t\t\tthis.touches = e.touches\r\n\t\t\t\twindow.addEventListener('touchmove', this.touchScale)\r\n\t\t\t\twindow.addEventListener('touchend', this.cancleTouchScale)\r\n\t\t\t\twindow.removeEventListener('touchmove', this.moveImg)\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches[0].clientX\r\n      var nowY = e.clientY ? e.clientY : e.touches[0].clientY\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.x = ~~(nowX - this.moveX)\r\n\t\t\t\tthis.y = ~~(nowY - this.moveY)\r\n\t\t\t})\r\n\t\t},\r\n\t\t// 移动图片结束\r\n\t\tleaveImg (e) {\r\n\t\t\twindow.removeEventListener('mousemove', this.moveImg)\r\n      window.removeEventListener('touchmove', this.moveImg)\r\n      window.removeEventListener('mouseup', this.leaveImg)\r\n      window.removeEventListener('touchend', this.leaveImg)\r\n\t\t},\r\n\t\t// 缩放图片\r\n\t\tscaleImg () {\r\n\t\t\tthis.support = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\"\r\n\t\t\tif (this.canScale) {\r\n\t\t\t\twindow.addEventListener(this.support, this.changeSize)\r\n\t\t\t}\r\n\t\t},\r\n\t\t// 移出框\r\n\t\tcancleScale () {\r\n\t\t\tif (this.canScale) {\r\n\t\t\t\twindow.removeEventListener(this.support, this.changeSize)\r\n\t\t\t}\r\n\t\t},\r\n\t\t// 改变大小函数\r\n\t\tchangeSize (e) {\r\n\t\t\tvar change = e.deltaY || e.wheelDelta\r\n\t\t\t// 根据图片本身大小 决定每次改变大小的系数, 图片越大系数越小\r\n      var isFirefox = navigator.userAgent.indexOf('Firefox')\r\n      change = isFirefox > 0 ? change * 30 : change\r\n\t\t\t// 1px - 0.2\r\n\t\t\tvar coe = 0.2\r\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth\r\n\t\t\tvar num = coe * change\r\n\t\t\tnum < 0 ? this.scale += Math.abs(num) : this.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale\r\n\t\t\te.preventDefault()\r\n\t\t},\r\n\r\n\t\t// 修改图片大小函数\r\n\t\tchangeScale (num) {\r\n\t\t\tnum = num || 1\r\n\t\t\tvar coe = 20\r\n\t\t\tcoe = coe / this.trueWidth > coe / this.trueHeight ? coe / this.trueHeight : coe / this.trueWidth\r\n\t\t\tnum = num * coe\r\n\t\t\tnum > 0 ? this.scale += Math.abs(num) : this.scale > Math.abs(num) ? this.scale -= Math.abs(num) : this.scale\r\n\t\t},\r\n\t\t// 创建截图框\r\n\t\tcreateCrop (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\t// 移动生成大小\r\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches ? e.touches[0].clientX : 0\r\n      var nowY = e.clientY ? e.clientY : e.touches ? e.touches[0].clientY : 0\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tvar fw = ~~(nowX - this.cropX)\r\n\t\t\t\tvar fh = ~~(nowY - this.cropY)\r\n\t\t\t\tif (fw > 0) {\r\n\t\t\t\t\tthis.cropW = fw + this.cropChangeX > this.w ? this.w - this.cropChangeX : fw\r\n\t\t\t\t\tthis.cropOffsertX = this.cropChangeX\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.cropW = (this.w - this.cropChangeX + Math.abs(fw)) > this.w ? this.cropChangeX : Math.abs(fw)\r\n\t\t\t\t\tthis.cropOffsertX = this.cropChangeX  + fw > 0 ? this.cropChangeX + fw : 0\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!this.fixed) {\r\n\t\t\t\t\tif (fh > 0) {\r\n\t\t\t\t\t\tthis.cropH = fh + this.cropChangeY > this.h ? this.h - this.cropChangeY : fh\r\n\t\t\t\t\t\tthis.cropOffsertY = this.cropChangeY\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.cropH = (this.h - this.cropChangeY + Math.abs(fh)) > this.h ? this.cropChangeY : Math.abs(fh)\r\n\t\t\t\t\t\tthis.cropOffsertY = this.cropChangeY  + fh > 0 ? this.cropChangeY + fh : 0\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fixedHeight = ~~(this.cropW / this.fixedNumber[0] * this.fixedNumber[1])\r\n\t\t\t\t\tif (fixedHeight + this.cropOffsertY > this.h) {\r\n\t\t\t\t\t\tthis.cropH = this.h - this.cropOffsertY\r\n\t\t\t\t\t\tthis.cropW = ~~(this.cropH / this.fixedNumber[1] * this.fixedNumber[0])\r\n\t\t\t\t\t\tif (fw > 0) {\r\n\t\t\t\t\t\t\tthis.cropOffsertX = this.cropChangeX\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.cropOffsertX = this.cropChangeX - this.cropW\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.cropH = fixedHeight\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.cropOffsertY = this.cropOffsertY\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t// 改变截图框大小\r\n\t\tchangeCropSize (e, w, h, typeW, typeH) {\r\n\t\t\te.preventDefault()\r\n\t\t\twindow.addEventListener('mousemove', this.changeCropNow)\r\n\t\t\twindow.addEventListener('mouseup', this.changeCropEnd)\r\n\t\t\twindow.addEventListener('touchmove', this.changeCropNow)\r\n\t\t\twindow.addEventListener('touchend', this.changeCropEnd)\r\n\t\t\tthis.canChangeX = w\r\n\t\t\tthis.canChangeY = h\r\n\t\t\tthis.changeCropTypeX = typeW\r\n\t\t\tthis.changeCropTypeY = typeH\r\n\t\t\tthis.cropX = e.clientX ? e.clientX : e.touches[0].clientX\r\n\t\t\tthis.cropY = e.clientY ? e.clientY : e.touches[0].clientY\r\n\t\t\tthis.cropOldW = this.cropW\r\n\t\t\tthis.cropOldH = this.cropH\r\n\t\t\tthis.cropChangeX = this.cropOffsertX\r\n\t\t\tthis.cropChangeY = this.cropOffsertY\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.canChangeX && this.canChangeY) {\r\n\t\t\t\t\tthis.canChangeY = 0\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// 正在改变\r\n\t\tchangeCropNow (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches ? e.touches[0].clientX : 0\r\n      var nowY = e.clientY ? e.clientY : e.touches ? e.touches[0].clientY : 0\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tvar fw = ~~(nowX - this.cropX)\r\n\t\t\t\tvar fh = ~~(nowY - this.cropY)\r\n\t\t\t\tif (this.canChangeX) {\r\n\t\t\t\t\tif (this.changeCropTypeX === 1) {\r\n\t\t\t\t\t\tif (this.cropOldW - fw > 0) {\r\n\t\t\t\t\t\t\tthis.cropW = this.w - this.cropChangeX - fw <= this.w ? this.cropOldW - fw : this.cropOldW + this.cropChangeX\r\n\t\t\t\t\t\t\tthis.cropOffsertX = this.w - this.cropChangeX - fw <= this.w ? this.cropChangeX + fw : 0\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.cropW = Math.abs(fw) + this.cropChangeX <= this.w ? Math.abs(fw) - this.cropOldW : this.w - this.cropOldW - this.cropChangeX\r\n\t\t\t\t\t\t\tthis.cropOffsertX = this.cropChangeX + this.cropOldW\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (this.changeCropTypeX === 2) {\r\n\t\t\t\t\t\tif (this.cropOldW + fw > 0) {\r\n\t\t\t\t\t\t\tthis.cropW = this.cropOldW + fw + this.cropOffsertX <= this.w ? this.cropOldW + fw : this.w - this.cropOffsertX\r\n\t\t\t\t\t\t\tthis.cropOffsertX = this.cropChangeX\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.cropW = (this.w - this.cropChangeX + Math.abs(fw + this.cropOldW)) <= this.w ? Math.abs(fw + this.cropOldW) : this.cropChangeX\r\n\t\t\t\t\t\t\tthis.cropOffsertX = (this.w - this.cropChangeX + Math.abs(fw + this.cropOldW)) <= this.w ? this.cropChangeX - Math.abs(fw + this.cropOldW) : 0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.canChangeY) {\r\n\t\t\t\t\tif (this.changeCropTypeY === 1) {\r\n\t\t\t\t\t\tif (this.cropOldH - fh > 0) {\r\n\t\t\t\t\t\t\tthis.cropH = this.h - this.cropChangeY - fh <= this.h ? this.cropOldH - fh : this.cropOldH + this.cropChangeY\r\n\t\t\t\t\t\t\tthis.cropOffsertY = this.h - this.cropChangeY - fh <= this.h ? this.cropChangeY + fh : 0\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.cropH = Math.abs(fh) + this.cropChangeY <= this.h ? Math.abs(fh) - this.cropOldH : this.h - this.cropOldH - this.cropChangeY\r\n\t\t\t\t\t\t\tthis.cropOffsertY = this.cropChangeY + this.cropOldH\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (this.changeCropTypeY === 2) {\r\n\t\t\t\t\t\tif (this.cropOldH + fh > 0) {\r\n\t\t\t\t\t\t\tthis.cropH = this.cropOldH + fh + this.cropOffsertY <= this.h ? this.cropOldH + fh : this.h - this.cropOffsertY\r\n\t\t\t\t\t\t\tthis.cropOffsertY = this.cropChangeY\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.cropH = (this.h - this.cropChangeY + Math.abs(fh + this.cropOldH)) <= this.h ? Math.abs(fh + this.cropOldH) : this.cropChangeY\r\n\t\t\t\t\t\t\tthis.cropOffsertY = (this.h - this.cropChangeY + Math.abs(fh + this.cropOldH)) <= this.h ? this.cropChangeY - Math.abs(fh + this.cropOldH) : 0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.canChangeX && this.fixed) {\r\n\t\t\t\t\tvar fixedHeight = ~~(this.cropW / this.fixedNumber[0] * this.fixedNumber[1])\r\n\t\t\t\t\tif (fixedHeight + this.cropOffsertY > this.h) {\r\n\t\t\t\t\t\tthis.cropH = this.h - this.cropOffsertY\r\n\t\t\t\t\t\tthis.cropW = ~~(this.cropH / this.fixedNumber[1] * this.fixedNumber[0])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.cropH = fixedHeight\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.canChangeY && this.fixed) {\r\n\t\t\t\t\tvar fixedWidth = ~~(this.cropH / this.fixedNumber[1] * this.fixedNumber[0])\r\n\t\t\t\t\tif (fixedWidth + this.cropOffsertX > this.w) {\r\n\t\t\t\t\t\tthis.cropW = this.w - this.cropOffsertX\r\n\t\t\t\t\t\tthis.cropH = ~~(this.cropW / this.fixedNumber[0] * this.fixedNumber[1])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.cropW = fixedWidth\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t// 结束改变\r\n\t\tchangeCropEnd (e) {\r\n\t\t\twindow.removeEventListener('mousemove', this.changeCropNow)\r\n\t\t\twindow.removeEventListener('mouseup', this.changeCropEnd)\r\n\t\t\twindow.removeEventListener('touchmove', this.changeCropNow)\r\n\t\t\twindow.removeEventListener('touchend', this.changeCropEnd)\r\n\t\t},\r\n\r\n\t\t// 创建完成\r\n\t\tendCrop () {\r\n\t\t\tif (this.cropW === 0 && this.cropH === 0) {\r\n\t\t\t\tthis.cropping = false\r\n\t\t\t}\r\n\t\t\twindow.removeEventListener('mousemove', this.createCrop)\r\n\t\t\twindow.removeEventListener('mouseup', this.endCrop)\r\n\t\t\twindow.removeEventListener('touchmove', this.createCrop)\r\n\t\t\twindow.removeEventListener('touchend', this.endCrop)\r\n\t\t},\r\n\t\t// 开始截图\r\n\t\tstartCrop () {\r\n\t\t\tthis.crop = true\r\n\t\t\t// console.log('开始截图')\r\n\t\t},\r\n\t\t// 停止截图\r\n\t\tstopCrop () {\r\n\t\t\tthis.crop = false\r\n\t\t\t// console.log('停止截图')\r\n\t\t},\r\n\t\t// 清除截图\r\n\t\tclearCrop () {\r\n\t\t\tthis.cropping = false\r\n\t\t\tthis.cropW = 0\r\n\t\t\tthis.cropH = 0\r\n\t\t\t// console.log('清除截图')\r\n\t\t},\r\n\t\t// 截图移动\r\n\t\tcropMove (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\twindow.addEventListener('mousemove', this.moveCrop)\r\n\t\t\twindow.addEventListener('mouseup', this.leaveCrop)\r\n\t\t\twindow.addEventListener('touchmove', this.moveCrop)\r\n\t\t\twindow.addEventListener('touchend', this.leaveCrop)\r\n\t\t\tthis.cropX = (e.clientX ? e.clientX : e.touches[0].clientX) - this.cropOffsertX\r\n\t\t\tthis.cropY = (e.clientY ? e.clientY : e.touches[0].clientY) - this.cropOffsertY\r\n\t\t},\r\n\r\n\t\tmoveCrop (e) {\r\n\t\t\te.preventDefault()\r\n\t\t\tvar nowX = e.clientX ? e.clientX : e.touches[0].clientX\r\n      var nowY = e.clientY ? e.clientY : e.touches[0].clientY\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tvar fw = ~~(nowX - this.cropX)\r\n\t\t\t\tvar fh = ~~(nowY - this.cropY)\r\n\t\t\t\tif (fw <= 1) {\r\n\t\t\t\t\tthis.cropOffsertX = 1\r\n\t\t\t\t} else if (~~(fw + this.cropW) > this.w) {\r\n\t\t\t\t\tthis.cropOffsertX = this.w - this.cropW - 1\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.cropOffsertX = fw\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (fh <= 1) {\r\n\t\t\t\t\tthis.cropOffsertY = 1\r\n\t\t\t\t} else if (~~(fh + this.cropH) > this.h) {\r\n\t\t\t\t\tthis.cropOffsertY = this.h - this.cropH - 1\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.cropOffsertY = fh\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tleaveCrop (e) {\r\n\t\t\twindow.removeEventListener('mousemove', this.moveCrop)\r\n\t\t\twindow.removeEventListener('mouseup', this.leaveCrop)\r\n\t\t\twindow.removeEventListener('touchmove', this.moveCrop)\r\n\t\t\twindow.removeEventListener('touchend', this.leaveCrop)\r\n\t\t},\r\n\t\t// 获取转换成base64 的图片信息\r\n\t\tgetCropData (cb) {\r\n\t\t\tlet canvas = document.createElement('canvas')\r\n\t\t\tlet img = new Image\r\n\t\t\tlet rotate = this.rotate\r\n\t\t\tlet trueWidth = this.trueWidth\r\n\t\t\tlet trueHeight = this.trueHeight\r\n\t\t\tlet cropOffsertX = this.cropOffsertX\r\n\t\t\tlet cropOffsertY = this.cropOffsertY\r\n\t\t\timg.onload = () => {\r\n\t\t\t\tif (~~(this.cropW) !== 0) {\r\n\t\t\t\t\tlet ctx = canvas.getContext('2d')\r\n\t\t\t\t\tlet width = this.cropW\r\n\t\t\t\t\tlet height = this.cropH\r\n\t\t\t\t\tlet imgW = trueWidth * this.scale\r\n\t\t\t\t\tlet imgH = trueHeight * this.scale\r\n\t\t\t\t\t// 图片x轴偏移\r\n\t\t\t\t\tlet dx = (this.x - cropOffsertX) + this.trueWidth * (1 - this.scale) / 2\r\n\t\t\t\t\t// 图片y轴偏移\r\n\t\t\t\t\tlet dy = (this.y - cropOffsertY) + this.trueHeight * (1 - this.scale) / 2\r\n\t\t\t\t\t// console.log(dx, dy)\r\n\t\t\t\t\t//保存状态\r\n\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\tctx.save()\r\n\t\t\t\t\tswitch (rotate) {\r\n    \t\t\t\tcase 0:\r\n\t\t\t\t\t\t\tif (!this.full) {\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx, dy, imgW, imgH)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// 输出原图比例截图\r\n\t\t\t\t\t\t\t\tcanvas.width = width / this.scale\r\n\t\t\t\t\t\t\t\tcanvas.height = height / this.scale\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx / this.scale, dy / this.scale, imgW / this.scale, imgH / this.scale)\r\n\t\t\t\t\t\t\t}\r\n    \t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase -3:\r\n\t\t\t\t\t\t  if (!this.full) {\r\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\r\n\t\t\t\t\t\t\t\tdx = dx + (imgW - imgH) / 2\r\n\t\t\t\t\t\t\t\tdy = dy + (imgH - imgW) / 2\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dy, -dx - imgH, imgW, imgH)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcanvas.width = width / this.scale\r\n\t\t\t\t\t\t\t\tcanvas.height = height / this.scale\r\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\r\n\t\t\t\t\t\t\t\tdx = dx / this.scale + (imgW / this.scale - imgH / this.scale) / 2\r\n\t\t\t\t\t\t\t\tdy = dy / this.scale + (imgH / this.scale - imgW / this.scale) / 2\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dy, (-dx - imgH / this.scale), imgW / this.scale, imgH / this.scale)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase -2:\r\n\t\t\t\t\t\t\tif (!this.full) {\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dx - imgW, -dy - imgH, imgW, imgH)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcanvas.width = width / this.scale\r\n\t\t\t\t\t\t\t\tcanvas.height = height / this.scale\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tdx = dx / this.scale\r\n\t\t\t\t\t\t\t\tdy = dy / this.scale\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dx - imgW / this.scale, -dy - imgH / this.scale, imgW / this.scale, imgH / this.scale)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tcase -1:\r\n\t\t\t\t\t\t\tif (!this.full) {\r\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\r\n\t\t\t\t\t\t\t\tdx = dx + (imgW - imgH) / 2\r\n\t\t\t\t\t\t\t\tdy = dy + (imgH - imgW) / 2\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dy - imgW, dx, imgW, imgH)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcanvas.width = width / this.scale\r\n\t\t\t\t\t\t\t\tcanvas.height = height / this.scale\r\n\t\t\t\t\t\t\t\t// 换算图片旋转后的坐标弥补\r\n\t\t\t\t\t\t\t\tdx = dx / this.scale + (imgW / this.scale - imgH / this.scale) / 2\r\n\t\t\t\t\t\t\t\tdy = dy / this.scale + (imgH / this.scale - imgW / this.scale) / 2\r\n\t\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, -dy - imgW / this.scale, dx, imgW / this.scale, imgH / this.scale)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n    \t\t\t\tdefault:\r\n\t\t\t\t\t\t\tif (!this.full) {\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx, dy, imgW, imgH)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// 输出原图比例截图\r\n\t\t\t\t\t\t\t\tcanvas.width = width / this.scale\r\n\t\t\t\t\t\t\t\tcanvas.height = height / this.scale\r\n\t\t\t\t\t\t\t\tctx.drawImage(img, dx / this.scale, dy / this.scale, imgW / this.scale, imgH / this.scale)\r\n\t\t\t\t\t\t\t}\r\n    \t\t\t}\r\n\t\t\t\t\tctx.restore()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet width = trueWidth * this.scale\r\n\t\t\t\t\tlet height = trueHeight * this.scale\r\n\t\t\t\t\tlet ctx = canvas.getContext('2d')\r\n\t\t\t\t\tctx.save()\r\n    \t\t\tswitch (rotate) {\r\n    \t\t\t\tcase 0:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height)\r\n    \t\t\t\tbreak\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase -3:\r\n\t\t\t\t\t\t\t// 旋转90度 或者-270度 宽度和高度对调\r\n\t\t\t\t\t\t\tcanvas.width = height\r\n\t\t\t\t\t\t\tcanvas.height = width\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, -height, width, height)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase -2:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, -width, -height, width, height)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tcase -1:\r\n\t\t\t\t\t\t\tcanvas.width = height\r\n\t\t\t\t\t\t\tcanvas.height = width\r\n\t\t\t\t\t\t\tctx.rotate(rotate * 90  * Math.PI / 180)\r\n\t\t\t\t\t\t\tctx.drawImage(img, -width, 0, width, height)\r\n\t\t\t\t\t\t\tbreak\r\n    \t\t\t\tdefault:\r\n\t\t\t\t\t\t\tcanvas.width = width\r\n\t\t\t\t\t\t\tcanvas.height = height\r\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0, width, height)\r\n    \t\t\t}\r\n\t\t\t\t\tctx.restore()\r\n\t\t\t\t}\r\n\t\t\t\tlet data = canvas.toDataURL('image/' + this.outputType, this.outputSize)\r\n\t\t\t\tcb(data)\r\n\t\t\t}\r\n\t\t\t// 判断图片是否是base64\r\n\t\t\tvar s = this.img.substr(0, 4)\r\n\t\t\tif (s !== 'data') {\r\n\t\t\t\timg.crossOrigin = 'anonymous'\r\n\t\t\t}\r\n\t\t\timg.src = this.imgs\r\n\t\t},\r\n\t\t//转化base64 为blob对象\r\n\t\tgetCropBlob(cb) {\r\n\t\t\tthis.getCropData((data) => {\r\n\t\t\t\tvar arr = data.split(',')\r\n\t\t\t  var mime = arr[0].match(/:(.*?);/)[1]\r\n\t\t\t  var bstr = atob(arr[1])\r\n\t\t\t  var n = bstr.length\r\n\t\t\t  var u8arr = new Uint8Array(n)\r\n\t\t\t\twhile (n--) {\r\n\t\t\t    u8arr[n] = bstr.charCodeAt(n)\r\n\t\t\t  }\r\n\t\t\t\tcb(\r\n\t\t\t\t\tnew Blob([u8arr], {\r\n\t\t\t    \ttype: mime\r\n\t\t\t  \t}\r\n\t\t\t\t))\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t// 自动预览函数\r\n\t\tshowPreview() {\r\n\t\t\tvar obj = {}\r\n\t\t\tobj.div = {\r\n\t\t\t\t'width': this.cropW + 'px',\r\n\t\t\t\t'height': this.cropH + 'px'\r\n\t\t\t}\r\n\t\t\tobj.img = {\r\n\t\t\t\t'width': this.trueWidth + 'px',\r\n\t\t\t\t'height': this.trueHeight + 'px',\r\n\t\t\t\t'transform': 'scale(' + this.scale + ',' + this.scale + ') ' + 'translate3d('+ (this.x - this.cropOffsertX) / this.scale  + 'px,' + (this.y - this.cropOffsertY) / this.scale + 'px,' + '0)'\r\n\t\t\t\t+ 'rotateZ('+ this.rotate * 90 + 'deg)'\r\n\t\t\t}\r\n\t\t\tobj.w = this.cropW\r\n\t\t\tobj.h = this.cropH\r\n\t\t\tobj.url = this.imgs\r\n\t\t\tthis.$emit('realTime',  obj)\r\n\t\t},\r\n\t\t// reload 图片布局函数\r\n\t\treload () {\r\n\t\t\tlet img = new Image\r\n\t\t\timg.onload = () => {\r\n\t\t\t\t// 读取图片的信息原始信息， 解析是否需要旋转\r\n\t\t\t\t// 读取图片的旋转信息\r\n\t\t\t\t// 得到外层容器的宽度高度\r\n\t\t\t\tthis.w =  ~~(window.getComputedStyle(this.$refs.cropper).width.replace('px', ''))\r\n\t\t\t\tthis.h =  ~~(window.getComputedStyle(this.$refs.cropper).height.replace('px', ''))\r\n\r\n\t\t\t\t// 存入图片真实高度\r\n\t\t\t\tthis.trueWidth = img.width\r\n\t\t\t\tthis.trueHeight = img.height\r\n\r\n\t\t\t\tif (this.trueWidth > this.w) {\r\n\t\t\t\t\t// 如果图片宽度大于容器宽度\r\n\t\t\t\t\tthis.scale = this.w / this.trueWidth\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.trueHeight * this.scale > this.h) {\r\n\t\t\t\t\tthis.scale = this.h / this.trueHeight\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.$nextTick(() => {\r\n\t\t\t\t\tthis.x = -(this.trueWidth - this.trueWidth * this.scale) / 2 + (this.w - this.trueWidth * this.scale) / 2\r\n\t\t\t\t\tthis.y = -(this.trueHeight - this.trueHeight * this.scale) / 2 + (this.h - this.trueHeight * this.scale) / 2\r\n\t\t\t\t\tthis.loading = false\r\n\t\t\t\t\t// 获取是否开启了自动截图\r\n\t\t\t\t\tif (this.autoCrop) {\r\n\t\t\t\t\t\tthis.goAutoCrop()\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\timg.src = this.imgs\r\n\t\t},\r\n\t\t// 自动截图函数\r\n\t\tgoAutoCrop () {\r\n\t\t\tthis.cropping = true\r\n\t\t\t// 截图框默认大小\r\n\t\t\t// 如果为0 那么计算容器大小 默认为80%\r\n\t\t\tvar w = this.autoCropWidth\r\n\t\t\tvar h = this.autoCropHeight\r\n\t\t\tif (w === 0 || h === 0) {\r\n\t\t\t\tw = this.w * 0.8\r\n\t\t\t\th = this.h * 0.8\r\n\t\t\t}\r\n\t\t\tw = w > this.w ? this.w : w\r\n\t\t\th = h > this.h ? this.h : h\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\th = w / this.fixedNumber[0] * this.fixedNumber[1]\r\n\t\t\t}\r\n\t\t\t// 如果比例之后 高度大于h\r\n\t\t\tif (h > this.h) {\r\n\t\t\t\th = this.h\r\n\t\t\t\tw = h / this.fixedNumber[1] * this.fixedNumber[0]\r\n\t\t\t}\r\n\t\t\tthis.changeCrop(w, h)\r\n\t\t},\r\n\t\t// 手动改变截图框大小函数\r\n\t\tchangeCrop (w, h) {\r\n\t\t\t// 判断是否大于容器\r\n\t\t\tthis.cropW = w\r\n\t\t\tthis.cropH = h\r\n\t\t\t// 居中走一走\r\n\t\t\tthis.cropOffsertX = (this.w - w) / 2\r\n\t\t\tthis.cropOffsertY = (this.h - h) / 2\r\n\t\t},\r\n\t\t// 重置函数， 恢复组件置初始状态\r\n\t\trefresh () {\r\n\t\t\t// console.log('refresh')\r\n\t\t},\r\n\r\n\t\t// 向左边旋转\r\n\t\trotateLeft () {\r\n\t\t\tthis.rotate = this.rotate <= -3 ? 0 : this.rotate - 1\r\n\t\t},\r\n\r\n\t\t// 向右边旋转\r\n\t\trotateRight () {\r\n\t\t\tthis.rotate = this.rotate >= 3 ? 0 : this.rotate + 1\r\n\t\t},\r\n\r\n\t\t// 清除旋转\r\n\t\trotateClear () {\r\n\t\t\tthis.rotate = 0\r\n\t\t}\r\n\t},\r\n\tmounted () {\r\n\t\tthis.showPreview()\r\n\t\tthis.checkedImg()\r\n\t\tvar u = navigator.userAgent\r\n\t\tthis.isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)\r\n\t}\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\t.vue-cropper {\r\n\t\tposition: relative;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\tbox-sizing: border-box;\r\n\t\tuser-select: none;\r\n\t\t-webkit-user-select: none;\r\n\t\t-moz-user-select: none;\r\n\t\t-ms-user-select: none;\r\n\t\tdirection: ltr;\r\n\t\ttouch-action: none;\r\n  \tbackground-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC');\r\n\t}\r\n\r\n\t.cropper-box, .cropper-box-canvas, .cropper-drag-box, .cropper-crop-box, .cropper-face{\r\n\t\tposition: absolute;\r\n\t\ttop: 0;\r\n\t\tright: 0;\r\n\t\tbottom: 0;\r\n\t\tleft: 0;\r\n\t\tuser-select: none;\r\n\t}\r\n\r\n\t.cropper-box-canvas img {\r\n\t\tposition: relative;\r\n\t\tuser-select: none;\r\n\t\ttransform: none;\r\n\t}\r\n\r\n\t.cropper-box {\r\n\t\toverflow: hidden;\r\n\t}\r\n\r\n\t.cropper-move {\r\n\t\tcursor: move;\r\n\t}\r\n\r\n\t.cropper-crop {\r\n    cursor: crosshair;\r\n\t}\r\n\r\n\t.cropper-modal {\r\n\t\tbackground: rgba(0, 0, 0, 0.5);\r\n\t}\r\n\r\n\t.cropper-crop-box {\r\n\t\t/*border: 2px solid #39f;*/\r\n\t}\r\n\r\n\t.cropper-view-box {\r\n\t\tdisplay: block;\r\n\t\toverflow: hidden;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\toutline: 1px solid #39f;\r\n    outline-color: rgba(51, 153, 255, 0.75);\r\n\t\tuser-select: none;\r\n\t}\r\n\r\n\t.cropper-view-box img {\r\n\t\tuser-select: none;\r\n\t}\r\n\r\n\t.cropper-face {\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\tbackground-color: #fff;\r\n\t\topacity: 0.1;\r\n\t}\r\n\r\n\t.crop-info {\r\n\t\tposition: absolute;\r\n\t\tleft: 0px;\r\n\t\tmin-width: 65px;\r\n\t\ttext-align: center;\r\n\t\tcolor: white;\r\n\t\tline-height: 20px;\r\n\t\tbackground-color: rgba(0, 0, 0, 0.8);\r\n\t\tfont-size: 12px;\r\n\t}\r\n\r\n\t.crop-line {\r\n\t\tposition: absolute;\r\n\t\tdisplay: block;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\topacity: .1;\r\n\t}\r\n\r\n\t.line-w {\r\n\t\ttop: -3px;\r\n    left: 0;\r\n    height: 5px;\r\n    cursor: n-resize;\r\n\t}\r\n\r\n\t.line-a {\r\n\t\ttop: 0;\r\n    left: -3px;\r\n    width: 5px;\r\n    cursor: w-resize;\r\n\t}\r\n\r\n\t.line-s {\r\n\t\tbottom: -3px;\r\n\t\tleft: 0;\r\n\t\theight: 5px;\r\n\t\tcursor: s-resize;\r\n\t}\r\n\r\n\t.line-d {\r\n\t\ttop: 0;\r\n    right: -3px;\r\n    width: 5px;\r\n    cursor: e-resize;\r\n\t}\r\n\r\n\t.crop-point {\r\n\t\tposition: absolute;\r\n\t\twidth: 8px;\r\n    height: 8px;\r\n    opacity: .75;\r\n    background-color: #39f;\r\n\t\tborder-radius: 100%;\r\n\t}\r\n\r\n\t.point1 {\r\n\t\ttop: -4px;\r\n    left: -4px;\r\n    cursor: nw-resize;\r\n\t}\r\n\r\n\t.point2 {\r\n\t\ttop: -5px;\r\n    left: 50%;\r\n    margin-left: -3px;\r\n    cursor: n-resize;\r\n\t}\r\n\r\n\t.point3 {\r\n\t\ttop: -4px;\r\n    right: -4px;\r\n    cursor: ne-resize;\r\n\t}\r\n\r\n\t.point4 {\r\n\t\ttop: 50%;\r\n    left: -4px;\r\n    margin-top: -3px;\r\n    cursor: w-resize;\r\n\t}\r\n\r\n\t.point5 {\r\n\t\ttop: 50%;\r\n    right: -4px;\r\n    margin-top: -3px;\r\n    cursor: w-resize;\r\n\t}\r\n\r\n\t.point6 {\r\n\t\tbottom: -5px;\r\n\t\tleft: -4px;\r\n\t\tcursor: sw-resize;\r\n\t}\r\n\r\n\t.point7 {\r\n\t\tbottom: -5px;\r\n\t\tleft: 50%;\r\n\t\tmargin-left: -3px;\r\n\t\tcursor: s-resize;\r\n\t}\r\n\r\n\t.point8 {\r\n\t\tbottom: -5px;\r\n\t\tright: -4px;\r\n\t\tcursor: nw-resize;\r\n\t}\r\n\r\n\t@media screen and (max-width: 500px) {\r\n\t\t.crop-point {\r\n\t\t\tposition: absolute;\r\n\t\t\twidth: 20px;\r\n\t\t\theight: 20px;\r\n\t\t\topacity: .45;\r\n\t\t\tbackground-color: #39f;\r\n\t\t\tborder-radius: 100%;\r\n\t\t}\r\n\r\n\t\t.point1 {\r\n\t\t\ttop: -10px;\r\n\t    left: -10px;\r\n\t\t}\r\n\r\n\t\t.point2, .point4, .point5, .point7 {\r\n\t\t\tdisplay: none;\r\n\t\t}\r\n\r\n\t\t.point3 {\r\n\t\t\ttop: -10px;\r\n\t\t\tright: -10px;\r\n\t\t}\r\n\r\n\t\t.point4 {\r\n\t\t\ttop: 0;\r\n\t\t\tleft: 0;\r\n\t\t}\r\n\r\n\t\t.point6 {\r\n\t\t\tbottom: -10px;\r\n\t\t\tleft: -10px;\r\n\t\t}\r\n\r\n\t\t.point8 {\r\n\t\t\tbottom: -10px;\r\n\t\t\tright: -10px;\r\n\t\t}\r\n\t}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/components/Course/vue-cropper.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"wrapper\"},[_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.model),expression:\"model\"}],staticClass:\"model\",on:{\"click\":function($event){_vm.model = false}}},[_c('div',{staticClass:\"model-show\"},[_c('img',{attrs:{\"src\":_vm.modelSrc,\"alt\":\"\"}})]),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.modelBtn),expression:\"modelBtn\"}],staticClass:\"container\",staticStyle:{\"width\":\"20%\",\"margin-top\":\"-10%\",\"margin-left\":\"44%\"},on:{\"click\":function($event){_vm.modelBtn = false}}},[_c('div',{staticStyle:{\"margin-left\":\"-25%\",\"margin-top\":\"-2%\"}},[_c('font',{attrs:{\"size\":\"2\",\"color\":\"#ffffff\",\"face\":\"微软雅黑\"}},[_vm._v(\"✱ 【确定】后将会上传图片为【课程封面】\")]),_c('br')],1),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"4%\"}},[_c('button',{staticClass:\"btn btn-info\",on:{\"click\":_vm.addDB}},[_vm._v(\"确定\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"5%\"}},[_vm._v(\"取消\")])])])]),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('div',{staticClass:\"show-info\"},[_c('h2',{staticClass:\"title\"},[_vm._v(\"选择课程封面图片\")]),_vm._v(\" \"),_c('div',{staticClass:\"test\"},[_c('vueCropper',{ref:\"cropper2\",attrs:{\"img\":_vm.example2.img,\"outputSize\":_vm.example2.size,\"outputType\":_vm.example2.outputType,\"info\":_vm.example2.info,\"canScale\":_vm.example2.canScale,\"autoCrop\":_vm.example2.autoCrop,\"autoCropWidth\":_vm.example2.width,\"autoCropHeight\":_vm.example2.height,\"fixed\":_vm.example2.fixed,\"fixedNumber\":_vm.example2.fixedNumber}})],1),_vm._v(\" \"),_c('div',{staticStyle:{\"margin-top\":\"1%\"}},[_c('label',{staticClass:\"btn btn-warning\",attrs:{\"for\":\"upload2\"}},[_vm._v(\"选择图片\")]),_vm._v(\" \"),_c('input',{staticStyle:{\"position\":\"absolute\",\"clip\":\"rect(0 0 0 0)\"},attrs:{\"type\":\"file\",\"id\":\"upload2\",\"accept\":\"image/png, image/jpeg, image/gif, image/jpg\"},on:{\"change\":function($event){_vm.uploadImg($event, 2)}}}),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-info\",staticStyle:{\"margin-left\":\"1%\"},on:{\"click\":function($event){_vm.finish2('base64')}}},[_vm._v(\"预览\")]),_vm._v(\" \"),_c('button',{staticClass:\"btn btn-success\",staticStyle:{\"margin-left\":\"1%\"},on:{\"click\":_vm.upload}},[_vm._v(\"完成\")])])])])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-loader@13.5.0@vue-loader/lib/template-compiler?{\"id\":\"data-v-3bb4743c\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/_vue-loader@13.5.0@vue-loader/lib/selector.js?type=template&index=0!./src/components/Course/cropper.vue\n// module id = tQYy\n// module chunks = 5","(function() {\r\n\r\n    var debug = false;\r\n\r\n    var root = this;\r\n\r\n    var EXIF = function(obj) {\r\n        if (obj instanceof EXIF) return obj;\r\n        if (!(this instanceof EXIF)) return new EXIF(obj);\r\n        this.EXIFwrapped = obj;\r\n    };\r\n\r\n    if (typeof exports !== 'undefined') {\r\n        if (typeof module !== 'undefined' && module.exports) {\r\n            exports = module.exports = EXIF;\r\n        }\r\n        exports.EXIF = EXIF;\r\n    } else {\r\n        root.EXIF = EXIF;\r\n    }\r\n\r\n    var ExifTags = EXIF.Tags = {\r\n\r\n        // version tags\r\n        0x9000 : \"ExifVersion\",             // EXIF version\r\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\r\n\r\n        // colorspace tags\r\n        0xA001 : \"ColorSpace\",              // Color space information tag\r\n\r\n        // image configuration\r\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\r\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\r\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\r\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\r\n\r\n        // user information\r\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\r\n        0x9286 : \"UserComment\",             // Comments by user\r\n\r\n        // related file\r\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\r\n\r\n        // date and time\r\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\r\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\r\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\r\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\r\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\r\n\r\n        // picture-taking conditions\r\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\r\n        0x829D : \"FNumber\",                 // F number\r\n        0x8822 : \"ExposureProgram\",         // Exposure program\r\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\r\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\r\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\r\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\r\n        0x9202 : \"ApertureValue\",           // Lens aperture\r\n        0x9203 : \"BrightnessValue\",         // Value of brightness\r\n        0x9204 : \"ExposureBias\",            // Exposure bias\r\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\r\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\r\n        0x9207 : \"MeteringMode\",            // Metering mode\r\n        0x9208 : \"LightSource\",             // Kind of light source\r\n        0x9209 : \"Flash\",                   // Flash status\r\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\r\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\r\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\r\n        0xA20C : \"SpatialFrequencyResponse\",    //\r\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\r\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\r\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\r\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\r\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\r\n        0xA217 : \"SensingMethod\",           // Image sensor type\r\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\r\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\r\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\r\n        0xA401 : \"CustomRendered\",          // Special processing\r\n        0xA402 : \"ExposureMode\",            // Exposure mode\r\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\r\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\r\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\r\n        0xA406 : \"SceneCaptureType\",        // Type of scene\r\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\r\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\r\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\r\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\r\n        0xA40B : \"DeviceSettingDescription\",    //\r\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\r\n\r\n        // other tags\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\r\n    };\r\n\r\n    var TiffTags = EXIF.TiffTags = {\r\n        0x0100 : \"ImageWidth\",\r\n        0x0101 : \"ImageHeight\",\r\n        0x8769 : \"ExifIFDPointer\",\r\n        0x8825 : \"GPSInfoIFDPointer\",\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0x0102 : \"BitsPerSample\",\r\n        0x0103 : \"Compression\",\r\n        0x0106 : \"PhotometricInterpretation\",\r\n        0x0112 : \"Orientation\",\r\n        0x0115 : \"SamplesPerPixel\",\r\n        0x011C : \"PlanarConfiguration\",\r\n        0x0212 : \"YCbCrSubSampling\",\r\n        0x0213 : \"YCbCrPositioning\",\r\n        0x011A : \"XResolution\",\r\n        0x011B : \"YResolution\",\r\n        0x0128 : \"ResolutionUnit\",\r\n        0x0111 : \"StripOffsets\",\r\n        0x0116 : \"RowsPerStrip\",\r\n        0x0117 : \"StripByteCounts\",\r\n        0x0201 : \"JPEGInterchangeFormat\",\r\n        0x0202 : \"JPEGInterchangeFormatLength\",\r\n        0x012D : \"TransferFunction\",\r\n        0x013E : \"WhitePoint\",\r\n        0x013F : \"PrimaryChromaticities\",\r\n        0x0211 : \"YCbCrCoefficients\",\r\n        0x0214 : \"ReferenceBlackWhite\",\r\n        0x0132 : \"DateTime\",\r\n        0x010E : \"ImageDescription\",\r\n        0x010F : \"Make\",\r\n        0x0110 : \"Model\",\r\n        0x0131 : \"Software\",\r\n        0x013B : \"Artist\",\r\n        0x8298 : \"Copyright\"\r\n    };\r\n\r\n    var GPSTags = EXIF.GPSTags = {\r\n        0x0000 : \"GPSVersionID\",\r\n        0x0001 : \"GPSLatitudeRef\",\r\n        0x0002 : \"GPSLatitude\",\r\n        0x0003 : \"GPSLongitudeRef\",\r\n        0x0004 : \"GPSLongitude\",\r\n        0x0005 : \"GPSAltitudeRef\",\r\n        0x0006 : \"GPSAltitude\",\r\n        0x0007 : \"GPSTimeStamp\",\r\n        0x0008 : \"GPSSatellites\",\r\n        0x0009 : \"GPSStatus\",\r\n        0x000A : \"GPSMeasureMode\",\r\n        0x000B : \"GPSDOP\",\r\n        0x000C : \"GPSSpeedRef\",\r\n        0x000D : \"GPSSpeed\",\r\n        0x000E : \"GPSTrackRef\",\r\n        0x000F : \"GPSTrack\",\r\n        0x0010 : \"GPSImgDirectionRef\",\r\n        0x0011 : \"GPSImgDirection\",\r\n        0x0012 : \"GPSMapDatum\",\r\n        0x0013 : \"GPSDestLatitudeRef\",\r\n        0x0014 : \"GPSDestLatitude\",\r\n        0x0015 : \"GPSDestLongitudeRef\",\r\n        0x0016 : \"GPSDestLongitude\",\r\n        0x0017 : \"GPSDestBearingRef\",\r\n        0x0018 : \"GPSDestBearing\",\r\n        0x0019 : \"GPSDestDistanceRef\",\r\n        0x001A : \"GPSDestDistance\",\r\n        0x001B : \"GPSProcessingMethod\",\r\n        0x001C : \"GPSAreaInformation\",\r\n        0x001D : \"GPSDateStamp\",\r\n        0x001E : \"GPSDifferential\"\r\n    };\r\n\r\n     // EXIF 2.3 Spec\r\n    var IFD1Tags = EXIF.IFD1Tags = {\r\n        0x0100: \"ImageWidth\",\r\n        0x0101: \"ImageHeight\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0103: \"Compression\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x0111: \"StripOffsets\",\r\n        0x0112: \"Orientation\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x011A: \"XResolution\",\r\n        0x011B: \"YResolution\",\r\n        0x011C: \"PlanarConfiguration\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\r\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x0214: \"ReferenceBlackWhite\"\r\n    };\r\n\r\n    var StringValues = EXIF.StringValues = {\r\n        ExposureProgram : {\r\n            0 : \"Not defined\",\r\n            1 : \"Manual\",\r\n            2 : \"Normal program\",\r\n            3 : \"Aperture priority\",\r\n            4 : \"Shutter priority\",\r\n            5 : \"Creative program\",\r\n            6 : \"Action program\",\r\n            7 : \"Portrait mode\",\r\n            8 : \"Landscape mode\"\r\n        },\r\n        MeteringMode : {\r\n            0 : \"Unknown\",\r\n            1 : \"Average\",\r\n            2 : \"CenterWeightedAverage\",\r\n            3 : \"Spot\",\r\n            4 : \"MultiSpot\",\r\n            5 : \"Pattern\",\r\n            6 : \"Partial\",\r\n            255 : \"Other\"\r\n        },\r\n        LightSource : {\r\n            0 : \"Unknown\",\r\n            1 : \"Daylight\",\r\n            2 : \"Fluorescent\",\r\n            3 : \"Tungsten (incandescent light)\",\r\n            4 : \"Flash\",\r\n            9 : \"Fine weather\",\r\n            10 : \"Cloudy weather\",\r\n            11 : \"Shade\",\r\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\r\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\r\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\r\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\r\n            17 : \"Standard light A\",\r\n            18 : \"Standard light B\",\r\n            19 : \"Standard light C\",\r\n            20 : \"D55\",\r\n            21 : \"D65\",\r\n            22 : \"D75\",\r\n            23 : \"D50\",\r\n            24 : \"ISO studio tungsten\",\r\n            255 : \"Other\"\r\n        },\r\n        Flash : {\r\n            0x0000 : \"Flash did not fire\",\r\n            0x0001 : \"Flash fired\",\r\n            0x0005 : \"Strobe return light not detected\",\r\n            0x0007 : \"Strobe return light detected\",\r\n            0x0009 : \"Flash fired, compulsory flash mode\",\r\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\r\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\r\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\r\n            0x0018 : \"Flash did not fire, auto mode\",\r\n            0x0019 : \"Flash fired, auto mode\",\r\n            0x001D : \"Flash fired, auto mode, return light not detected\",\r\n            0x001F : \"Flash fired, auto mode, return light detected\",\r\n            0x0020 : \"No flash function\",\r\n            0x0041 : \"Flash fired, red-eye reduction mode\",\r\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\r\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\r\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\r\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\r\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\r\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\r\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\r\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\r\n        },\r\n        SensingMethod : {\r\n            1 : \"Not defined\",\r\n            2 : \"One-chip color area sensor\",\r\n            3 : \"Two-chip color area sensor\",\r\n            4 : \"Three-chip color area sensor\",\r\n            5 : \"Color sequential area sensor\",\r\n            7 : \"Trilinear sensor\",\r\n            8 : \"Color sequential linear sensor\"\r\n        },\r\n        SceneCaptureType : {\r\n            0 : \"Standard\",\r\n            1 : \"Landscape\",\r\n            2 : \"Portrait\",\r\n            3 : \"Night scene\"\r\n        },\r\n        SceneType : {\r\n            1 : \"Directly photographed\"\r\n        },\r\n        CustomRendered : {\r\n            0 : \"Normal process\",\r\n            1 : \"Custom process\"\r\n        },\r\n        WhiteBalance : {\r\n            0 : \"Auto white balance\",\r\n            1 : \"Manual white balance\"\r\n        },\r\n        GainControl : {\r\n            0 : \"None\",\r\n            1 : \"Low gain up\",\r\n            2 : \"High gain up\",\r\n            3 : \"Low gain down\",\r\n            4 : \"High gain down\"\r\n        },\r\n        Contrast : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        Saturation : {\r\n            0 : \"Normal\",\r\n            1 : \"Low saturation\",\r\n            2 : \"High saturation\"\r\n        },\r\n        Sharpness : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        SubjectDistanceRange : {\r\n            0 : \"Unknown\",\r\n            1 : \"Macro\",\r\n            2 : \"Close view\",\r\n            3 : \"Distant view\"\r\n        },\r\n        FileSource : {\r\n            3 : \"DSC\"\r\n        },\r\n\r\n        Components : {\r\n            0 : \"\",\r\n            1 : \"Y\",\r\n            2 : \"Cb\",\r\n            3 : \"Cr\",\r\n            4 : \"R\",\r\n            5 : \"G\",\r\n            6 : \"B\"\r\n        }\r\n    };\r\n\r\n    function addEvent(element, event, handler) {\r\n        if (element.addEventListener) {\r\n            element.addEventListener(event, handler, false);\r\n        } else if (element.attachEvent) {\r\n            element.attachEvent(\"on\" + event, handler);\r\n        }\r\n    }\r\n\r\n    function imageHasData(img) {\r\n        return !!(img.exifdata);\r\n    }\r\n\r\n\r\n    function base64ToArrayBuffer(base64, contentType) {\r\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\r\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\r\n        var binary = atob(base64);\r\n        var len = binary.length;\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        for (var i = 0; i < len; i++) {\r\n            view[i] = binary.charCodeAt(i);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    function objectURLToBlob(url, callback) {\r\n        var http = new XMLHttpRequest();\r\n        http.open(\"GET\", url, true);\r\n        http.responseType = \"blob\";\r\n        http.onload = function(e) {\r\n            if (this.status == 200 || this.status === 0) {\r\n                callback(this.response);\r\n            }\r\n        };\r\n        http.send();\r\n    }\r\n\r\n    function getImageData(img, callback) {\r\n        function handleBinaryFile(binFile) {\r\n            var data = findEXIFinJPEG(binFile);\r\n            img.exifdata = data || {};\r\n            var iptcdata = findIPTCinJPEG(binFile);\r\n            img.iptcdata = iptcdata || {};\r\n            if (EXIF.isXmpEnabled) {\r\n               var xmpdata= findXMPinJPEG(binFile);\r\n               img.xmpdata = xmpdata || {};               \r\n            }\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n\r\n        if (img.src) {\r\n            if (/^data\\:/i.test(img.src)) { // Data URI\r\n                var arrayBuffer = base64ToArrayBuffer(img.src);\r\n                handleBinaryFile(arrayBuffer);\r\n\r\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\r\n                var fileReader = new FileReader();\r\n                fileReader.onload = function(e) {\r\n                    handleBinaryFile(e.target.result);\r\n                };\r\n                objectURLToBlob(img.src, function (blob) {\r\n                    fileReader.readAsArrayBuffer(blob);\r\n                });\r\n            } else {\r\n                var http = new XMLHttpRequest();\r\n                http.onload = function() {\r\n                    if (this.status == 200 || this.status === 0) {\r\n                        handleBinaryFile(http.response);\r\n                    } else {\r\n                        throw \"Could not load image\";\r\n                    }\r\n                    http = null;\r\n                };\r\n                http.open(\"GET\", img.src, true);\r\n                http.responseType = \"arraybuffer\";\r\n                http.send(null);\r\n            }\r\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\r\n            var fileReader = new FileReader();\r\n            fileReader.onload = function(e) {\r\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\r\n                handleBinaryFile(e.target.result);\r\n            };\r\n\r\n            fileReader.readAsArrayBuffer(img);\r\n        }\r\n    }\r\n\r\n    function findEXIFinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            marker;\r\n\r\n        while (offset < length) {\r\n            if (dataView.getUint8(offset) != 0xFF) {\r\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\r\n                return false; // not a valid marker, something is wrong\r\n            }\r\n\r\n            marker = dataView.getUint8(offset + 1);\r\n            if (debug) console.log(marker);\r\n\r\n            // we could implement handling for other markers here,\r\n            // but we're only looking for 0xFFE1 for EXIF data\r\n\r\n            if (marker == 225) {\r\n                if (debug) console.log(\"Found 0xFFE1 marker\");\r\n\r\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\r\n\r\n                // offset += 2 + file.getShortAt(offset+2, true);\r\n\r\n            } else {\r\n                offset += 2 + dataView.getUint16(offset+2);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function findIPTCinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength;\r\n\r\n\r\n        var isFieldSegmentStart = function(dataView, offset){\r\n            return (\r\n                dataView.getUint8(offset) === 0x38 &&\r\n                dataView.getUint8(offset+1) === 0x42 &&\r\n                dataView.getUint8(offset+2) === 0x49 &&\r\n                dataView.getUint8(offset+3) === 0x4D &&\r\n                dataView.getUint8(offset+4) === 0x04 &&\r\n                dataView.getUint8(offset+5) === 0x04\r\n            );\r\n        };\r\n\r\n        while (offset < length) {\r\n\r\n            if ( isFieldSegmentStart(dataView, offset )){\r\n\r\n                // Get the length of the name header (which is padded to an even number of bytes)\r\n                var nameHeaderLength = dataView.getUint8(offset+7);\r\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\r\n                // Check for pre photoshop 6 format\r\n                if(nameHeaderLength === 0) {\r\n                    // Always 4\r\n                    nameHeaderLength = 4;\r\n                }\r\n\r\n                var startOffset = offset + 8 + nameHeaderLength;\r\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\r\n\r\n                return readIPTCData(file, startOffset, sectionLength);\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n            // Not the marker, continue searching\r\n            offset++;\r\n\r\n        }\r\n\r\n    }\r\n    var IptcFieldMap = {\r\n        0x78 : 'caption',\r\n        0x6E : 'credit',\r\n        0x19 : 'keywords',\r\n        0x37 : 'dateCreated',\r\n        0x50 : 'byline',\r\n        0x55 : 'bylineTitle',\r\n        0x7A : 'captionWriter',\r\n        0x69 : 'headline',\r\n        0x74 : 'copyright',\r\n        0x0F : 'category'\r\n    };\r\n    function readIPTCData(file, startOffset, sectionLength){\r\n        var dataView = new DataView(file);\r\n        var data = {};\r\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\r\n        var segmentStartPos = startOffset;\r\n        while(segmentStartPos < startOffset+sectionLength) {\r\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\r\n                segmentType = dataView.getUint8(segmentStartPos+2);\r\n                if(segmentType in IptcFieldMap) {\r\n                    dataSize = dataView.getInt16(segmentStartPos+3);\r\n                    segmentSize = dataSize + 5;\r\n                    fieldName = IptcFieldMap[segmentType];\r\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\r\n                    // Check if we already stored a value with this name\r\n                    if(data.hasOwnProperty(fieldName)) {\r\n                        // Value already stored with this name, create multivalue field\r\n                        if(data[fieldName] instanceof Array) {\r\n                            data[fieldName].push(fieldValue);\r\n                        }\r\n                        else {\r\n                            data[fieldName] = [data[fieldName], fieldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        data[fieldName] = fieldValue;\r\n                    }\r\n                }\r\n\r\n            }\r\n            segmentStartPos++;\r\n        }\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\r\n        var entries = file.getUint16(dirStart, !bigEnd),\r\n            tags = {},\r\n            entryOffset, tag,\r\n            i;\r\n\r\n        for (i=0;i<entries;i++) {\r\n            entryOffset = dirStart + i*12 + 2;\r\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\r\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n        }\r\n        return tags;\r\n    }\r\n\r\n\r\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n        var type = file.getUint16(entryOffset+2, !bigEnd),\r\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\r\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\r\n            offset,\r\n            vals, val, n,\r\n            numerator, denominator;\r\n\r\n        switch (type) {\r\n            case 1: // byte, 8-bit unsigned int\r\n            case 7: // undefined, 8-bit byte, value depending on field\r\n                if (numValues == 1) {\r\n                    return file.getUint8(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint8(offset + n);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 2: // ascii, 8-bit byte\r\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                return getStringFromDB(file, offset, numValues-1);\r\n\r\n            case 3: // short, 16 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint16(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 4: // long, 32 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 5:    // rational = two long values, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    numerator = file.getUint32(valueOffset, !bigEnd);\r\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\r\n                    val = new Number(numerator / denominator);\r\n                    val.numerator = numerator;\r\n                    val.denominator = denominator;\r\n                    return val;\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\r\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\r\n                        vals[n] = new Number(numerator / denominator);\r\n                        vals[n].numerator = numerator;\r\n                        vals[n].denominator = denominator;\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 9: // slong, 32 bit signed int\r\n                if (numValues == 1) {\r\n                    return file.getInt32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Given an IFD (Image File Directory) start offset\r\n    * returns an offset to next IFD or 0 if it's the last IFD.\r\n    */\r\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\r\n        //the first 2bytes means the number of directory entries contains in this IFD\r\n        var entries = dataView.getUint16(dirStart, !bigEnd);\r\n\r\n        // After last directory entry, there is a 4bytes of data,\r\n        // it means an offset to next IFD.\r\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\r\n\r\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\r\n    }\r\n\r\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\r\n        // get the IFD1 offset\r\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\r\n\r\n        if (!IFD1OffsetPointer) {\r\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\r\n            return {};\r\n        }\r\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\r\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\r\n            return {};\r\n        }\r\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\r\n\r\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\r\n\r\n        // EXIF 2.3 specification for JPEG format thumbnail\r\n\r\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\r\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\r\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\r\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\r\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\r\n\r\n        if (thumbTags['Compression']) {\r\n            // console.log('Thumbnail image found!');\r\n\r\n            switch (thumbTags['Compression']) {\r\n                case 6:\r\n                    // console.log('Thumbnail image format is JPEG');\r\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\r\n                    // extract the thumbnail\r\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\r\n                        var tLength = thumbTags.JpegIFByteCount;\r\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\r\n                            type: 'image/jpeg'\r\n                        });\r\n                    }\r\n                break;\r\n\r\n            case 1:\r\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\r\n                break;\r\n            default:\r\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\r\n            }\r\n        }\r\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\r\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\r\n        }\r\n        return thumbTags;\r\n    }\r\n\r\n    function getStringFromDB(buffer, start, length) {\r\n        var outstr = \"\";\r\n        for (n = start; n < start+length; n++) {\r\n            outstr += String.fromCharCode(buffer.getUint8(n));\r\n        }\r\n        return outstr;\r\n    }\r\n\r\n    function readEXIFData(file, start) {\r\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\r\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\r\n            return false;\r\n        }\r\n\r\n        var bigEnd,\r\n            tags, tag,\r\n            exifData, gpsData,\r\n            tiffOffset = start + 6;\r\n\r\n        // test for TIFF validity and endianness\r\n        if (file.getUint16(tiffOffset) == 0x4949) {\r\n            bigEnd = false;\r\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\r\n            bigEnd = true;\r\n        } else {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\r\n            return false;\r\n        }\r\n\r\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\r\n            return false;\r\n        }\r\n\r\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\r\n\r\n        if (firstIFDOffset < 0x00000008) {\r\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\r\n            return false;\r\n        }\r\n\r\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\r\n\r\n        if (tags.ExifIFDPointer) {\r\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\r\n            for (tag in exifData) {\r\n                switch (tag) {\r\n                    case \"LightSource\" :\r\n                    case \"Flash\" :\r\n                    case \"MeteringMode\" :\r\n                    case \"ExposureProgram\" :\r\n                    case \"SensingMethod\" :\r\n                    case \"SceneCaptureType\" :\r\n                    case \"SceneType\" :\r\n                    case \"CustomRendered\" :\r\n                    case \"WhiteBalance\" :\r\n                    case \"GainControl\" :\r\n                    case \"Contrast\" :\r\n                    case \"Saturation\" :\r\n                    case \"Sharpness\" :\r\n                    case \"SubjectDistanceRange\" :\r\n                    case \"FileSource\" :\r\n                        exifData[tag] = StringValues[tag][exifData[tag]];\r\n                        break;\r\n\r\n                    case \"ExifVersion\" :\r\n                    case \"FlashpixVersion\" :\r\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\r\n                        break;\r\n\r\n                    case \"ComponentsConfiguration\" :\r\n                        exifData[tag] =\r\n                            StringValues.Components[exifData[tag][0]] +\r\n                            StringValues.Components[exifData[tag][1]] +\r\n                            StringValues.Components[exifData[tag][2]] +\r\n                            StringValues.Components[exifData[tag][3]];\r\n                        break;\r\n                }\r\n                tags[tag] = exifData[tag];\r\n            }\r\n        }\r\n\r\n        if (tags.GPSInfoIFDPointer) {\r\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\r\n            for (tag in gpsData) {\r\n                switch (tag) {\r\n                    case \"GPSVersionID\" :\r\n                        gpsData[tag] = gpsData[tag][0] +\r\n                            \".\" + gpsData[tag][1] +\r\n                            \".\" + gpsData[tag][2] +\r\n                            \".\" + gpsData[tag][3];\r\n                        break;\r\n                }\r\n                tags[tag] = gpsData[tag];\r\n            }\r\n        }\r\n\r\n        // extract thumbnail\r\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\r\n\r\n        return tags;\r\n    }\r\n\r\n   function findXMPinJPEG(file) {\r\n\r\n        if (!('DOMParser' in self)) {\r\n            // console.warn('XML parsing not supported without DOMParser');\r\n            return;\r\n        }\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n           if (debug) console.log(\"Not a valid JPEG\");\r\n           return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            dom = new DOMParser();\r\n\r\n        while (offset < (length-4)) {\r\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\r\n                var startOffset = offset - 1;\r\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\r\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\r\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\r\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\r\n\r\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\r\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\r\n                //Without these namespaces, XML is thought to be invalid by parsers\r\n                xmpString = xmpString.slice(0, indexOfXmp)\r\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\r\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\r\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\r\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\r\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\r\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\r\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\r\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\r\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\r\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\r\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\r\n                            + xmpString.slice(indexOfXmp)\r\n\r\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\r\n                return xml2Object(domDocument);\r\n            } else{\r\n             offset++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function xml2json(xml) {\r\n        var json = {};\r\n      \r\n        if (xml.nodeType == 1) { // element node\r\n          if (xml.attributes.length > 0) {\r\n            json['@attributes'] = {};\r\n            for (var j = 0; j < xml.attributes.length; j++) {\r\n              var attribute = xml.attributes.item(j);\r\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\r\n            }\r\n          }\r\n        } else if (xml.nodeType == 3) { // text node\r\n          return xml.nodeValue;\r\n        }\r\n      \r\n        // deal with children\r\n        if (xml.hasChildNodes()) {\r\n          for(var i = 0; i < xml.childNodes.length; i++) {\r\n            var child = xml.childNodes.item(i);\r\n            var nodeName = child.nodeName;\r\n            if (json[nodeName] == null) {\r\n              json[nodeName] = xml2json(child);\r\n            } else {\r\n              if (json[nodeName].push == null) {\r\n                var old = json[nodeName];\r\n                json[nodeName] = [];\r\n                json[nodeName].push(old);\r\n              }\r\n              json[nodeName].push(xml2json(child));\r\n            }\r\n          }\r\n        }\r\n        \r\n        return json;\r\n    }\r\n\r\n    function xml2Object(xml) {\r\n        try {\r\n            var obj = {};\r\n            if (xml.children.length > 0) {\r\n              for (var i = 0; i < xml.children.length; i++) {\r\n                var item = xml.children.item(i);\r\n                var attributes = item.attributes;\r\n                for(var idx in attributes) {\r\n                    var itemAtt = attributes[idx];\r\n                    var dataKey = itemAtt.nodeName;\r\n                    var dataValue = itemAtt.nodeValue;\r\n\r\n                    if(dataKey !== undefined) {\r\n                        obj[dataKey] = dataValue;\r\n                    }\r\n                }\r\n                var nodeName = item.nodeName;\r\n\r\n                if (typeof (obj[nodeName]) == \"undefined\") {\r\n                  obj[nodeName] = xml2json(item);\r\n                } else {\r\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\r\n                    var old = obj[nodeName];\r\n\r\n                    obj[nodeName] = [];\r\n                    obj[nodeName].push(old);\r\n                  }\r\n                  obj[nodeName].push(xml2json(item));\r\n                }\r\n              }\r\n            } else {\r\n              obj = xml.textContent;\r\n            }\r\n            return obj;\r\n          } catch (e) {\r\n              console.log(e.message);\r\n          }\r\n    }\r\n\r\n    EXIF.enableXmp = function() {\r\n        EXIF.isXmpEnabled = true;\r\n    }\r\n\r\n    EXIF.disableXmp = function() {\r\n        EXIF.isXmpEnabled = false;\r\n    }\r\n\r\n    EXIF.getData = function(img, callback) {\r\n        if (((self.Image && img instanceof self.Image)\r\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\r\n            && !img.complete)\r\n            return false;\r\n\r\n        if (!imageHasData(img)) {\r\n            getImageData(img, callback);\r\n        } else {\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    EXIF.getTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.exifdata[tag];\r\n    }\r\n    \r\n    EXIF.getIptcTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.iptcdata[tag];\r\n    }\r\n\r\n    EXIF.getAllTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.exifdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n    \r\n    EXIF.getAllIptcTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.iptcdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    EXIF.pretty = function(img) {\r\n        if (!imageHasData(img)) return \"\";\r\n        var a,\r\n            data = img.exifdata,\r\n            strPretty = \"\";\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                if (typeof data[a] == \"object\") {\r\n                    if (data[a] instanceof Number) {\r\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\r\n                    } else {\r\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\r\n                    }\r\n                } else {\r\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n        return strPretty;\r\n    }\r\n\r\n    EXIF.readFromBinaryFile = function(file) {\r\n        return findEXIFinJPEG(file);\r\n    }\r\n\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('exif-js', [], function() {\r\n            return EXIF;\r\n        });\r\n    }\r\n}.call(this));\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/exif.js\n// module id = yOBD\n// module chunks = 5"],"sourceRoot":""}